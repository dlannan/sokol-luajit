LJØ¨
local t=package.preload;t['F:.devjit.Thunc.sokol-luajit.tools.dirtools']=load("\27LJ\2\8+F:.devjit.Thunc.sokol-luajit.tools.dirtoolsê\3\0\1\11\1\12\0*M\
\0165\1\0\0005\2\1\0006\3\2\0006\4\2\0009\4\3\4'\5\4\0\18\6\0\0'\7\5\0-\8\0\0009\8\6\0088\8\8\1'\9\7\0-\
\0\0009\
\6\
8\
\
\2&\4\
\4=\4\3\0036\3\2\0006\4\2\0009\4\8\4'\5\4\0\18\6\0\0'\7\9\0&\4\7\4=\4\8\0036\3\2\0006\4\2\0009\4\8\4'\5\4\0\18\6\0\0'\7\
\0&\4\7\4=\4\8\0036\3\2\0006\4\2\0009\4\8\4'\5\4\0\18\6\0\0'\7\11\0&\4\7\4=\4\8\3K\0\1\0\0¿\11/?.lua\14lua/?.lua\21/ffi/sokol/?.lua\9path\8/?.\7os\9bin/\6;\
cpath\12package\1\0\3\12Windows\8dll\11MacOSX\7so\
Linux\7so\1\0\3\12Windows\
win64\11MacOSX\
macos\
Linux\
linux\1\6\12\12\12\12\12\12\12\12\12\12\12\12\12\12\12\13\13\13\13\13\13\13\13\14\14\14\14\14\14\14\14\15\15\15\15\15\15\15\15\16ffi\0path\0\0+folders\0\2)extensions\0\1(\0ã\1\0\2\7\0\5\0\19\30!\0056\2\0\0009\2\1\2\18\4\0\0'\5\2\0'\6\3\0B\2\4\2\18\0\2\0006\2\0\0009\2\1\2\18\4\1\0'\5\2\0'\6\3\0B\2\4\2\18\1\2\0006\2\0\0009\2\4\2\18\4\0\0\18\5\1\0D\2\3\0\
match\6_\7%-\9gsub\11string\2\2\2\2\2\2\2\3\3\3\3\3\3\3\4\4\4\4\4p1\0\0\20p2\0\0\20\0<\0\2\5\1\0\0\5\28*\3\18\2\0\0-\3\0\0\18\4\1\0&\2\4\2L\2\2\0\4Ä\2\2\2\2\2sep\0base\0\0\6addition\0\0\6\0Á\5\0\0\14\2\20\1bæ\0011'4\0\0\0-\1\0\0009\1\0\1\7\1\1\0X\0011Ä'\1\2\0006\2\3\0009\2\4\2\18\4\1\0'\5\5\0B\2\3\2\15\0\2\0X\3TÄ\18\5\2\0009\3\6\2'\6\7\0B\3\3\2\18\6\2\0009\4\8\2B\4\2\0016\4\9\0009\4\
\4\18\6\3\0'\7\11\0B\4\3\2\15\0\4\0X\5FÄ6\4\9\0009\4\12\4\18\6\3\0)\7\
\0)\8ˇˇB\4\4\2\18\3\4\0006\4\9\0009\4\13\4\18\6\3\0'\7\14\0B\4\3\4X\7\11Ä6\8\9\0009\8\12\8\18\
\7\0)\11\1\0)\12˛ˇB\8\4\2\18\7\8\0-\8\1\0\18\
\0\0\18\11\7\0B\8\3\1E\7\3\2R\7Û\127X\1+Ä'\1\15\0006\2\3\0009\2\4\2\18\4\1\0'\5\5\0B\2\3\2\15\0\2\0X\3#Ä\18\5\2\0009\3\6\2'\6\7\0B\3\3\2)\4\0\0006\5\9\0009\5\13\5\18\7\3\0'\8\16\0B\5\3\4X\8\19Ä6\9\9\0009\9\17\9\18\11\8\0'\12\18\0'\13\19\0B\9\4\2\18\8\9\0)\9\0\0\1\9\4\0X\9\8Ä\21\9\8\0)\
\0\0\1\
\9\0X\9\4Ä-\9\1\0\18\11\0\0\18\12\8\0B\9\3\1\22\4\0\4E\8\3\2R\8Î\127\18\7\2\0009\5\8\2B\5\2\1L\0\2\0\0¿\2¿\5\8%s+\9gsub\
(.-)\
\"df -h -t ext4 --output=target\13([^%s]+)\11gmatch\8sub\13Drives: \
match\11string\
close\7*a\9read\6r\
popen\7io\25fsutil fsinfo drives\12Windows\7os\2\2\3\3\3\3\5\6\6\6\6\6\7\7\8\8\8\8\9\9\9\
\
\
\
\
\
\
\11\11\11\11\11\11\11\12\12\12\12\12\12\13\13\13\13\13\13\13\14\14\14\14\12\12\17\20\22\22\22\22\22\23\23\24\24\24\24\25\26\26\26\26\26\26\27\27\27\27\27\27\27\28\28\28\29\29\29\29\30\30\30\30!\26\26###&ffi\0tinsert\0drives\0\2acmd\0\5/fh\0\5*data\0\6$\4\22\14\5\0\14\6\0\14f\0\1\11cmd\0\15*fh\0\5%data\0\6\31count\0\1\30\4\5\22\5\0\22\6\0\22f\0\1\19\0Ü\2\0\1\11\4\6\0\28[\\\0094\1\0\0'\2\0\0-\3\0\0009\3\1\3\6\3\2\0X\3\1Ä'\2\3\0006\3\4\0009\3\5\3\18\5\0\0\18\6\2\0B\3\3\4X\6\4Ä-\7\1\0\18\9\1\0\18\
\6\0B\7\3\1E\6\3\2R\6˙\127\21\3\1\0)\4\1\0\1\3\4\0X\3\1ÄL\0\2\0-\3\2\0\18\5\1\0-\6\3\0D\3\3\0\0¿\2¿\3¿\4Ä\11gmatch\11string\12(.-)[/]\12Windows\7os\12(.-)[\\]\1\2\3\3\3\3\3\4\4\4\4\4\4\5\5\5\5\4\4\7\7\7\7\7\8\8\8\8ffi\0tinsert\0tconcat\0sep\0path\0\0\29parts\0\2\27patt\0\1\26\4\
\7\5\0\7\6\0\7pseg\0\1\4\0õ\2\0\1\9\0\12\1&Dj\0116\1\0\0009\1\1\1'\3\2\0\18\4\0\0&\3\4\3'\4\3\0B\1\3\2\15\0\1\0X\2\27Ä\18\4\1\0009\2\4\1'\5\5\0B\2\3\0026\3\6\0009\3\7\3\18\5\2\0)\6\1\0)\7\20\0B\3\4\0026\4\6\0009\4\8\4\18\6\3\0'\7\9\0'\8\
\0B\4\4\2\18\3\4\0\18\6\1\0009\4\11\1B\4\2\1\21\4\3\0\8\4\0\0X\4\2Ä+\4\1\0X\5\1Ä+\4\2\0L\4\2\0+\2\1\0L\2\2\0\
close\5\6 \9gsub\8sub\11string\7*a\9read\6r\12attrib \
popen\7io\0\2\2\2\2\2\2\2\3\3\4\4\4\4\5\5\5\5\5\5\6\6\6\6\6\6\6\7\7\7\8\8\8\8\8\8\8\
\
path\0\0'fh\0\8\31res\0\6\23fileattr\0\6\17\0Ú\1\0\1\7\0\
\0\0299w\
6\1\0\0009\1\1\1'\3\2\0\18\4\0\0&\3\4\3'\4\3\0B\1\3\2\15\0\1\0X\2\18Ä\18\4\1\0009\2\4\1'\5\5\0B\2\3\0026\3\6\0009\3\7\3\18\5\2\0'\6\8\0B\3\3\2\18\6\1\0009\4\9\1B\4\2\1\11\3\0\0X\4\2Ä+\4\1\0X\5\1Ä+\4\2\0L\4\2\0+\2\1\0L\2\2\0\
close\19.-: directory$\
match\11string\7*a\9read\6r\
file \
popen\7io\2\2\2\2\2\2\2\3\3\4\4\4\4\5\5\5\5\5\6\6\6\7\7\7\7\7\7\9\9path\0\0\30fh\0\8\22res\0\6\14folder\0\5\9\0ù\4\0\1\
\1\20\0G°\1Ü\1\26'\1\0\0-\2\0\0009\2\1\2\7\2\2\0X\2\16Ä6\2\3\0009\2\4\2'\4\5\0'\5\6\0B\2\3\2\15\0\2\0X\3\24Ä\18\5\2\0009\3\7\2'\6\8\0B\3\3\2\18\1\3\0\18\5\2\0009\3\9\2B\3\2\1X\2\15Ä6\2\3\0009\2\4\2'\4\
\0'\5\6\0B\2\3\2\15\0\2\0X\3\8Ä\18\5\2\0009\3\7\2'\6\8\0B\3\3\2\18\1\3\0\18\5\2\0009\3\9\2B\3\2\1\15\0\0\0X\2 Ä\18\2\0\0006\3\11\0009\3\12\3\18\5\1\0'\6\13\0\18\7\2\0'\8\14\0&\6\8\6B\3\3\3\14\0\3\0X\5\1Ä'\3\15\0\14\0\4\0X\5\1Ä'\4\15\0\18\7\4\0009\5\16\4'\8\17\0'\9\15\0B\5\4\2\18\4\5\0-\5\0\0009\5\1\5\7\5\2\0X\5\4Ä\18\5\3\0'\6\18\0&\1\6\5X\5\3Ä\18\5\3\0'\6\19\0&\1\6\5L\1\2\0\0¿\6/\6\\\8%s+\9gsub\5\
)(.-)\8(.-\
match\11string\8pwd\
close\7*a\9read\6r\7cd\
popen\7io\12Windows\7os\6.\2\3\3\3\3\4\4\4\4\4\5\5\5\5\5\5\5\5\5\5\5\7\7\7\7\7\8\8\8\8\8\8\8\8\8\8\11\11\12\13\13\13\13\13\13\13\13\14\14\14\15\15\15\17\17\17\17\17\17\18\18\18\18\19\19\19\19\21\21\21\25ffi\0expected_root_folder\0\0Hbase_dir\0\2Fcmdh\0\9\
cmdh\0\16\
folder_name\0\13\31last_folder\0\8\23remain\0\0\23\0è\6\0\2\14\4\26\0[Œ\1Æ\1#-\2\0\0009\2\0\2\7\2\1\0X\2\12Ä6\2\2\0009\2\3\2\18\4\0\0)\5\2\0)\6ˇˇB\2\4\2\7\2\4\0X\3\4Ä+\1\2\0\18\3\0\0-\4\1\0&\0\4\3-\2\2\0008\2\0\2\15\0\2\0X\3\5Ä\11\1\0\0X\2\3Ä-\2\2\0008\2\0\2L\2\2\0004\2\0\0006\3\5\0009\3\6\3\18\5\2\0)\6\1\0005\7\7\0B\3\4\1'\3\8\0006\4\9\0009\4\
\0046\6\2\0009\6\11\6-\8\3\0\18\9\0\0B\6\3\2'\7\12\0B\4\3\2\15\0\4\0X\5\9Ä\18\7\4\0009\5\13\4'\8\14\0B\5\3\2\18\3\5\0\18\7\4\0009\5\15\4B\5\2\1X\5\8Ä6\5\16\0'\7\17\0006\8\18\0\18\
\0\0B\8\2\2&\7\8\7B\5\2\1L\2\2\0006\5\2\0009\5\19\5\18\7\3\0'\8\20\0B\5\3\4X\8\19Ä5\9\21\0-\
\0\0009\
\2\
\18\12\8\0B\
\2\2=\
\22\9-\
\0\0009\
\24\
'\12\25\0B\
\2\2=\
\23\0099\
\23\9)\11\0\0>\11\0\
6\
\5\0009\
\6\
\18\12\2\0\18\13\9\0B\
\3\1E\8\3\2R\8Î\127-\5\2\0<\2\0\5L\2\2\0\0¿\4Ä\7¿\5Ä\11int[1]\8new\11select\9name\1\0\2\11folder\2\9name\0\
(.-)\
\11gmatch\13tostring0[Error] dirtools.get_folderslist bad path: \
print\
close\7*a\9read\6r\11format\
popen\7io\5\1\0\1\9name\7..\11insert\
table\6:\8sub\11string\12Windows\7os\3\3\3\3\4\4\4\4\4\4\5\5\5\5\5\5\8\8\8\8\8\8\9\9\9\12\13\13\13\13\13\13\15\17\17\17\17\17\17\17\17\17\18\18\19\19\19\19\19\20\20\20\20\22\22\22\22\22\22\22\23\26\26\26\26\26\26\27\27\27\27\27\27\28\28\28\28\28\29\29\29\30\30\30\30\30\26\26!!\"ffi\0sep\0list_folders_cache\0allfolders_cmd\0path\0\0\\cache_update\0\0\\colon\0\11\6files\0\16Ares\0\7:fh\0\0091\4\24\22\5\0\22\6\0\22f\0\1\19newfile\0\6\13\0£\6\0\2\14\5\27\1]œ\1’\1(-\2\0\0009\2\0\2\7\2\1\0X\2\
Ä6\2\2\0009\2\3\2\18\4\0\0'\5\4\0B\2\3\2\7\2\5\0X\3\3Ä\18\3\0\0-\4\1\0&\0\4\3-\2\2\0008\2\0\2\15\0\2\0X\3\5Ä\11\1\0\0X\2\3Ä-\2\2\0008\2\0\2L\2\2\0-\2\3\0009\2\6\2\18\4\0\0B\2\2\2'\3\7\0006\4\8\0009\4\9\0046\6\2\0009\6\
\6-\8\4\0\18\9\0\0B\6\3\2'\7\11\0B\4\3\2\15\0\4\0X\5\15Ä\18\7\4\0009\5\12\4'\8\13\0B\5\3\2\18\3\5\0\18\7\4\0009\5\14\4B\5\2\1\21\5\3\0\9\5\0\0X\5\13Ä-\5\2\0<\2\0\5L\2\2\0X\5\9Ä6\5\15\0'\7\16\0006\8\17\0\18\
\0\0B\8\2\2&\7\8\7B\5\2\0014\5\0\0L\5\2\0006\5\2\0009\5\18\5\18\7\3\0'\8\19\0B\5\3\4X\8\19Ä5\9\20\0-\
\0\0009\
\2\
\18\12\8\0B\
\2\2=\
\21\9-\
\0\0009\
\23\
'\12\24\0B\
\2\2=\
\22\0099\
\22\9)\11\0\0>\11\0\
6\
\25\0009\
\26\
\18\12\2\0\18\13\9\0B\
\3\1E\8\3\2R\8Î\127-\5\2\0<\2\0\5L\2\2\0\0¿\4Ä\8¿\1¿\6Ä\11insert\
table\11int[1]\8new\11select\9name\1\0\2\11folder\0\9name\0\
(.-)\
\11gmatch\13tostring,[Error] dirtools.get_dirlist bad path: \
print\
close\7*a\9read\6r\11format\
popen\7io\5\20get_folderslist\6:\9(.)$\
match\11string\12Windows\7os\0\3\3\3\3\4\4\4\4\4\5\5\5\5\5\8\8\8\8\8\8\9\9\9\13\13\13\13\16\18\18\18\18\18\18\18\18\18\19\19\20\20\20\20\20\21\21\21\22\22\22\23\23\24\25\27\27\27\27\27\27\27\28\28\31\31\31\31\31\31      !!!!!\"\"\"#####\31\31&&'ffi\0sep\0list_cache\0dirtools\0allfiles_cmd\0path\0\0^cache_update\0\0^colon\0\
\5files\0\18Bres\0\1Afh\0\0098\4\31\22\5\0\22\6\0\22f\0\1\19newfile\0\6\13\0•\1\0\2\11\1\3\0\17:Ä\2\0086\2\0\0\18\4\0\0B\2\2\4X\5\9Ä-\7\0\0009\7\1\0079\9\2\6\18\
\1\0B\7\3\2\15\0\7\0X\8\2Ä+\7\2\0L\7\2\0E\5\3\3R\5ı\127+\2\1\0L\2\2\0\1¿\9name\18compare_paths\11ipairs\2\2\2\2\3\3\3\3\3\3\3\4\4\2\2\7\7dirtools\0list\0\0\18path\0\0\18\4\4\12\5\0\12\6\0\12i\0\1\9v\0\0\9\0k\0\1\4\1\3\0\
(ã\2\4\
\0\0\0X\1\2Ä\7\0\0\0X\1\1Ä'\0\1\0-\1\0\0009\1\2\1\18\3\0\0B\1\2\2L\1\2\0\1¿\15get_folder\6.\5\1\1\1\1\1\2\2\2\2\3dirtools\0path\0\0\11parentpath\0\
\1\0˙\2\0\3\13\1\6\0,{ì\2\20\7\0\0\0X\3\4Ä-\3\0\0009\3\1\3B\3\1\2\18\0\3\0-\3\0\0009\3\2\3\18\5\0\0B\3\2\2-\4\0\0009\4\3\4\18\6\3\0'\7\4\0B\4\3\2\11\4\2\0X\4\1ÄL\0\2\0\18\4\0\0)\5\1\0\18\6\1\0)\7\1\0M\5\19Ä-\9\0\0009\9\5\9\18\11\4\0B\9\2\2\18\4\9\0-\9\0\0009\9\2\9\18\11\4\0B\9\2\2\18\3\9\0-\9\0\0009\9\3\9\18\11\3\0'\12\4\0B\9\3\2\11\9\2\0X\9\1ÄL\4\2\0O\5Ì\127+\5\0\0L\5\2\0\1¿\15get_parent\17sokol-luajit\15path_match\20get_folderslist\17get_app_path\6.\3\3\4\4\4\4\6\6\6\6\7\7\7\7\7\7\7\8\11\12\12\12\12\13\13\13\13\13\14\14\14\14\14\15\15\15\15\15\15\15\16\12\19\19dirtools\0start_path\0\0-parent_up\0\0-folder_name\0\0-list\0\11\"current\0\9\25\1\3\20\2\0\20\3\0\20i\0\1\18\0D\0\2\5\1\0\0\5#™\2\4\18\2\0\0-\3\0\0\18\4\1\0&\2\4\2L\2\2\0\4Ä\2\2\2\2\3sep\0path\0\0\6child\0\0\6newpath\0\5\1\0v\0\1\5\1\2\0\9&≥\2\3-\1\0\0009\1\0\1\18\3\0\0B\1\2\2-\2\0\0009\2\1\2\18\4\1\0B\2\2\1K\0\1\0\1¿\22add_default_paths\17get_app_path\1\1\1\1\2\2\2\2\3dirtools\0base_path\0\0\
path\0\5\5\0ù\6\3\0\
\0*\0=Ë\1\0º\0026\0\0\0'\2\1\0B\0\2\0024\1\0\0006\2\2\0009\2\3\0026\3\2\0009\3\4\0033\4\6\0=\4\5\1'\4\7\0009\5\8\0\6\5\9\0X\5\1Ä'\4\
\0003\5\12\0=\5\11\0013\5\14\0=\5\13\0013\5\16\0=\5\15\0013\5\18\0=\5\17\0019\5\8\0\7\5\9\0X\5\3Ä3\5\20\0=\5\19\1X\5\2Ä3\5\21\0=\5\19\0013\5\23\0=\5\22\1'\5\24\0009\6\8\0\6\6\9\0X\6\1Ä'\5\25\0'\6\26\0009\7\8\0\6\7\9\0X\7\1Ä'\6\27\0004\7\0\0004\8\0\0003\9\29\0=\9\28\0013\9\31\0=\9\30\0013\9!\0=\9 \0013\9#\0=\9\"\0013\9%\0=\9$\0013\9'\0=\9&\0013\9)\0=\9(\0012\0\0ÄL\1\2\0\0\9init\0\18change_folder\0\16find_folder\0\15get_parent\0\15path_match\0\16get_dirlist\0\20get_folderslist\25ls -p %s | grep -v /\23dir /ON /A-D /B %s\22ls -p %s | grep /\22dir /ON /AD /B %s\0\17get_app_path\0\0\14is_folder\0\15get_folder\0\15get_drives\0\17combine_path\0\18compare_paths\6/\12Windows\7os\6\\\0\22add_default_paths\11concat\11insert\
table\8ffi\12require\1\0\1\0\1\0\3\0\5\0\5\0\6\0\6\0\26\0\26\0\28\0\29\0\29\0\29\0\29\0&\0&\0-\0-\0X\0X\0e\0e\0i\0i\0i\0u\0u\0u\0Å\0Å\0†\0†\0§\0•\0•\0•\0•\0¶\0ß\0ß\0ß\0ß\0´\0¨\0—\0—\0˝\0˝\0\8\1\8\1\15\1\15\1'\1'\1.\1.\0016\0016\1:\1:\1ffi\0\4:dirtools\0\0019tinsert\0\0027tconcat\0\0025sep\0\0032allfolders_cmd\0\23\27allfiles_cmd\0\5\22list_folders_cache\0\5\17list_cache\0\1\16\0\0");t['F:.devjit.Thunc.sokol-luajit.ffi.sokol.sokol_app']=load("\27LJ\2\0080F:.devjit.Thunc.sokol-luajit.ffi.sokol.sokol_app∆»\1\2\0\8\0\30\0Gø\1\0◊\0046\0\0\0'\2\1\0B\0\2\0026\1\2\0009\1\3\1\14\0\1\0X\2\1Ä'\1\4\0006\2\5\0\14\0\2\0X\3+Ä5\2\9\0005\3\7\0\18\4\1\0'\5\6\0&\4\5\4=\4\8\3=\3\
\0025\3\12\0\18\4\1\0'\5\11\0&\4\5\4=\4\8\3=\3\13\0025\3\15\0'\4\14\0\18\5\1\0'\6\6\0&\4\6\4=\4\8\3'\4\14\0\18\5\1\0'\6\6\0&\4\6\4=\4\16\3=\3\17\0025\3\18\0\18\4\1\0'\5\6\0&\4\5\4=\4\8\3=\3\19\0025\3\20\0\18\4\1\0'\5\6\0&\4\5\4=\4\8\3=\3\21\0025\3\22\0\18\4\1\0'\5\6\0&\4\5\4=\4\8\3=\3\23\0026\3\5\0\14\0\3\0X\4\4Ä9\3\24\0008\3\3\0029\4\25\0008\3\4\0036\4\26\0\18\6\3\0B\4\2\0019\4\27\0\18\6\3\0B\4\2\0029\5\28\0'\7\29\0B\5\2\1L\4\2\0Å√\1\
/********** sokol_app ****************************************************************/\
\
/* misc constants */\
enum {\
   SAPP_MAX_TOUCHPOINTS = 8,\
   SAPP_MAX_MOUSEBUTTONS = 3,\
   SAPP_MAX_KEYCODES = 512,\
   SAPP_MAX_ICONIMAGES = 8,\
};\
\
/*\
   sapp_event_type\
\
   The type of event that's passed to the event handler callback\
   in the sapp_event.type field. These are not just \"traditional\"\
   input events, but also notify the application about state changes\
   or other user-invoked actions.\
*/\
typedef enum sapp_event_type {\
   SAPP_EVENTTYPE_INVALID,\
   SAPP_EVENTTYPE_KEY_DOWN,\
   SAPP_EVENTTYPE_KEY_UP,\
   SAPP_EVENTTYPE_CHAR,\
   SAPP_EVENTTYPE_MOUSE_DOWN,\
   SAPP_EVENTTYPE_MOUSE_UP,\
   SAPP_EVENTTYPE_MOUSE_SCROLL,\
   SAPP_EVENTTYPE_MOUSE_MOVE,\
   SAPP_EVENTTYPE_MOUSE_ENTER,\
   SAPP_EVENTTYPE_MOUSE_LEAVE,\
   SAPP_EVENTTYPE_TOUCHES_BEGAN,\
   SAPP_EVENTTYPE_TOUCHES_MOVED,\
   SAPP_EVENTTYPE_TOUCHES_ENDED,\
   SAPP_EVENTTYPE_TOUCHES_CANCELLED,\
   SAPP_EVENTTYPE_RESIZED,\
   SAPP_EVENTTYPE_ICONIFIED,\
   SAPP_EVENTTYPE_RESTORED,\
   SAPP_EVENTTYPE_FOCUSED,\
   SAPP_EVENTTYPE_UNFOCUSED,\
   SAPP_EVENTTYPE_SUSPENDED,\
   SAPP_EVENTTYPE_RESUMED,\
   SAPP_EVENTTYPE_QUIT_REQUESTED,\
   SAPP_EVENTTYPE_CLIPBOARD_PASTED,\
   SAPP_EVENTTYPE_FILES_DROPPED,\
   _SAPP_EVENTTYPE_NUM,\
   _SAPP_EVENTTYPE_FORCE_U32 = 0x7FFFFFFF\
} sapp_event_type;\
\
/*\
   sapp_keycode\
\
   The 'virtual keycode' of a KEY_DOWN or KEY_UP event in the\
   struct field sapp_event.key_code.\
\
   Note that the keycode values are identical with GLFW.\
*/\
typedef enum sapp_keycode {\
   SAPP_KEYCODE_INVALID          = 0,\
   SAPP_KEYCODE_SPACE            = 32,\
   SAPP_KEYCODE_APOSTROPHE       = 39,  /* ' */\
   SAPP_KEYCODE_COMMA            = 44,  /* , */\
   SAPP_KEYCODE_MINUS            = 45,  /* - */\
   SAPP_KEYCODE_PERIOD           = 46,  /* . */\
   SAPP_KEYCODE_SLASH            = 47,  /* / */\
   SAPP_KEYCODE_0                = 48,\
   SAPP_KEYCODE_1                = 49,\
   SAPP_KEYCODE_2                = 50,\
   SAPP_KEYCODE_3                = 51,\
   SAPP_KEYCODE_4                = 52,\
   SAPP_KEYCODE_5                = 53,\
   SAPP_KEYCODE_6                = 54,\
   SAPP_KEYCODE_7                = 55,\
   SAPP_KEYCODE_8                = 56,\
   SAPP_KEYCODE_9                = 57,\
   SAPP_KEYCODE_SEMICOLON        = 59,  /* ; */\
   SAPP_KEYCODE_EQUAL            = 61,  /* = */\
   SAPP_KEYCODE_A                = 65,\
   SAPP_KEYCODE_B                = 66,\
   SAPP_KEYCODE_C                = 67,\
   SAPP_KEYCODE_D                = 68,\
   SAPP_KEYCODE_E                = 69,\
   SAPP_KEYCODE_F                = 70,\
   SAPP_KEYCODE_G                = 71,\
   SAPP_KEYCODE_H                = 72,\
   SAPP_KEYCODE_I                = 73,\
   SAPP_KEYCODE_J                = 74,\
   SAPP_KEYCODE_K                = 75,\
   SAPP_KEYCODE_L                = 76,\
   SAPP_KEYCODE_M                = 77,\
   SAPP_KEYCODE_N                = 78,\
   SAPP_KEYCODE_O                = 79,\
   SAPP_KEYCODE_P                = 80,\
   SAPP_KEYCODE_Q                = 81,\
   SAPP_KEYCODE_R                = 82,\
   SAPP_KEYCODE_S                = 83,\
   SAPP_KEYCODE_T                = 84,\
   SAPP_KEYCODE_U                = 85,\
   SAPP_KEYCODE_V                = 86,\
   SAPP_KEYCODE_W                = 87,\
   SAPP_KEYCODE_X                = 88,\
   SAPP_KEYCODE_Y                = 89,\
   SAPP_KEYCODE_Z                = 90,\
   SAPP_KEYCODE_LEFT_BRACKET     = 91,  /* [ */\
   SAPP_KEYCODE_BACKSLASH        = 92,  /* \\ */\
   SAPP_KEYCODE_RIGHT_BRACKET    = 93,  /* ] */\
   SAPP_KEYCODE_GRAVE_ACCENT     = 96,  /* ` */\
   SAPP_KEYCODE_WORLD_1          = 161, /* non-US #1 */\
   SAPP_KEYCODE_WORLD_2          = 162, /* non-US #2 */\
   SAPP_KEYCODE_ESCAPE           = 256,\
   SAPP_KEYCODE_ENTER            = 257,\
   SAPP_KEYCODE_TAB              = 258,\
   SAPP_KEYCODE_BACKSPACE        = 259,\
   SAPP_KEYCODE_INSERT           = 260,\
   SAPP_KEYCODE_DELETE           = 261,\
   SAPP_KEYCODE_RIGHT            = 262,\
   SAPP_KEYCODE_LEFT             = 263,\
   SAPP_KEYCODE_DOWN             = 264,\
   SAPP_KEYCODE_UP               = 265,\
   SAPP_KEYCODE_PAGE_UP          = 266,\
   SAPP_KEYCODE_PAGE_DOWN        = 267,\
   SAPP_KEYCODE_HOME             = 268,\
   SAPP_KEYCODE_END              = 269,\
   SAPP_KEYCODE_CAPS_LOCK        = 280,\
   SAPP_KEYCODE_SCROLL_LOCK      = 281,\
   SAPP_KEYCODE_NUM_LOCK         = 282,\
   SAPP_KEYCODE_PRINT_SCREEN     = 283,\
   SAPP_KEYCODE_PAUSE            = 284,\
   SAPP_KEYCODE_F1               = 290,\
   SAPP_KEYCODE_F2               = 291,\
   SAPP_KEYCODE_F3               = 292,\
   SAPP_KEYCODE_F4               = 293,\
   SAPP_KEYCODE_F5               = 294,\
   SAPP_KEYCODE_F6               = 295,\
   SAPP_KEYCODE_F7               = 296,\
   SAPP_KEYCODE_F8               = 297,\
   SAPP_KEYCODE_F9               = 298,\
   SAPP_KEYCODE_F10              = 299,\
   SAPP_KEYCODE_F11              = 300,\
   SAPP_KEYCODE_F12              = 301,\
   SAPP_KEYCODE_F13              = 302,\
   SAPP_KEYCODE_F14              = 303,\
   SAPP_KEYCODE_F15              = 304,\
   SAPP_KEYCODE_F16              = 305,\
   SAPP_KEYCODE_F17              = 306,\
   SAPP_KEYCODE_F18              = 307,\
   SAPP_KEYCODE_F19              = 308,\
   SAPP_KEYCODE_F20              = 309,\
   SAPP_KEYCODE_F21              = 310,\
   SAPP_KEYCODE_F22              = 311,\
   SAPP_KEYCODE_F23              = 312,\
   SAPP_KEYCODE_F24              = 313,\
   SAPP_KEYCODE_F25              = 314,\
   SAPP_KEYCODE_KP_0             = 320,\
   SAPP_KEYCODE_KP_1             = 321,\
   SAPP_KEYCODE_KP_2             = 322,\
   SAPP_KEYCODE_KP_3             = 323,\
   SAPP_KEYCODE_KP_4             = 324,\
   SAPP_KEYCODE_KP_5             = 325,\
   SAPP_KEYCODE_KP_6             = 326,\
   SAPP_KEYCODE_KP_7             = 327,\
   SAPP_KEYCODE_KP_8             = 328,\
   SAPP_KEYCODE_KP_9             = 329,\
   SAPP_KEYCODE_KP_DECIMAL       = 330,\
   SAPP_KEYCODE_KP_DIVIDE        = 331,\
   SAPP_KEYCODE_KP_MULTIPLY      = 332,\
   SAPP_KEYCODE_KP_SUBTRACT      = 333,\
   SAPP_KEYCODE_KP_ADD           = 334,\
   SAPP_KEYCODE_KP_ENTER         = 335,\
   SAPP_KEYCODE_KP_EQUAL         = 336,\
   SAPP_KEYCODE_LEFT_SHIFT       = 340,\
   SAPP_KEYCODE_LEFT_CONTROL     = 341,\
   SAPP_KEYCODE_LEFT_ALT         = 342,\
   SAPP_KEYCODE_LEFT_SUPER       = 343,\
   SAPP_KEYCODE_RIGHT_SHIFT      = 344,\
   SAPP_KEYCODE_RIGHT_CONTROL    = 345,\
   SAPP_KEYCODE_RIGHT_ALT        = 346,\
   SAPP_KEYCODE_RIGHT_SUPER      = 347,\
   SAPP_KEYCODE_MENU             = 348,\
} sapp_keycode;\
\
/*\
   Android specific 'tool type' enum for touch events. This lets the\
   application check what type of input device was used for\
   touch events.\
\
   NOTE: the values must remain in sync with the corresponding\
   Android SDK type, so don't change those.\
\
   See https://developer.android.com/reference/android/view/MotionEvent#TOOL_TYPE_UNKNOWN\
*/\
typedef enum sapp_android_tooltype {\
   SAPP_ANDROIDTOOLTYPE_UNKNOWN = 0,   // TOOL_TYPE_UNKNOWN\
   SAPP_ANDROIDTOOLTYPE_FINGER = 1,    // TOOL_TYPE_FINGER\
   SAPP_ANDROIDTOOLTYPE_STYLUS = 2,    // TOOL_TYPE_STYLUS\
   SAPP_ANDROIDTOOLTYPE_MOUSE = 3,     // TOOL_TYPE_MOUSE\
} sapp_android_tooltype;\
\
/*\
   sapp_touchpoint\
\
   Describes a single touchpoint in a multitouch event (TOUCHES_BEGAN,\
   TOUCHES_MOVED, TOUCHES_ENDED).\
\
   Touch points are stored in the nested array sapp_event.touches[],\
   and the number of touches is stored in sapp_event.num_touches.\
*/\
typedef struct sapp_touchpoint {\
   uintptr_t identifier;\
   float pos_x;\
   float pos_y;\
   sapp_android_tooltype android_tooltype; // only valid on Android\
   bool changed;\
} sapp_touchpoint;\
\
/*\
   sapp_mousebutton\
\
   The currently pressed mouse button in the events MOUSE_DOWN\
   and MOUSE_UP, stored in the struct field sapp_event.mouse_button.\
*/\
typedef enum sapp_mousebutton {\
   SAPP_MOUSEBUTTON_LEFT = 0x0,\
   SAPP_MOUSEBUTTON_RIGHT = 0x1,\
   SAPP_MOUSEBUTTON_MIDDLE = 0x2,\
   SAPP_MOUSEBUTTON_INVALID = 0x100,\
} sapp_mousebutton;\
\
/*\
   These are currently pressed modifier keys (and mouse buttons) which are\
   passed in the event struct field sapp_event.modifiers.\
*/\
enum {\
   SAPP_MODIFIER_SHIFT = 0x1,      // left or right shift key\
   SAPP_MODIFIER_CTRL  = 0x2,      // left or right control key\
   SAPP_MODIFIER_ALT   = 0x4,      // left or right alt key\
   SAPP_MODIFIER_SUPER = 0x8,      // left or right 'super' key\
   SAPP_MODIFIER_LMB   = 0x100,    // left mouse button\
   SAPP_MODIFIER_RMB   = 0x200,    // right mouse button\
   SAPP_MODIFIER_MMB   = 0x400,    // middle mouse button\
};\
\
/*\
   sapp_event\
\
   This is an all-in-one event struct passed to the event handler\
   user callback function. Note that it depends on the event\
   type what struct fields actually contain useful values, so you\
   should first check the event type before reading other struct\
   fields.\
*/\
typedef struct sapp_event {\
   uint64_t frame_count;               // current frame counter, always valid, useful for checking if two events were issued in the same frame\
   sapp_event_type type;               // the event type, always valid\
   sapp_keycode key_code;              // the virtual key code, only valid in KEY_UP, KEY_DOWN\
   uint32_t char_code;                 // the UTF-32 character code, only valid in CHAR events\
   bool key_repeat;                    // true if this is a key-repeat event, valid in KEY_UP, KEY_DOWN and CHAR\
   uint32_t modifiers;                 // current modifier keys, valid in all key-, char- and mouse-events\
   sapp_mousebutton mouse_button;      // mouse button that was pressed or released, valid in MOUSE_DOWN, MOUSE_UP\
   float mouse_x;                      // current horizontal mouse position in pixels, always valid except during mouse lock\
   float mouse_y;                      // current vertical mouse position in pixels, always valid except during mouse lock\
   float mouse_dx;                     // relative horizontal mouse movement since last frame, always valid\
   float mouse_dy;                     // relative vertical mouse movement since last frame, always valid\
   float scroll_x;                     // horizontal mouse wheel scroll distance, valid in MOUSE_SCROLL events\
   float scroll_y;                     // vertical mouse wheel scroll distance, valid in MOUSE_SCROLL events\
   int num_touches;                    // number of valid items in the touches[] array\
   sapp_touchpoint touches[SAPP_MAX_TOUCHPOINTS];  // current touch points, valid in TOUCHES_BEGIN, TOUCHES_MOVED, TOUCHES_ENDED\
   int window_width;                   // current window- and framebuffer sizes in pixels, always valid\
   int window_height;\
   int framebuffer_width;              // = window_width * dpi_scale\
   int framebuffer_height;             // = window_height * dpi_scale\
} sapp_event;\
\
/*\
   sg_range\
\
   A general pointer/size-pair struct and constructor macros for passing binary blobs\
   into sokol_app.h.\
*/\
typedef struct sapp_range {\
   const void* ptr;\
   size_t size;\
} sapp_range;\
\
\
/*\
   sapp_image_desc\
\
   This is used to describe image data to sokol_app.h (at first, window\
   icons, later maybe cursor images).\
\
   Note that the actual image pixel format depends on the use case:\
\
   - window icon pixels are RGBA8\
*/\
typedef struct sapp_image_desc {\
   int width;\
   int height;\
   sapp_range pixels;\
} sapp_image_desc;\
\
/*\
   sapp_icon_desc\
\
   An icon description structure for use in sapp_desc.icon and\
   sapp_set_icon().\
\
   When setting a custom image, the application can provide a number of\
   candidates differing in size, and sokol_app.h will pick the image(s)\
   closest to the size expected by the platform's window system.\
\
   To set sokol-app's default icon, set .sokol_default to true.\
\
   Otherwise provide candidate images of different sizes in the\
   images[] array.\
\
   If both the sokol_default flag is set to true, any image candidates\
   will be ignored and the sokol_app.h default icon will be set.\
*/\
typedef struct sapp_icon_desc {\
   bool sokol_default;\
   sapp_image_desc images[SAPP_MAX_ICONIMAGES];\
} sapp_icon_desc;\
\
/*\
   sapp_allocator\
\
   Used in sapp_desc to provide custom memory-alloc and -free functions\
   to sokol_app.h. If memory management should be overridden, both the\
   alloc_fn and free_fn function must be provided (e.g. it's not valid to\
   override one function but not the other).\
*/\
typedef struct sapp_allocator {\
   void* (*alloc_fn)(size_t size, void* user_data);\
   void (*free_fn)(void* ptr, void* user_data);\
   void* user_data;\
} sapp_allocator;\
\
/*\
    sapp_logger\
\
    Used in sapp_desc to provide a logging function. Please be aware that\
    without logging function, sokol-app will be completely silent, e.g. it will\
    not report errors or warnings. For maximum error verbosity, compile in\
    debug mode (e.g. NDEBUG *not* defined) and install a logger (for instance\
    the standard logging function from sokol_log.h).\
*/\
typedef struct sapp_logger {\
   void (*func)(\
       const char* tag,                // always \"sapp\"\
       uint32_t log_level,             // 0=panic, 1=error, 2=warning, 3=info\
       uint32_t log_item_id,           // SAPP_LOGITEM_*\
       const char* message_or_null,    // a message string, may be nullptr in release mode\
       uint32_t line_nr,               // line number in sokol_app.h\
       const char* filename_or_null,   // source filename, may be nullptr in release mode\
       void* user_data);\
   void* user_data;\
} sapp_logger;\
\
typedef struct sapp_desc {\
   void (*init_cb)(void);                  // these are the user-provided callbacks without user data\
   void (*frame_cb)(void);\
   void (*cleanup_cb)(void);\
   void (*event_cb)(const sapp_event*);\
\
   void* user_data;                        // these are the user-provided callbacks with user data\
   void (*init_userdata_cb)(void*);\
   void (*frame_userdata_cb)(void*);\
   void (*cleanup_userdata_cb)(void*);\
   void (*event_userdata_cb)(const sapp_event*, void*);\
\
   int width;                          // the preferred width of the window / canvas\
   int height;                         // the preferred height of the window / canvas\
   int sample_count;                   // MSAA sample count\
   int swap_interval;                  // the preferred swap interval (ignored on some platforms)\
   bool high_dpi;                      // whether the rendering canvas is full-resolution on HighDPI displays\
   bool fullscreen;                    // whether the window should be created in fullscreen mode\
   bool alpha;                         // whether the framebuffer should have an alpha channel (ignored on some platforms)\
   const char* window_title;           // the window title as UTF-8 encoded string\
   bool enable_clipboard;              // enable clipboard access, default is false\
   int clipboard_size;                 // max size of clipboard content in bytes\
   bool enable_dragndrop;              // enable file dropping (drag'n'drop), default is false\
   int max_dropped_files;              // max number of dropped files to process (default: 1)\
   int max_dropped_file_path_length;   // max length in bytes of a dropped UTF-8 file path (default: 2048)\
   sapp_icon_desc icon;                // the initial window icon to set\
   sapp_allocator allocator;           // optional memory allocation overrides (default: malloc/free)\
   sapp_logger logger;                 // logging callback override (default: NO LOGGING!)\
\
   // backend-specific options\
   int gl_major_version;               // override GL major and minor version (the default GL version is 4.1 on macOS, 4.3 elsewhere)\
   int gl_minor_version;\
   bool win32_console_utf8;            // if true, set the output console codepage to UTF-8\
   bool win32_console_create;          // if true, attach stdout/stderr to a new console window\
   bool win32_console_attach;          // if true, attach stdout/stderr to parent process\
   const char* html5_canvas_name;      // the name (id) of the HTML5 canvas element, default is \"canvas\"\
   bool html5_canvas_resize;           // if true, the HTML5 canvas size is set to sapp_desc.width/height, otherwise canvas size is tracked\
   bool html5_preserve_drawing_buffer; // HTML5 only: whether to preserve default framebuffer content between frames\
   bool html5_premultiplied_alpha;     // HTML5 only: whether the rendered pixels use premultiplied alpha convention\
   bool html5_ask_leave_site;          // initial state of the internal html5_ask_leave_site flag (see sapp_html5_ask_leave_site())\
   bool html5_bubble_mouse_events;     // if true, mouse events will bubble up to the web page\
   bool html5_bubble_touch_events;     // same for touch events\
   bool html5_bubble_wheel_events;     // same for wheel events\
   bool html5_bubble_key_events;       // if true, bubble up *all* key events to browser, not just key events that represent characters\
   bool html5_bubble_char_events;      // if true, bubble up character events to browser\
   bool html5_use_emsc_set_main_loop;  // if true, use emscripten_set_main_loop() instead of emscripten_request_animation_frame_loop()\
   bool html5_emsc_set_main_loop_simulate_infinite_loop;   // this will be passed as the simulate_infinite_loop arg to emscripten_set_main_loop()\
   bool ios_keyboard_resizes_canvas;   // if true, showing the iOS keyboard shrinks the canvas\
} sapp_desc;\
\
/* HTML5 specific: request and response structs for\
  asynchronously loading dropped-file content.\
*/\
typedef enum sapp_html5_fetch_error {\
   SAPP_HTML5_FETCH_ERROR_NO_ERROR,\
   SAPP_HTML5_FETCH_ERROR_BUFFER_TOO_SMALL,\
   SAPP_HTML5_FETCH_ERROR_OTHER,\
} sapp_html5_fetch_error;\
\
typedef struct sapp_html5_fetch_response {\
   bool succeeded;         // true if the loading operation has succeeded\
   sapp_html5_fetch_error error_code;\
   int file_index;         // index of the dropped file (0..sapp_get_num_dropped_filed()-1)\
   sapp_range data;        // pointer and size of the fetched data (data.ptr == buffer.ptr, data.size <= buffer.size)\
   sapp_range buffer;      // the user-provided buffer ptr/size pair (buffer.ptr == data.ptr, buffer.size >= data.size)\
   void* user_data;        // user-provided user data pointer\
} sapp_html5_fetch_response;\
\
typedef struct sapp_html5_fetch_request {\
   int dropped_file_index; // 0..sapp_get_num_dropped_files()-1\
   void (*callback)(const sapp_html5_fetch_response*);     // response callback function pointer (required)\
   sapp_range buffer;      // ptr/size of a memory buffer to load the data into\
   void* user_data;        // optional userdata pointer\
} sapp_html5_fetch_request;\
\
typedef enum sapp_mouse_cursor {\
   SAPP_MOUSECURSOR_DEFAULT = 0,   // equivalent with system default cursor\
   SAPP_MOUSECURSOR_ARROW,\
   SAPP_MOUSECURSOR_IBEAM,\
   SAPP_MOUSECURSOR_CROSSHAIR,\
   SAPP_MOUSECURSOR_POINTING_HAND,\
   SAPP_MOUSECURSOR_RESIZE_EW,\
   SAPP_MOUSECURSOR_RESIZE_NS,\
   SAPP_MOUSECURSOR_RESIZE_NWSE,\
   SAPP_MOUSECURSOR_RESIZE_NESW,\
   SAPP_MOUSECURSOR_RESIZE_ALL,\
   SAPP_MOUSECURSOR_NOT_ALLOWED,\
   _SAPP_MOUSECURSOR_NUM,\
} sapp_mouse_cursor;\
\
/* returns true after sokol-app has been initialized */\
bool sapp_isvalid(void);\
/* returns the current framebuffer width in pixels */\
int sapp_width(void);\
/* same as sapp_width(), but returns float */\
float sapp_widthf(void);\
/* returns the current framebuffer height in pixels */\
int sapp_height(void);\
/* same as sapp_height(), but returns float */\
float sapp_heightf(void);\
/* get default framebuffer color pixel format */\
int sapp_color_format(void);\
/* get default framebuffer depth pixel format */\
int sapp_depth_format(void);\
/* get default framebuffer sample count */\
int sapp_sample_count(void);\
/* returns true when high_dpi was requested and actually running in a high-dpi scenario */\
bool sapp_high_dpi(void);\
/* returns the dpi scaling factor (window pixels to framebuffer pixels) */\
float sapp_dpi_scale(void);\
/* show or hide the mobile device onscreen keyboard */\
void sapp_show_keyboard(bool show);\
/* return true if the mobile device onscreen keyboard is currently shown */\
bool sapp_keyboard_shown(void);\
/* query fullscreen mode */\
bool sapp_is_fullscreen(void);\
/* toggle fullscreen mode */\
void sapp_toggle_fullscreen(void);\
/* show or hide the mouse cursor */\
void sapp_show_mouse(bool show);\
/* show or hide the mouse cursor */\
bool sapp_mouse_shown(void);\
/* enable/disable mouse-pointer-lock mode */\
void sapp_lock_mouse(bool lock);\
/* return true if in mouse-pointer-lock mode (this may toggle a few frames later) */\
bool sapp_mouse_locked(void);\
/* set mouse cursor type */\
void sapp_set_mouse_cursor(sapp_mouse_cursor cursor);\
/* get current mouse cursor type */\
sapp_mouse_cursor sapp_get_mouse_cursor(void);\
/* return the userdata pointer optionally provided in sapp_desc */\
void* sapp_userdata(void);\
/* return a copy of the sapp_desc structure */\
sapp_desc sapp_query_desc(void);\
/* initiate a \"soft quit\" (sends SAPP_EVENTTYPE_QUIT_REQUESTED) */\
void sapp_request_quit(void);\
/* cancel a pending quit (when SAPP_EVENTTYPE_QUIT_REQUESTED has been received) */\
void sapp_cancel_quit(void);\
/* initiate a \"hard quit\" (quit application without sending SAPP_EVENTTYPE_QUIT_REQUESTED) */\
void sapp_quit(void);\
/* call from inside event callback to consume the current event (don't forward to platform) */\
void sapp_consume_event(void);\
/* get the current frame counter (for comparison with sapp_event.frame_count) */\
uint64_t sapp_frame_count(void);\
/* get an averaged/smoothed frame duration in seconds */\
double sapp_frame_duration(void);\
/* write string into clipboard */\
void sapp_set_clipboard_string(const char* str);\
/* read string from clipboard (usually during SAPP_EVENTTYPE_CLIPBOARD_PASTED) */\
const char* sapp_get_clipboard_string(void);\
/* set the window title (only on desktop platforms) */\
void sapp_set_window_title(const char* str);\
/* set the window icon (only on Windows and Linux) */\
void sapp_set_icon(const sapp_icon_desc* icon_desc);\
/* gets the total number of dropped files (after an SAPP_EVENTTYPE_FILES_DROPPED event) */\
int sapp_get_num_dropped_files(void);\
/* gets the dropped file paths */\
const char* sapp_get_dropped_file_path(int index);\
\
/* special run-function for SOKOL_NO_ENTRY (in standard mode this is an empty stub) */\
void sapp_run(const sapp_desc* desc);\
\
/* EGL: get EGLDisplay object */\
const void* sapp_egl_get_display(void);\
/* EGL: get EGLContext object */\
const void* sapp_egl_get_context(void);\
\
/* HTML5: enable or disable the hardwired \"Leave Site?\" dialog box */\
void sapp_html5_ask_leave_site(bool ask);\
/* HTML5: get byte size of a dropped file */\
uint32_t sapp_html5_get_dropped_file_size(int index);\
/* HTML5: asynchronously load the content of a dropped file */\
void sapp_html5_fetch_dropped_file(const sapp_html5_fetch_request* request);\
\
/* Metal: get bridged pointer to Metal device object */\
const void* sapp_metal_get_device(void);\
/* Metal: get bridged pointer to MTKView's current drawable of type CAMetalDrawable */\
const void* sapp_metal_get_current_drawable(void);\
/* Metal: get bridged pointer to MTKView's depth-stencil texture of type MTLTexture */\
const void* sapp_metal_get_depth_stencil_texture(void);\
/* Metal: get bridged pointer to MTKView's msaa-color-texture of type MTLTexture (may be null) */\
const void* sapp_metal_get_msaa_color_texture(void);\
/* macOS: get bridged pointer to macOS NSWindow */\
const void* sapp_macos_get_window(void);\
/* iOS: get bridged pointer to iOS UIWindow */\
const void* sapp_ios_get_window(void);\
\
/* D3D11: get pointer to ID3D11Device object */\
const void* sapp_d3d11_get_device(void);\
/* D3D11: get pointer to ID3D11DeviceContext object */\
const void* sapp_d3d11_get_device_context(void);\
/* D3D11: get pointer to IDXGISwapChain object */\
const void* sapp_d3d11_get_swap_chain(void);\
/* D3D11: get pointer to ID3D11RenderTargetView object for rendering */\
const void* sapp_d3d11_get_render_view(void);\
/* D3D11: get pointer ID3D11RenderTargetView object for msaa-resolve (may return null) */\
const void* sapp_d3d11_get_resolve_view(void);\
/* D3D11: get pointer ID3D11DepthStencilView */\
const void* sapp_d3d11_get_depth_stencil_view(void);\
/* Win32: get the HWND window handle */\
const void* sapp_win32_get_hwnd(void);\
\
/* WebGPU: get WGPUDevice handle */\
const void* sapp_wgpu_get_device(void);\
/* WebGPU: get swapchain's WGPUTextureView handle for rendering */\
const void* sapp_wgpu_get_render_view(void);\
/* WebGPU: get swapchain's MSAA-resolve WGPUTextureView (may return null) */\
const void* sapp_wgpu_get_resolve_view(void);\
/* WebGPU: get swapchain's WGPUTextureView for the depth-stencil surface */\
const void* sapp_wgpu_get_depth_stencil_view(void);\
\
/* GL: get framebuffer object */\
uint32_t sapp_gl_get_framebuffer(void);\
/* GL: get major version (only valid for desktop GL) */\
int sapp_gl_get_major_version(void);\
/* GL: get minor version (only valid for desktop GL) */\
int sapp_gl_get_minor_version(void);\
\
/* Android: get native activity handle */\
const void* sapp_android_get_native_activity(void);\
\
\9cdef\9load\
print\9arch\7os\
Other\1\0\1\8x64\0\
POSIX\1\0\1\8x64\0\8BSD\1\0\1\8x64\0\
Linux\8arm\1\0\2\8arm\0\8x64\0\8lib\12Windows\1\0\1\8x64\0\9.dll\8OSX\1\0\6\12Windows\0\
Other\0\8OSX\0\
POSIX\0\8BSD\0\
Linux\0\8x64\1\0\1\8x64\0\8.so\18ffi_sokol_app\14sokol_dll\14SOKOL_DLL\7_G\8ffi\12require\1\0\1\0\1\0\3\0\3\0\3\0\3\0\3\0\4\0\4\0\4\0\4\0\5\0\5\0\5\0\5\0\5\0\5\0\6\0\6\0\6\0\6\0\6\0\6\0\7\0\7\0\7\0\7\0\7\0\7\0\7\0\7\0\7\0\7\0\7\0\7\0\8\0\8\0\8\0\8\0\8\0\8\0\9\0\9\0\9\0\9\0\9\0\9\0\
\0\
\0\
\0\
\0\
\0\
\0\13\0\13\0\13\0\13\0\13\0\13\0\13\0\14\0\14\0\14\0\15\0\15\0\15\0\17\0U\2U\2W\2ffi\0\4Dsokol_filename\0\5?libs\0.\17lib\0\7\
sokol_app\0\6\4\0\0");t['F:.devjit.Thunc.sokol-luajit.ffi.sokol.sokol_gfx']=load("\27LJ\2\0080F:.devjit.Thunc.sokol-luajit.ffi.sokol.sokol_gfx˘å\5\2\0\8\0\28\0Bµ\1\0≈\0176\0\0\0'\2\1\0B\0\2\0026\1\2\0009\1\3\1\14\0\1\0X\2\1Ä'\1\4\0006\2\5\0\14\0\2\0X\3)Ä5\2\9\0005\3\7\0\18\4\1\0'\5\6\0&\4\5\4=\4\8\3=\3\
\0025\3\12\0\18\4\1\0'\5\11\0&\4\5\4=\4\8\3=\3\13\0025\3\14\0\18\4\1\0'\5\6\0&\4\5\4=\4\8\3\18\4\1\0'\5\6\0&\4\5\4=\4\15\3=\3\16\0025\3\17\0\18\4\1\0'\5\6\0&\4\5\4=\4\8\3=\3\18\0025\3\19\0\18\4\1\0'\5\6\0&\4\5\4=\4\8\3=\3\20\0025\3\21\0\18\4\1\0'\5\6\0&\4\5\4=\4\8\3=\3\22\0026\3\5\0\14\0\3\0X\4\4Ä9\3\23\0008\3\3\0029\4\24\0008\3\4\0039\4\25\0\18\6\3\0B\4\2\0029\5\26\0'\7\27\0B\5\2\1L\4\2\0‹á\5\
/*\
    Resource id typedefs:\
\
    sg_buffer:      vertex- and index-buffers\
    sg_image:       images used as textures and render targets\
    sg_sampler      sampler object describing how a texture is sampled in a shader\
    sg_shader:      vertex- and fragment-shaders and shader interface information\
    sg_pipeline:    associated shader and vertex-layouts, and render states\
    sg_attachments: a baked collection of render pass attachment images\
\
    Instead of pointers, resource creation functions return a 32-bit\
    number which uniquely identifies the resource object.\
\
    The 32-bit resource id is split into a 16-bit pool index in the lower bits,\
    and a 16-bit 'generation counter' in the upper bits. The index allows fast\
    pool lookups, and combined with the generation-counter it allows to detect\
    'dangling accesses' (trying to use an object which no longer exists, and\
    its pool slot has been reused for a new object)\
\
    The resource ids are wrapped into a strongly-typed struct so that\
    trying to pass an incompatible resource id is a compile error.\
*/\
typedef struct sg_buffer        { uint32_t id; } sg_buffer;\
typedef struct sg_image         { uint32_t id; } sg_image;\
typedef struct sg_sampler       { uint32_t id; } sg_sampler;\
typedef struct sg_shader        { uint32_t id; } sg_shader;\
typedef struct sg_pipeline      { uint32_t id; } sg_pipeline;\
typedef struct sg_attachments   { uint32_t id; } sg_attachments;\
\
/*\
    sg_range is a pointer-size-pair struct used to pass memory blobs into\
    sokol-gfx. When initialized from a value type (array or struct), you can\
    use the SG_RANGE() macro to build an sg_range struct. For functions which\
    take either a sg_range pointer, or a (C++) sg_range reference, use the\
    SG_RANGE_REF macro as a solution which compiles both in C and C++.\
*/\
typedef struct sg_range {\
    const void* ptr;\
    size_t size;\
} sg_range;\
\
//  various compile-time constants\
enum {\
    SG_INVALID_ID = 0,\
    SG_NUM_SHADER_STAGES = 2,\
    SG_NUM_INFLIGHT_FRAMES = 2,\
    SG_MAX_COLOR_ATTACHMENTS = 4,\
    SG_MAX_VERTEX_BUFFERS = 8,\
    SG_MAX_SHADERSTAGE_IMAGES = 12,\
    SG_MAX_SHADERSTAGE_SAMPLERS = 8,\
    SG_MAX_SHADERSTAGE_IMAGESAMPLERPAIRS = 12,\
    SG_MAX_SHADERSTAGE_STORAGEBUFFERS = 8,\
    SG_MAX_SHADERSTAGE_UBS = 4,\
    SG_MAX_UB_MEMBERS = 16,\
    SG_MAX_VERTEX_ATTRIBUTES = 16,\
    SG_MAX_MIPMAPS = 16,\
    SG_MAX_TEXTUREARRAY_LAYERS = 128\
};\
\
/*\
    sg_color\
\
    An RGBA color value.\
*/\
typedef struct sg_color { float r, g, b, a; } sg_color;\
\
/*\
    sg_backend\
\
    The active 3D-API backend, use the function sg_query_backend()\
    to get the currently active backend.\
*/\
typedef enum sg_backend {\
    SG_BACKEND_GLCORE,\
    SG_BACKEND_GLES3,\
    SG_BACKEND_D3D11,\
    SG_BACKEND_METAL_IOS,\
    SG_BACKEND_METAL_MACOS,\
    SG_BACKEND_METAL_SIMULATOR,\
    SG_BACKEND_WGPU,\
    SG_BACKEND_DUMMY,\
} sg_backend;\
\
/*\
    sg_pixel_format\
\
    sokol_gfx.h basically uses the same pixel formats as WebGPU, since these\
    are supported on most newer GPUs.\
\
    A pixelformat name consist of three parts:\
\
        - components (R, RG, RGB or RGBA)\
        - bit width per component (8, 16 or 32)\
        - component data type:\
            - unsigned normalized (no postfix)\
            - signed normalized (SN postfix)\
            - unsigned integer (UI postfix)\
            - signed integer (SI postfix)\
            - float (F postfix)\
\
    Not all pixel formats can be used for everything, call sg_query_pixelformat()\
    to inspect the capabilities of a given pixelformat. The function returns\
    an sg_pixelformat_info struct with the following members:\
\
        - sample: the pixelformat can be sampled as texture at least with\
                  nearest filtering\
        - filter: the pixelformat can be samples as texture with linear\
                  filtering\
        - render: the pixelformat can be used for render targets\
        - blend:  blending is supported when using the pixelformat for\
                  render targets\
        - msaa:   multisample-antialiasing is supported when using the\
                  pixelformat for render targets\
        - depth:  the pixelformat can be used for depth-stencil attachments\
        - compressed: this is a block-compressed format\
        - bytes_per_pixel: the numbers of bytes in a pixel (0 for compressed formats)\
\
    The default pixel format for texture images is SG_PIXELFORMAT_RGBA8.\
\
    The default pixel format for render target images is platform-dependent\
    and taken from the sg_environment struct passed into sg_setup(). Typically\
    the default formats are:\
\
        - for the Metal, D3D11 and WebGPU backends: SG_PIXELFORMAT_BGRA8\
        - for GL backends: SG_PIXELFORMAT_RGBA8\
*/\
typedef enum sg_pixel_format {\
    _SG_PIXELFORMAT_DEFAULT,    // value 0 reserved for default-init\
    SG_PIXELFORMAT_NONE,\
\
    SG_PIXELFORMAT_R8,\
    SG_PIXELFORMAT_R8SN,\
    SG_PIXELFORMAT_R8UI,\
    SG_PIXELFORMAT_R8SI,\
\
    SG_PIXELFORMAT_R16,\
    SG_PIXELFORMAT_R16SN,\
    SG_PIXELFORMAT_R16UI,\
    SG_PIXELFORMAT_R16SI,\
    SG_PIXELFORMAT_R16F,\
    SG_PIXELFORMAT_RG8,\
    SG_PIXELFORMAT_RG8SN,\
    SG_PIXELFORMAT_RG8UI,\
    SG_PIXELFORMAT_RG8SI,\
\
    SG_PIXELFORMAT_R32UI,\
    SG_PIXELFORMAT_R32SI,\
    SG_PIXELFORMAT_R32F,\
    SG_PIXELFORMAT_RG16,\
    SG_PIXELFORMAT_RG16SN,\
    SG_PIXELFORMAT_RG16UI,\
    SG_PIXELFORMAT_RG16SI,\
    SG_PIXELFORMAT_RG16F,\
    SG_PIXELFORMAT_RGBA8,\
    SG_PIXELFORMAT_SRGB8A8,\
    SG_PIXELFORMAT_RGBA8SN,\
    SG_PIXELFORMAT_RGBA8UI,\
    SG_PIXELFORMAT_RGBA8SI,\
    SG_PIXELFORMAT_BGRA8,\
    SG_PIXELFORMAT_RGB10A2,\
    SG_PIXELFORMAT_RG11B10F,\
    SG_PIXELFORMAT_RGB9E5,\
\
    SG_PIXELFORMAT_RG32UI,\
    SG_PIXELFORMAT_RG32SI,\
    SG_PIXELFORMAT_RG32F,\
    SG_PIXELFORMAT_RGBA16,\
    SG_PIXELFORMAT_RGBA16SN,\
    SG_PIXELFORMAT_RGBA16UI,\
    SG_PIXELFORMAT_RGBA16SI,\
    SG_PIXELFORMAT_RGBA16F,\
\
    SG_PIXELFORMAT_RGBA32UI,\
    SG_PIXELFORMAT_RGBA32SI,\
    SG_PIXELFORMAT_RGBA32F,\
\
    // NOTE: when adding/removing pixel formats before DEPTH, also update sokol_app.h/_SAPP_PIXELFORMAT_*\
    SG_PIXELFORMAT_DEPTH,\
    SG_PIXELFORMAT_DEPTH_STENCIL,\
\
    // NOTE: don't put any new compressed format in front of here\
    SG_PIXELFORMAT_BC1_RGBA,\
    SG_PIXELFORMAT_BC2_RGBA,\
    SG_PIXELFORMAT_BC3_RGBA,\
    SG_PIXELFORMAT_BC3_SRGBA,\
    SG_PIXELFORMAT_BC4_R,\
    SG_PIXELFORMAT_BC4_RSN,\
    SG_PIXELFORMAT_BC5_RG,\
    SG_PIXELFORMAT_BC5_RGSN,\
    SG_PIXELFORMAT_BC6H_RGBF,\
    SG_PIXELFORMAT_BC6H_RGBUF,\
    SG_PIXELFORMAT_BC7_RGBA,\
    SG_PIXELFORMAT_BC7_SRGBA,\
    SG_PIXELFORMAT_PVRTC_RGB_2BPP,      // FIXME: deprecated\
    SG_PIXELFORMAT_PVRTC_RGB_4BPP,      // FIXME: deprecated\
    SG_PIXELFORMAT_PVRTC_RGBA_2BPP,     // FIXME: deprecated\
    SG_PIXELFORMAT_PVRTC_RGBA_4BPP,     // FIXME: deprecated\
    SG_PIXELFORMAT_ETC2_RGB8,\
    SG_PIXELFORMAT_ETC2_SRGB8,\
    SG_PIXELFORMAT_ETC2_RGB8A1,\
    SG_PIXELFORMAT_ETC2_RGBA8,\
    SG_PIXELFORMAT_ETC2_SRGB8A8,\
    SG_PIXELFORMAT_EAC_R11,\
    SG_PIXELFORMAT_EAC_R11SN,\
    SG_PIXELFORMAT_EAC_RG11,\
    SG_PIXELFORMAT_EAC_RG11SN,\
\
    SG_PIXELFORMAT_ASTC_4x4_RGBA,\
    SG_PIXELFORMAT_ASTC_4x4_SRGBA,\
\
    _SG_PIXELFORMAT_NUM,\
    _SG_PIXELFORMAT_FORCE_U32 = 0x7FFFFFFF\
} sg_pixel_format;\
\
/*\
    Runtime information about a pixel format, returned\
    by sg_query_pixelformat().\
*/\
typedef struct sg_pixelformat_info {\
    bool sample;            // pixel format can be sampled in shaders at least with nearest filtering\
    bool filter;            // pixel format can be sampled with linear filtering\
    bool render;            // pixel format can be used as render target\
    bool blend;             // alpha-blending is supported\
    bool msaa;              // pixel format can be used as MSAA render target\
    bool depth;             // pixel format is a depth format\
    bool compressed;        // true if this is a hardware-compressed format\
    int bytes_per_pixel;    // NOTE: this is 0 for compressed formats, use sg_query_row_pitch() / sg_query_surface_pitch() as alternative\
} sg_pixelformat_info;\
\
/*\
    Runtime information about available optional features,\
    returned by sg_query_features()\
*/\
typedef struct sg_features {\
    bool origin_top_left;               // framebuffer and texture origin is in top left corner\
    bool image_clamp_to_border;         // border color and clamp-to-border UV-wrap mode is supported\
    bool mrt_independent_blend_state;   // multiple-render-target rendering can use per-render-target blend state\
    bool mrt_independent_write_mask;    // multiple-render-target rendering can use per-render-target color write masks\
    bool storage_buffer;                // storage buffers are supported\
} sg_features;\
\
/*\
    Runtime information about resource limits, returned by sg_query_limit()\
*/\
typedef struct sg_limits {\
    int max_image_size_2d;          // max width/height of SG_IMAGETYPE_2D images\
    int max_image_size_cube;        // max width/height of SG_IMAGETYPE_CUBE images\
    int max_image_size_3d;          // max width/height/depth of SG_IMAGETYPE_3D images\
    int max_image_size_array;       // max width/height of SG_IMAGETYPE_ARRAY images\
    int max_image_array_layers;     // max number of layers in SG_IMAGETYPE_ARRAY images\
    int max_vertex_attrs;           // max number of vertex attributes, clamped to SG_MAX_VERTEX_ATTRIBUTES\
    int gl_max_vertex_uniform_components;    // <= GL_MAX_VERTEX_UNIFORM_COMPONENTS (only on GL backends)\
    int gl_max_combined_texture_image_units; // <= GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS (only on GL backends)\
} sg_limits;\
\
/*\
    sg_resource_state\
\
    The current state of a resource in its resource pool.\
    Resources start in the INITIAL state, which means the\
    pool slot is unoccupied and can be allocated. When a resource is\
    created, first an id is allocated, and the resource pool slot\
    is set to state ALLOC. After allocation, the resource is\
    initialized, which may result in the VALID or FAILED state. The\
    reason why allocation and initialization are separate is because\
    some resource types (e.g. buffers and images) might be asynchronously\
    initialized by the user application. If a resource which is not\
    in the VALID state is attempted to be used for rendering, rendering\
    operations will silently be dropped.\
\
    The special INVALID state is returned in sg_query_xxx_state() if no\
    resource object exists for the provided resource id.\
*/\
typedef enum sg_resource_state {\
    SG_RESOURCESTATE_INITIAL,\
    SG_RESOURCESTATE_ALLOC,\
    SG_RESOURCESTATE_VALID,\
    SG_RESOURCESTATE_FAILED,\
    SG_RESOURCESTATE_INVALID,\
    _SG_RESOURCESTATE_FORCE_U32 = 0x7FFFFFFF\
} sg_resource_state;\
\
/*\
    sg_usage\
\
    A resource usage hint describing the update strategy of\
    buffers and images. This is used in the sg_buffer_desc.usage\
    and sg_image_desc.usage members when creating buffers\
    and images:\
\
    SG_USAGE_IMMUTABLE:     the resource will never be updated with\
                            new data, instead the content of the\
                            resource must be provided on creation\
    SG_USAGE_DYNAMIC:       the resource will be updated infrequently\
                            with new data (this could range from \"once\
                            after creation\", to \"quite often but not\
                            every frame\")\
    SG_USAGE_STREAM:        the resource will be updated each frame\
                            with new content\
\
    The rendering backends use this hint to prevent that the\
    CPU needs to wait for the GPU when attempting to update\
    a resource that might be currently accessed by the GPU.\
\
    Resource content is updated with the functions sg_update_buffer() or\
    sg_append_buffer() for buffer objects, and sg_update_image() for image\
    objects. For the sg_update_*() functions, only one update is allowed per\
    frame and resource object, while sg_append_buffer() can be called\
    multiple times per frame on the same buffer. The application must update\
    all data required for rendering (this means that the update data can be\
    smaller than the resource size, if only a part of the overall resource\
    size is used for rendering, you only need to make sure that the data that\
    *is* used is valid).\
\
    The default usage is SG_USAGE_IMMUTABLE.\
*/\
typedef enum sg_usage {\
    _SG_USAGE_DEFAULT,      // value 0 reserved for default-init\
    SG_USAGE_IMMUTABLE,\
    SG_USAGE_DYNAMIC,\
    SG_USAGE_STREAM,\
    _SG_USAGE_NUM,\
    _SG_USAGE_FORCE_U32 = 0x7FFFFFFF\
} sg_usage;\
\
/*\
    sg_buffer_type\
\
    Indicates whether a buffer will be bound as vertex-,\
    index- or storage-buffer.\
\
    Used in the sg_buffer_desc.type member when creating a buffer.\
\
    The default value is SG_BUFFERTYPE_VERTEXBUFFER.\
*/\
typedef enum sg_buffer_type {\
    _SG_BUFFERTYPE_DEFAULT,         // value 0 reserved for default-init\
    SG_BUFFERTYPE_VERTEXBUFFER,\
    SG_BUFFERTYPE_INDEXBUFFER,\
    SG_BUFFERTYPE_STORAGEBUFFER,\
    _SG_BUFFERTYPE_NUM,\
    _SG_BUFFERTYPE_FORCE_U32 = 0x7FFFFFFF\
} sg_buffer_type;\
\
/*\
    sg_index_type\
\
    Indicates whether indexed rendering (fetching vertex-indices from an\
    index buffer) is used, and if yes, the index data type (16- or 32-bits).\
    This is used in the sg_pipeline_desc.index_type member when creating a\
    pipeline object.\
\
    The default index type is SG_INDEXTYPE_NONE.\
*/\
typedef enum sg_index_type {\
    _SG_INDEXTYPE_DEFAULT,   // value 0 reserved for default-init\
    SG_INDEXTYPE_NONE,\
    SG_INDEXTYPE_UINT16,\
    SG_INDEXTYPE_UINT32,\
    _SG_INDEXTYPE_NUM,\
    _SG_INDEXTYPE_FORCE_U32 = 0x7FFFFFFF\
} sg_index_type;\
\
/*\
    sg_image_type\
\
    Indicates the basic type of an image object (2D-texture, cubemap,\
    3D-texture or 2D-array-texture). Used in the sg_image_desc.type member when\
    creating an image, and in sg_shader_image_desc to describe a sampled texture\
    in the shader (both must match and will be checked in the validation layer\
    when calling sg_apply_bindings).\
\
    The default image type when creating an image is SG_IMAGETYPE_2D.\
*/\
typedef enum sg_image_type {\
    _SG_IMAGETYPE_DEFAULT,  // value 0 reserved for default-init\
    SG_IMAGETYPE_2D,\
    SG_IMAGETYPE_CUBE,\
    SG_IMAGETYPE_3D,\
    SG_IMAGETYPE_ARRAY,\
    _SG_IMAGETYPE_NUM,\
    _SG_IMAGETYPE_FORCE_U32 = 0x7FFFFFFF\
} sg_image_type;\
\
/*\
    sg_image_sample_type\
\
    The basic data type of a texture sample as expected by a shader.\
    Must be provided in sg_shader_image_desc and used by the validation\
    layer in sg_apply_bindings() to check if the provided image object\
    is compatible with what the shader expects. Apart from the sokol-gfx\
    validation layer, WebGPU is the only backend API which actually requires\
    matching texture and sampler type to be provided upfront for validation\
    (other 3D APIs treat texture/sampler type mismatches as undefined behaviour).\
\
    NOTE that the following texture pixel formats require the use\
    of SG_IMAGESAMPLETYPE_UNFILTERABLE_FLOAT, combined with a sampler\
    of type SG_SAMPLERTYPE_NONFILTERING:\
\
    - SG_PIXELFORMAT_R32F\
    - SG_PIXELFORMAT_RG32F\
    - SG_PIXELFORMAT_RGBA32F\
\
    (when using sokol-shdc, also check out the meta tags `@image_sample_type`\
    and `@sampler_type`)\
*/\
typedef enum sg_image_sample_type {\
    _SG_IMAGESAMPLETYPE_DEFAULT,  // value 0 reserved for default-init\
    SG_IMAGESAMPLETYPE_FLOAT,\
    SG_IMAGESAMPLETYPE_DEPTH,\
    SG_IMAGESAMPLETYPE_SINT,\
    SG_IMAGESAMPLETYPE_UINT,\
    SG_IMAGESAMPLETYPE_UNFILTERABLE_FLOAT,\
    _SG_IMAGESAMPLETYPE_NUM,\
    _SG_IMAGESAMPLETYPE_FORCE_U32 = 0x7FFFFFFF\
} sg_image_sample_type;\
\
/*\
    sg_sampler_type\
\
    The basic type of a texture sampler (sampling vs comparison) as\
    defined in a shader. Must be provided in sg_shader_sampler_desc.\
\
    sg_image_sample_type and sg_sampler_type for a texture/sampler\
    pair must be compatible with each other, specifically only\
    the following pairs are allowed:\
\
    - SG_IMAGESAMPLETYPE_FLOAT => (SG_SAMPLERTYPE_FILTERING or SG_SAMPLERTYPE_NONFILTERING)\
    - SG_IMAGESAMPLETYPE_UNFILTERABLE_FLOAT => SG_SAMPLERTYPE_NONFILTERING\
    - SG_IMAGESAMPLETYPE_SINT => SG_SAMPLERTYPE_NONFILTERING\
    - SG_IMAGESAMPLETYPE_UINT => SG_SAMPLERTYPE_NONFILTERING\
    - SG_IMAGESAMPLETYPE_DEPTH => SG_SAMPLERTYPE_COMPARISON\
*/\
typedef enum sg_sampler_type {\
    _SG_SAMPLERTYPE_DEFAULT,\
    SG_SAMPLERTYPE_FILTERING,\
    SG_SAMPLERTYPE_NONFILTERING,\
    SG_SAMPLERTYPE_COMPARISON,\
    _SG_SAMPLERTYPE_NUM,\
    _SG_SAMPLERTYPE_FORCE_U32,\
} sg_sampler_type;\
\
/*\
    sg_cube_face\
\
    The cubemap faces. Use these as indices in the sg_image_desc.content\
    array.\
*/\
typedef enum sg_cube_face {\
    SG_CUBEFACE_POS_X,\
    SG_CUBEFACE_NEG_X,\
    SG_CUBEFACE_POS_Y,\
    SG_CUBEFACE_NEG_Y,\
    SG_CUBEFACE_POS_Z,\
    SG_CUBEFACE_NEG_Z,\
    SG_CUBEFACE_NUM,\
    _SG_CUBEFACE_FORCE_U32 = 0x7FFFFFFF\
} sg_cube_face;\
\
/*\
    sg_shader_stage\
\
    There are 2 shader stages: vertex- and fragment-shader-stage.\
    Each shader stage\
\
    - SG_MAX_SHADERSTAGE_UBS slots for applying uniform data\
    - SG_MAX_SHADERSTAGE_IMAGES slots for images used as textures\
    - SG_MAX_SHADERSTAGE_SAMPLERS slots for texture samplers\
    - SG_MAX_SHADERSTAGE_STORAGEBUFFERS slots for storage buffer bindings\
*/\
typedef enum sg_shader_stage {\
    SG_SHADERSTAGE_VS,\
    SG_SHADERSTAGE_FS,\
    _SG_SHADERSTAGE_FORCE_U32 = 0x7FFFFFFF\
} sg_shader_stage;\
\
/*\
    sg_primitive_type\
\
    This is the common subset of 3D primitive types supported across all 3D\
    APIs. This is used in the sg_pipeline_desc.primitive_type member when\
    creating a pipeline object.\
\
    The default primitive type is SG_PRIMITIVETYPE_TRIANGLES.\
*/\
typedef enum sg_primitive_type {\
    _SG_PRIMITIVETYPE_DEFAULT,  // value 0 reserved for default-init\
    SG_PRIMITIVETYPE_POINTS,\
    SG_PRIMITIVETYPE_LINES,\
    SG_PRIMITIVETYPE_LINE_STRIP,\
    SG_PRIMITIVETYPE_TRIANGLES,\
    SG_PRIMITIVETYPE_TRIANGLE_STRIP,\
    _SG_PRIMITIVETYPE_NUM,\
    _SG_PRIMITIVETYPE_FORCE_U32 = 0x7FFFFFFF\
} sg_primitive_type;\
\
/*\
    sg_filter\
\
    The filtering mode when sampling a texture image. This is\
    used in the sg_sampler_desc.min_filter, sg_sampler_desc.mag_filter\
    and sg_sampler_desc.mipmap_filter members when creating a sampler object.\
\
    For the default is SG_FILTER_NEAREST.\
*/\
typedef enum sg_filter {\
    _SG_FILTER_DEFAULT, // value 0 reserved for default-init\
    SG_FILTER_NEAREST,\
    SG_FILTER_LINEAR,\
    _SG_FILTER_NUM,\
    _SG_FILTER_FORCE_U32 = 0x7FFFFFFF\
} sg_filter;\
\
/*\
    sg_wrap\
\
    The texture coordinates wrapping mode when sampling a texture\
    image. This is used in the sg_image_desc.wrap_u, .wrap_v\
    and .wrap_w members when creating an image.\
\
    The default wrap mode is SG_WRAP_REPEAT.\
\
    NOTE: SG_WRAP_CLAMP_TO_BORDER is not supported on all backends\
    and platforms. To check for support, call sg_query_features()\
    and check the \"clamp_to_border\" boolean in the returned\
    sg_features struct.\
\
    Platforms which don't support SG_WRAP_CLAMP_TO_BORDER will silently fall back\
    to SG_WRAP_CLAMP_TO_EDGE without a validation error.\
*/\
typedef enum sg_wrap {\
    _SG_WRAP_DEFAULT,   // value 0 reserved for default-init\
    SG_WRAP_REPEAT,\
    SG_WRAP_CLAMP_TO_EDGE,\
    SG_WRAP_CLAMP_TO_BORDER,\
    SG_WRAP_MIRRORED_REPEAT,\
    _SG_WRAP_NUM,\
    _SG_WRAP_FORCE_U32 = 0x7FFFFFFF\
} sg_wrap;\
\
/*\
    sg_border_color\
\
    The border color to use when sampling a texture, and the UV wrap\
    mode is SG_WRAP_CLAMP_TO_BORDER.\
\
    The default border color is SG_BORDERCOLOR_OPAQUE_BLACK\
*/\
typedef enum sg_border_color {\
    _SG_BORDERCOLOR_DEFAULT,    // value 0 reserved for default-init\
    SG_BORDERCOLOR_TRANSPARENT_BLACK,\
    SG_BORDERCOLOR_OPAQUE_BLACK,\
    SG_BORDERCOLOR_OPAQUE_WHITE,\
    _SG_BORDERCOLOR_NUM,\
    _SG_BORDERCOLOR_FORCE_U32 = 0x7FFFFFFF\
} sg_border_color;\
\
/*\
    sg_vertex_format\
\
    The data type of a vertex component. This is used to describe\
    the layout of vertex data when creating a pipeline object.\
*/\
typedef enum sg_vertex_format {\
    SG_VERTEXFORMAT_INVALID,\
    SG_VERTEXFORMAT_FLOAT,\
    SG_VERTEXFORMAT_FLOAT2,\
    SG_VERTEXFORMAT_FLOAT3,\
    SG_VERTEXFORMAT_FLOAT4,\
    SG_VERTEXFORMAT_BYTE4,\
    SG_VERTEXFORMAT_BYTE4N,\
    SG_VERTEXFORMAT_UBYTE4,\
    SG_VERTEXFORMAT_UBYTE4N,\
    SG_VERTEXFORMAT_SHORT2,\
    SG_VERTEXFORMAT_SHORT2N,\
    SG_VERTEXFORMAT_USHORT2N,\
    SG_VERTEXFORMAT_SHORT4,\
    SG_VERTEXFORMAT_SHORT4N,\
    SG_VERTEXFORMAT_USHORT4N,\
    SG_VERTEXFORMAT_UINT10_N2,\
    SG_VERTEXFORMAT_HALF2,\
    SG_VERTEXFORMAT_HALF4,\
    _SG_VERTEXFORMAT_NUM,\
    _SG_VERTEXFORMAT_FORCE_U32 = 0x7FFFFFFF\
} sg_vertex_format;\
\
/*\
    sg_vertex_step\
\
    Defines whether the input pointer of a vertex input stream is advanced\
    'per vertex' or 'per instance'. The default step-func is\
    SG_VERTEXSTEP_PER_VERTEX. SG_VERTEXSTEP_PER_INSTANCE is used with\
    instanced-rendering.\
\
    The vertex-step is part of the vertex-layout definition\
    when creating pipeline objects.\
*/\
typedef enum sg_vertex_step {\
    _SG_VERTEXSTEP_DEFAULT,     // value 0 reserved for default-init\
    SG_VERTEXSTEP_PER_VERTEX,\
    SG_VERTEXSTEP_PER_INSTANCE,\
    _SG_VERTEXSTEP_NUM,\
    _SG_VERTEXSTEP_FORCE_U32 = 0x7FFFFFFF\
} sg_vertex_step;\
\
/*\
    sg_uniform_type\
\
    The data type of a uniform block member. This is used to\
    describe the internal layout of uniform blocks when creating\
    a shader object.\
*/\
typedef enum sg_uniform_type {\
    SG_UNIFORMTYPE_INVALID,\
    SG_UNIFORMTYPE_FLOAT,\
    SG_UNIFORMTYPE_FLOAT2,\
    SG_UNIFORMTYPE_FLOAT3,\
    SG_UNIFORMTYPE_FLOAT4,\
    SG_UNIFORMTYPE_INT,\
    SG_UNIFORMTYPE_INT2,\
    SG_UNIFORMTYPE_INT3,\
    SG_UNIFORMTYPE_INT4,\
    SG_UNIFORMTYPE_MAT4,\
    _SG_UNIFORMTYPE_NUM,\
    _SG_UNIFORMTYPE_FORCE_U32 = 0x7FFFFFFF\
} sg_uniform_type;\
\
/*\
    sg_uniform_layout\
\
    A hint for the interior memory layout of uniform blocks. This is\
    only really relevant for the GL backend where the internal layout\
    of uniform blocks must be known to sokol-gfx. For all other backends the\
    internal memory layout of uniform blocks doesn't matter, sokol-gfx\
    will just pass uniform data as a single memory blob to the\
    3D backend.\
\
    SG_UNIFORMLAYOUT_NATIVE (default)\
        Native layout means that a 'backend-native' memory layout\
        is used. For the GL backend this means that uniforms\
        are packed tightly in memory (e.g. there are no padding\
        bytes).\
\
    SG_UNIFORMLAYOUT_STD140\
        The memory layout is a subset of std140. Arrays are only\
        allowed for the FLOAT4, INT4 and MAT4. Alignment is as\
        is as follows:\
\
            FLOAT, INT:         4 byte alignment\
            FLOAT2, INT2:       8 byte alignment\
            FLOAT3, INT3:       16 byte alignment(!)\
            FLOAT4, INT4:       16 byte alignment\
            MAT4:               16 byte alignment\
            FLOAT4[], INT4[]:   16 byte alignment\
\
        The overall size of the uniform block must be a multiple\
        of 16.\
\
    For more information search for 'UNIFORM DATA LAYOUT' in the documentation block\
    at the start of the header.\
*/\
typedef enum sg_uniform_layout {\
    _SG_UNIFORMLAYOUT_DEFAULT,     // value 0 reserved for default-init\
    SG_UNIFORMLAYOUT_NATIVE,       // default: layout depends on currently active backend\
    SG_UNIFORMLAYOUT_STD140,       // std140: memory layout according to std140\
    _SG_UNIFORMLAYOUT_NUM,\
    _SG_UNIFORMLAYOUT_FORCE_U32 = 0x7FFFFFFF\
} sg_uniform_layout;\
\
/*\
    sg_cull_mode\
\
    The face-culling mode, this is used in the\
    sg_pipeline_desc.cull_mode member when creating a\
    pipeline object.\
\
    The default cull mode is SG_CULLMODE_NONE\
*/\
typedef enum sg_cull_mode {\
    _SG_CULLMODE_DEFAULT,   // value 0 reserved for default-init\
    SG_CULLMODE_NONE,\
    SG_CULLMODE_FRONT,\
    SG_CULLMODE_BACK,\
    _SG_CULLMODE_NUM,\
    _SG_CULLMODE_FORCE_U32 = 0x7FFFFFFF\
} sg_cull_mode;\
\
/*\
    sg_face_winding\
\
    The vertex-winding rule that determines a front-facing primitive. This\
    is used in the member sg_pipeline_desc.face_winding\
    when creating a pipeline object.\
\
    The default winding is SG_FACEWINDING_CW (clockwise)\
*/\
typedef enum sg_face_winding {\
    _SG_FACEWINDING_DEFAULT,    // value 0 reserved for default-init\
    SG_FACEWINDING_CCW,\
    SG_FACEWINDING_CW,\
    _SG_FACEWINDING_NUM,\
    _SG_FACEWINDING_FORCE_U32 = 0x7FFFFFFF\
} sg_face_winding;\
\
/*\
    sg_compare_func\
\
    The compare-function for configuring depth- and stencil-ref tests\
    in pipeline objects, and for texture samplers which perform a comparison\
    instead of regular sampling operation.\
\
    sg_pipeline_desc\
        .depth\
            .compare\
        .stencil\
            .front.compare\
            .back.compar\
\
    sg_sampler_desc\
        .compare\
\
    The default compare func for depth- and stencil-tests is\
    SG_COMPAREFUNC_ALWAYS.\
\
    The default compare func for sampler is SG_COMPAREFUNC_NEVER.\
*/\
typedef enum sg_compare_func {\
    _SG_COMPAREFUNC_DEFAULT,    // value 0 reserved for default-init\
    SG_COMPAREFUNC_NEVER,\
    SG_COMPAREFUNC_LESS,\
    SG_COMPAREFUNC_EQUAL,\
    SG_COMPAREFUNC_LESS_EQUAL,\
    SG_COMPAREFUNC_GREATER,\
    SG_COMPAREFUNC_NOT_EQUAL,\
    SG_COMPAREFUNC_GREATER_EQUAL,\
    SG_COMPAREFUNC_ALWAYS,\
    _SG_COMPAREFUNC_NUM,\
    _SG_COMPAREFUNC_FORCE_U32 = 0x7FFFFFFF\
} sg_compare_func;\
\
/*\
    sg_stencil_op\
\
    The operation performed on a currently stored stencil-value when a\
    comparison test passes or fails. This is used when creating a pipeline\
    object in the members:\
\
    sg_pipeline_desc\
        .stencil\
            .front\
                .fail_op\
                .depth_fail_op\
                .pass_op\
            .back\
                .fail_op\
                .depth_fail_op\
                .pass_op\
\
    The default value is SG_STENCILOP_KEEP.\
*/\
typedef enum sg_stencil_op {\
    _SG_STENCILOP_DEFAULT,      // value 0 reserved for default-init\
    SG_STENCILOP_KEEP,\
    SG_STENCILOP_ZERO,\
    SG_STENCILOP_REPLACE,\
    SG_STENCILOP_INCR_CLAMP,\
    SG_STENCILOP_DECR_CLAMP,\
    SG_STENCILOP_INVERT,\
    SG_STENCILOP_INCR_WRAP,\
    SG_STENCILOP_DECR_WRAP,\
    _SG_STENCILOP_NUM,\
    _SG_STENCILOP_FORCE_U32 = 0x7FFFFFFF\
} sg_stencil_op;\
\
/*\
    sg_blend_factor\
\
    The source and destination factors in blending operations.\
    This is used in the following members when creating a pipeline object:\
\
    sg_pipeline_desc\
        .colors[i]\
            .blend\
                .src_factor_rgb\
                .dst_factor_rgb\
                .src_factor_alpha\
                .dst_factor_alpha\
\
    The default value is SG_BLENDFACTOR_ONE for source\
    factors, and SG_BLENDFACTOR_ZERO for destination factors.\
*/\
typedef enum sg_blend_factor {\
    _SG_BLENDFACTOR_DEFAULT,    // value 0 reserved for default-init\
    SG_BLENDFACTOR_ZERO,\
    SG_BLENDFACTOR_ONE,\
    SG_BLENDFACTOR_SRC_COLOR,\
    SG_BLENDFACTOR_ONE_MINUS_SRC_COLOR,\
    SG_BLENDFACTOR_SRC_ALPHA,\
    SG_BLENDFACTOR_ONE_MINUS_SRC_ALPHA,\
    SG_BLENDFACTOR_DST_COLOR,\
    SG_BLENDFACTOR_ONE_MINUS_DST_COLOR,\
    SG_BLENDFACTOR_DST_ALPHA,\
    SG_BLENDFACTOR_ONE_MINUS_DST_ALPHA,\
    SG_BLENDFACTOR_SRC_ALPHA_SATURATED,\
    SG_BLENDFACTOR_BLEND_COLOR,\
    SG_BLENDFACTOR_ONE_MINUS_BLEND_COLOR,\
    SG_BLENDFACTOR_BLEND_ALPHA,\
    SG_BLENDFACTOR_ONE_MINUS_BLEND_ALPHA,\
    _SG_BLENDFACTOR_NUM,\
    _SG_BLENDFACTOR_FORCE_U32 = 0x7FFFFFFF\
} sg_blend_factor;\
\
/*\
    sg_blend_op\
\
    Describes how the source and destination values are combined in the\
    fragment blending operation. It is used in the following members when\
    creating a pipeline object:\
\
    sg_pipeline_desc\
        .colors[i]\
            .blend\
                .op_rgb\
                .op_alpha\
\
    The default value is SG_BLENDOP_ADD.\
*/\
typedef enum sg_blend_op {\
    _SG_BLENDOP_DEFAULT,    // value 0 reserved for default-init\
    SG_BLENDOP_ADD,\
    SG_BLENDOP_SUBTRACT,\
    SG_BLENDOP_REVERSE_SUBTRACT,\
    _SG_BLENDOP_NUM,\
    _SG_BLENDOP_FORCE_U32 = 0x7FFFFFFF\
} sg_blend_op;\
\
/*\
    sg_color_mask\
\
    Selects the active color channels when writing a fragment color to the\
    framebuffer. This is used in the members\
    sg_pipeline_desc.colors[i].write_mask when creating a pipeline object.\
\
    The default colormask is SG_COLORMASK_RGBA (write all colors channels)\
\
    NOTE: since the color mask value 0 is reserved for the default value\
    (SG_COLORMASK_RGBA), use SG_COLORMASK_NONE if all color channels\
    should be disabled.\
*/\
typedef enum sg_color_mask {\
    _SG_COLORMASK_DEFAULT = 0,    // value 0 reserved for default-init\
    SG_COLORMASK_NONE   = 0x10,   // special value for 'all channels disabled\
    SG_COLORMASK_R      = 0x1,\
    SG_COLORMASK_G      = 0x2,\
    SG_COLORMASK_RG     = 0x3,\
    SG_COLORMASK_B      = 0x4,\
    SG_COLORMASK_RB     = 0x5,\
    SG_COLORMASK_GB     = 0x6,\
    SG_COLORMASK_RGB    = 0x7,\
    SG_COLORMASK_A      = 0x8,\
    SG_COLORMASK_RA     = 0x9,\
    SG_COLORMASK_GA     = 0xA,\
    SG_COLORMASK_RGA    = 0xB,\
    SG_COLORMASK_BA     = 0xC,\
    SG_COLORMASK_RBA    = 0xD,\
    SG_COLORMASK_GBA    = 0xE,\
    SG_COLORMASK_RGBA   = 0xF,\
    _SG_COLORMASK_FORCE_U32 = 0x7FFFFFFF\
} sg_color_mask;\
\
/*\
    sg_load_action\
\
    Defines the load action that should be performed at the start of a render pass:\
\
    SG_LOADACTION_CLEAR:        clear the render target\
    SG_LOADACTION_LOAD:         load the previous content of the render target\
    SG_LOADACTION_DONTCARE:     leave the render target in an undefined state\
\
    This is used in the sg_pass_action structure.\
\
    The default load action for all pass attachments is SG_LOADACTION_CLEAR,\
    with the values rgba = { 0.5f, 0.5f, 0.5f, 1.0f }, depth=1.0f and stencil=0.\
\
    If you want to override the default behaviour, it is important to not\
    only set the clear color, but the 'action' field as well (as long as this\
    is _SG_LOADACTION_DEFAULT, the value fields will be ignored).\
*/\
typedef enum sg_load_action {\
    _SG_LOADACTION_DEFAULT,\
    SG_LOADACTION_CLEAR,\
    SG_LOADACTION_LOAD,\
    SG_LOADACTION_DONTCARE,\
    _SG_LOADACTION_FORCE_U32 = 0x7FFFFFFF\
} sg_load_action;\
\
/*\
    sg_store_action\
\
    Defines the store action that be performed at the end of a render pass:\
\
    SG_STOREACTION_STORE:       store the rendered content to the color attachment image\
    SG_STOREACTION_DONTCARE:    allows the GPU to discard the rendered content\
*/\
typedef enum sg_store_action {\
    _SG_STOREACTION_DEFAULT,\
    SG_STOREACTION_STORE,\
    SG_STOREACTION_DONTCARE,\
    _SG_STOREACTION_FORCE_U32 = 0x7FFFFFFF\
} sg_store_action;\
\
\
/*\
    sg_pass_action\
\
    The sg_pass_action struct defines the actions to be performed\
    at the start and end of a render pass.\
\
    - at the start of the pass: whether the render targets should be cleared,\
      loaded with their previous content, or start in an undefined state\
    - for clear operations: the clear value (color, depth, or stencil values)\
    - at the end of the pass: whether the rendering result should be\
      stored back into the render target or discarded\
*/\
typedef struct sg_color_attachment_action {\
    sg_load_action load_action;         // default: SG_LOADACTION_CLEAR\
    sg_store_action store_action;       // default: SG_STOREACTION_STORE\
    sg_color clear_value;               // default: { 0.5f, 0.5f, 0.5f, 1.0f }\
} sg_color_attachment_action;\
\
typedef struct sg_depth_attachment_action {\
    sg_load_action load_action;         // default: SG_LOADACTION_CLEAR\
    sg_store_action store_action;       // default: SG_STOREACTION_DONTCARE\
    float clear_value;                  // default: 1.0\
} sg_depth_attachment_action;\
\
typedef struct sg_stencil_attachment_action {\
    sg_load_action load_action;         // default: SG_LOADACTION_CLEAR\
    sg_store_action store_action;       // default: SG_STOREACTION_DONTCARE\
    uint8_t clear_value;                // default: 0\
} sg_stencil_attachment_action;\
\
typedef struct sg_pass_action {\
    sg_color_attachment_action colors[SG_MAX_COLOR_ATTACHMENTS];\
    sg_depth_attachment_action depth;\
    sg_stencil_attachment_action stencil;\
} sg_pass_action;\
\
/*\
    sg_swapchain\
\
    Used in sg_begin_pass() to provide details about an external swapchain\
    (pixel formats, sample count and backend-API specific render surface objects).\
\
    The following information must be provided:\
\
    - the width and height of the swapchain surfaces in number of pixels,\
    - the pixel format of the render- and optional msaa-resolve-surface\
    - the pixel format of the optional depth- or depth-stencil-surface\
    - the MSAA sample count for the render and depth-stencil surface\
\
    If the pixel formats and MSAA sample counts are left zero-initialized,\
    their defaults are taken from the sg_environment struct provided in the\
    sg_setup() call.\
\
    The width and height *must* be > 0.\
\
    Additionally the following backend API specific objects must be passed in\
    as 'type erased' void pointers:\
\
    GL: on all GL backends, a GL framebuffer object must be provided. This\
    can be zero for the default framebuffer.\
\
    D3D11:\
        - an ID3D11RenderTargetView for the rendering surface, without\
          MSAA rendering this surface will also be displayed\
        - an optional ID3D11DepthStencilView for the depth- or depth/stencil\
          buffer surface\
        - when MSAA rendering is used, another ID3D11RenderTargetView\
          which serves as MSAA resolve target and will be displayed\
\
    WebGPU (same as D3D11, except different types)\
        - a WGPUTextureView for the rendering surface, without\
          MSAA rendering this surface will also be displayed\
        - an optional WGPUTextureView for the depth- or depth/stencil\
          buffer surface\
        - when MSAA rendering is used, another WGPUTextureView\
          which serves as MSAA resolve target and will be displayed\
\
    Metal (NOTE that the rolves of provided surfaces is slightly different\
    than on D3D11 or WebGPU in case of MSAA vs non-MSAA rendering):\
\
        - A current CAMetalDrawable (NOT an MTLDrawable!) which will be presented.\
          This will either be rendered to directly (if no MSAA is used), or serve\
          as MSAA-resolve target.\
        - an optional MTLTexture for the depth- or depth-stencil buffer\
        - an optional multisampled MTLTexture which serves as intermediate\
          rendering surface which will then be resolved into the\
          CAMetalDrawable.\
\
    NOTE that for Metal you must use an ObjC __bridge cast to\
    properly tunnel the ObjC object handle through a C void*, e.g.:\
\
        swapchain.metal.current_drawable = (__bridge const void*) [mtkView currentDrawable];\
\
    On all other backends you shouldn't need to mess with the reference count.\
\
    It's a good practice to write a helper function which returns an initialized\
    sg_swapchain structs, which can then be plugged directly into\
    sg_pass.swapchain. Look at the function sglue_swapchain() in the sokol_glue.h\
    as an example.\
*/\
typedef struct sg_metal_swapchain {\
    const void* current_drawable;       // CAMetalDrawable (NOT MTLDrawable!!!)\
    const void* depth_stencil_texture;  // MTLTexture\
    const void* msaa_color_texture;     // MTLTexture\
} sg_metal_swapchain;\
\
typedef struct sg_d3d11_swapchain {\
    const void* render_view;            // ID3D11RenderTargetView\
    const void* resolve_view;           // ID3D11RenderTargetView\
    const void* depth_stencil_view;     // ID3D11DepthStencilView\
} sg_d3d11_swapchain;\
\
typedef struct sg_wgpu_swapchain {\
    const void* render_view;            // WGPUTextureView\
    const void* resolve_view;           // WGPUTextureView\
    const void* depth_stencil_view;     // WGPUTextureView\
} sg_wgpu_swapchain;\
\
typedef struct sg_gl_swapchain {\
    uint32_t framebuffer;               // GL framebuffer object\
} sg_gl_swapchain;\
\
typedef struct sg_swapchain {\
    int width;\
    int height;\
    int sample_count;\
    sg_pixel_format color_format;\
    sg_pixel_format depth_format;\
    sg_metal_swapchain metal;\
    sg_d3d11_swapchain d3d11;\
    sg_wgpu_swapchain wgpu;\
    sg_gl_swapchain gl;\
} sg_swapchain;\
\
/*\
    sg_pass\
\
    The sg_pass structure is passed as argument into the sg_begin_pass()\
    function.\
\
    For an offscreen rendering pass, an sg_pass_action struct and sg_attachments\
    object must be provided, and for swapchain passes, and sg_pass_action and\
    an sg_swapchain struct. It is an error to provide both an sg_attachments\
    handle and an initialized sg_swapchain struct in the same sg_begin_pass().\
\
    An sg_begin_pass() call for an offscreen pass would look like this (where\
    `attachments` is an sg_attachments handle):\
\
        sg_begin_pass(&(sg_pass){\
            .action = { ... },\
            .attachments = attachments,\
        });\
\
    ...and a swapchain render pass would look like this (using the sokol_glue.h\
    helper function sglue_swapchain() which gets the swapchain properties from\
    sokol_app.h):\
\
        sg_begin_pass(&(sg_pass){\
            .action = { ... },\
            .swapchain = sglue_swapchain(),\
        });\
\
    You can also omit the .action object to get default pass action behaviour\
    (clear to color=grey, depth=1 and stencil=0).\
*/\
typedef struct sg_pass {\
    uint32_t _start_canary;\
    sg_pass_action action;\
    sg_attachments attachments;\
    sg_swapchain swapchain;\
    const char* label;\
    uint32_t _end_canary;\
} sg_pass;\
\
/*\
    sg_bindings\
\
    The sg_bindings structure defines the resource binding slots\
    of the sokol_gfx render pipeline, used as argument to the\
    sg_apply_bindings() function.\
\
    A resource binding struct contains:\
\
    - 1..N vertex buffers\
    - 0..N vertex buffer offsets\
    - 0..1 index buffers\
    - 0..1 index buffer offsets\
    - 0..N vertex shader stage images\
    - 0..N vertex shader stage samplers\
    - 0..N vertex shader storage buffers\
    - 0..N fragment shader stage images\
    - 0..N fragment shader stage samplers\
    - 0..N fragment shader storage buffers\
\
    For the max number of bindings, see the constant definitions:\
\
    - SG_MAX_VERTEX_BUFFERS\
    - SG_MAX_SHADERSTAGE_IMAGES\
    - SG_MAX_SHADERSTAGE_SAMPLERS\
    - SG_MAX_SHADERSTAGE_STORAGEBUFFERS\
\
    The optional buffer offsets can be used to put different unrelated\
    chunks of vertex- and/or index-data into the same buffer objects.\
*/\
typedef struct sg_stage_bindings {\
    sg_image images[SG_MAX_SHADERSTAGE_IMAGES];\
    sg_sampler samplers[SG_MAX_SHADERSTAGE_SAMPLERS];\
    sg_buffer storage_buffers[SG_MAX_SHADERSTAGE_STORAGEBUFFERS];\
} sg_stage_bindings;\
\
typedef struct sg_bindings {\
    uint32_t _start_canary;\
    sg_buffer vertex_buffers[SG_MAX_VERTEX_BUFFERS];\
    int vertex_buffer_offsets[SG_MAX_VERTEX_BUFFERS];\
    sg_buffer index_buffer;\
    int index_buffer_offset;\
    sg_stage_bindings vs;\
    sg_stage_bindings fs;\
    uint32_t _end_canary;\
} sg_bindings;\
\
/*\
    sg_buffer_desc\
\
    Creation parameters for sg_buffer objects, used in the\
    sg_make_buffer() call.\
\
    The default configuration is:\
\
    .size:      0       (*must* be >0 for buffers without data)\
    .type:      SG_BUFFERTYPE_VERTEXBUFFER\
    .usage:     SG_USAGE_IMMUTABLE\
    .data.ptr   0       (*must* be valid for immutable buffers)\
    .data.size  0       (*must* be > 0 for immutable buffers)\
    .label      0       (optional string label)\
\
    For immutable buffers which are initialized with initial data,\
    keep the .size item zero-initialized, and set the size together with the\
    pointer to the initial data in the .data item.\
\
    For mutable buffers without initial data, keep the .data item\
    zero-initialized, and set the buffer size in the .size item instead.\
\
    You can also set both size values, but currently both size values must\
    be identical (this may change in the future when the dynamic resource\
    management may become more flexible).\
\
    ADVANCED TOPIC: Injecting native 3D-API buffers:\
\
    The following struct members allow to inject your own GL, Metal\
    or D3D11 buffers into sokol_gfx:\
\
    .gl_buffers[SG_NUM_INFLIGHT_FRAMES]\
    .mtl_buffers[SG_NUM_INFLIGHT_FRAMES]\
    .d3d11_buffer\
\
    You must still provide all other struct items except the .data item, and\
    these must match the creation parameters of the native buffers you\
    provide. For SG_USAGE_IMMUTABLE, only provide a single native 3D-API\
    buffer, otherwise you need to provide SG_NUM_INFLIGHT_FRAMES buffers\
    (only for GL and Metal, not D3D11). Providing multiple buffers for GL and\
    Metal is necessary because sokol_gfx will rotate through them when\
    calling sg_update_buffer() to prevent lock-stalls.\
\
    Note that it is expected that immutable injected buffer have already been\
    initialized with content, and the .content member must be 0!\
\
    Also you need to call sg_reset_state_cache() after calling native 3D-API\
    functions, and before calling any sokol_gfx function.\
*/\
typedef struct sg_buffer_desc {\
    uint32_t _start_canary;\
    size_t size;\
    sg_buffer_type type;\
    sg_usage usage;\
    sg_range data;\
    const char* label;\
    // optionally inject backend-specific resources\
    uint32_t gl_buffers[SG_NUM_INFLIGHT_FRAMES];\
    const void* mtl_buffers[SG_NUM_INFLIGHT_FRAMES];\
    const void* d3d11_buffer;\
    const void* wgpu_buffer;\
    uint32_t _end_canary;\
} sg_buffer_desc;\
\
/*\
    sg_image_data\
\
    Defines the content of an image through a 2D array of sg_range structs.\
    The first array dimension is the cubemap face, and the second array\
    dimension the mipmap level.\
*/\
typedef struct sg_image_data {\
    sg_range subimage[SG_CUBEFACE_NUM][SG_MAX_MIPMAPS];\
} sg_image_data;\
\
/*\
    sg_image_desc\
\
    Creation parameters for sg_image objects, used in the sg_make_image() call.\
\
    The default configuration is:\
\
    .type:              SG_IMAGETYPE_2D\
    .render_target:     false\
    .width              0 (must be set to >0)\
    .height             0 (must be set to >0)\
    .num_slices         1 (3D textures: depth; array textures: number of layers)\
    .num_mipmaps:       1\
    .usage:             SG_USAGE_IMMUTABLE\
    .pixel_format:      SG_PIXELFORMAT_RGBA8 for textures, or sg_desc.environment.defaults.color_format for render targets\
    .sample_count:      1 for textures, or sg_desc.environment.defaults.sample_count for render targets\
    .data               an sg_image_data struct to define the initial content\
    .label              0 (optional string label for trace hooks)\
\
    Q: Why is the default sample_count for render targets identical with the\
    \"default sample count\" from sg_desc.environment.defaults.sample_count?\
\
    A: So that it matches the default sample count in pipeline objects. Even\
    though it is a bit strange/confusing that offscreen render targets by default\
    get the same sample count as 'default swapchains', but it's better that\
    an offscreen render target created with default parameters matches\
    a pipeline object created with default parameters.\
\
    NOTE:\
\
    Images with usage SG_USAGE_IMMUTABLE must be fully initialized by\
    providing a valid .data member which points to initialization data.\
\
    ADVANCED TOPIC: Injecting native 3D-API textures:\
\
    The following struct members allow to inject your own GL, Metal or D3D11\
    textures into sokol_gfx:\
\
    .gl_textures[SG_NUM_INFLIGHT_FRAMES]\
    .mtl_textures[SG_NUM_INFLIGHT_FRAMES]\
    .d3d11_texture\
    .d3d11_shader_resource_view\
    .wgpu_texture\
    .wgpu_texture_view\
\
    For GL, you can also specify the texture target or leave it empty to use\
    the default texture target for the image type (GL_TEXTURE_2D for\
    SG_IMAGETYPE_2D etc)\
\
    For D3D11 and WebGPU, either only provide a texture, or both a texture and\
    shader-resource-view / texture-view object. If you want to use access the\
    injected texture in a shader you *must* provide a shader-resource-view.\
\
    The same rules apply as for injecting native buffers (see sg_buffer_desc\
    documentation for more details).\
*/\
typedef struct sg_image_desc {\
    uint32_t _start_canary;\
    sg_image_type type;\
    bool render_target;\
    int width;\
    int height;\
    int num_slices;\
    int num_mipmaps;\
    sg_usage usage;\
    sg_pixel_format pixel_format;\
    int sample_count;\
    sg_image_data data;\
    const char* label;\
    // optionally inject backend-specific resources\
    uint32_t gl_textures[SG_NUM_INFLIGHT_FRAMES];\
    uint32_t gl_texture_target;\
    const void* mtl_textures[SG_NUM_INFLIGHT_FRAMES];\
    const void* d3d11_texture;\
    const void* d3d11_shader_resource_view;\
    const void* wgpu_texture;\
    const void* wgpu_texture_view;\
    uint32_t _end_canary;\
} sg_image_desc;\
\
/*\
    sg_sampler_desc\
\
    Creation parameters for sg_sampler objects, used in the sg_make_sampler() call\
\
    .min_filter:        SG_FILTER_NEAREST\
    .mag_filter:        SG_FILTER_NEAREST\
    .mipmap_filter      SG_FILTER_NEAREST\
    .wrap_u:            SG_WRAP_REPEAT\
    .wrap_v:            SG_WRAP_REPEAT\
    .wrap_w:            SG_WRAP_REPEAT (only SG_IMAGETYPE_3D)\
    .min_lod            0.0f\
    .max_lod            FLT_MAX\
    .border_color       SG_BORDERCOLOR_OPAQUE_BLACK\
    .compare            SG_COMPAREFUNC_NEVER\
    .max_anisotropy     1 (must be 1..16)\
\
*/\
typedef struct sg_sampler_desc {\
    uint32_t _start_canary;\
    sg_filter min_filter;\
    sg_filter mag_filter;\
    sg_filter mipmap_filter;\
    sg_wrap wrap_u;\
    sg_wrap wrap_v;\
    sg_wrap wrap_w;\
    float min_lod;\
    float max_lod;\
    sg_border_color border_color;\
    sg_compare_func compare;\
    uint32_t max_anisotropy;\
    const char* label;\
    // optionally inject backend-specific resources\
    uint32_t gl_sampler;\
    const void* mtl_sampler;\
    const void* d3d11_sampler;\
    const void* wgpu_sampler;\
    uint32_t _end_canary;\
} sg_sampler_desc;\
\
/*\
    sg_shader_desc\
\
    The structure sg_shader_desc defines all creation parameters for shader\
    programs, used as input to the sg_make_shader() function:\
\
    - reflection information for vertex attributes (vertex shader inputs):\
        - vertex attribute name (only optionally used by GLES3 and GL)\
        - a semantic name and index (required for D3D11)\
    - for each shader-stage (vertex and fragment):\
        - the shader source or bytecode\
        - an optional entry function name\
        - an optional compile target (only for D3D11 when source is provided,\
          defaults are \"vs_4_0\" and \"ps_4_0\")\
        - reflection info for each uniform block used by the shader stage:\
            - the size of the uniform block in bytes\
            - a memory layout hint (native vs std140, only required for GL backends)\
            - reflection info for each uniform block member (only required for GL backends):\
                - member name\
                - member type (SG_UNIFORMTYPE_xxx)\
                - if the member is an array, the number of array items\
        - reflection info for textures used in the shader stage:\
            - the image type (SG_IMAGETYPE_xxx)\
            - the image-sample type (SG_IMAGESAMPLETYPE_xxx, default is SG_IMAGESAMPLETYPE_FLOAT)\
            - whether the shader expects a multisampled texture\
        - reflection info for samplers used in the shader stage:\
            - the sampler type (SG_SAMPLERTYPE_xxx)\
        - reflection info for each image-sampler-pair used by the shader:\
            - the texture slot of the involved texture\
            - the sampler slot of the involved sampler\
            - for GLSL only: the name of the combined image-sampler object\
        - reflection info for each storage-buffer used by the shader:\
            - whether the storage buffer is readonly (currently this\
              must be true)\
\
    For all GL backends, shader source-code must be provided. For D3D11 and Metal,\
    either shader source-code or byte-code can be provided.\
\
    For D3D11, if source code is provided, the d3dcompiler_47.dll will be loaded\
    on demand. If this fails, shader creation will fail. When compiling HLSL\
    source code, you can provide an optional target string via\
    sg_shader_stage_desc.d3d11_target, the default target is \"vs_4_0\" for the\
    vertex shader stage and \"ps_4_0\" for the pixel shader stage.\
*/\
typedef struct sg_shader_attr_desc {\
    const char* name;           // GLSL vertex attribute name (optional)\
    const char* sem_name;       // HLSL semantic name\
    int sem_index;              // HLSL semantic index\
} sg_shader_attr_desc;\
\
typedef struct sg_shader_uniform_desc {\
    const char* name;\
    sg_uniform_type type;\
    int array_count;\
} sg_shader_uniform_desc;\
\
typedef struct sg_shader_uniform_block_desc {\
    size_t size;\
    sg_uniform_layout layout;\
    sg_shader_uniform_desc uniforms[SG_MAX_UB_MEMBERS];\
} sg_shader_uniform_block_desc;\
\
typedef struct sg_shader_storage_buffer_desc {\
    bool used;\
    bool readonly;\
} sg_shader_storage_buffer_desc;\
\
typedef struct sg_shader_image_desc {\
    bool used;\
    bool multisampled;\
    sg_image_type image_type;\
    sg_image_sample_type sample_type;\
} sg_shader_image_desc;\
\
typedef struct sg_shader_sampler_desc {\
    bool used;\
    sg_sampler_type sampler_type;\
} sg_shader_sampler_desc;\
\
typedef struct sg_shader_image_sampler_pair_desc {\
    bool used;\
    int image_slot;\
    int sampler_slot;\
    const char* glsl_name;\
} sg_shader_image_sampler_pair_desc;\
\
typedef struct sg_shader_stage_desc {\
    const char* source;\
    sg_range bytecode;\
    const char* entry;\
    const char* d3d11_target;\
    sg_shader_uniform_block_desc uniform_blocks[SG_MAX_SHADERSTAGE_UBS];\
    sg_shader_storage_buffer_desc storage_buffers[SG_MAX_SHADERSTAGE_STORAGEBUFFERS];\
    sg_shader_image_desc images[SG_MAX_SHADERSTAGE_IMAGES];\
    sg_shader_sampler_desc samplers[SG_MAX_SHADERSTAGE_SAMPLERS];\
    sg_shader_image_sampler_pair_desc image_sampler_pairs[SG_MAX_SHADERSTAGE_IMAGESAMPLERPAIRS];\
} sg_shader_stage_desc;\
\
typedef struct sg_shader_desc {\
    uint32_t _start_canary;\
    sg_shader_attr_desc attrs[SG_MAX_VERTEX_ATTRIBUTES];\
    sg_shader_stage_desc vs;\
    sg_shader_stage_desc fs;\
    const char* label;\
    uint32_t _end_canary;\
} sg_shader_desc;\
\
/*\
    sg_pipeline_desc\
\
    The sg_pipeline_desc struct defines all creation parameters for an\
    sg_pipeline object, used as argument to the sg_make_pipeline() function:\
\
    - the vertex layout for all input vertex buffers\
    - a shader object\
    - the 3D primitive type (points, lines, triangles, ...)\
    - the index type (none, 16- or 32-bit)\
    - all the fixed-function-pipeline state (depth-, stencil-, blend-state, etc...)\
\
    If the vertex data has no gaps between vertex components, you can omit\
    the .layout.buffers[].stride and layout.attrs[].offset items (leave them\
    default-initialized to 0), sokol-gfx will then compute the offsets and\
    strides from the vertex component formats (.layout.attrs[].format).\
    Please note that ALL vertex attribute offsets must be 0 in order for the\
    automatic offset computation to kick in.\
\
    The default configuration is as follows:\
\
    .shader:            0 (must be initialized with a valid sg_shader id!)\
    .layout:\
        .buffers[]:         vertex buffer layouts\
            .stride:        0 (if no stride is given it will be computed)\
            .step_func      SG_VERTEXSTEP_PER_VERTEX\
            .step_rate      1\
        .attrs[]:           vertex attribute declarations\
            .buffer_index   0 the vertex buffer bind slot\
            .offset         0 (offsets can be omitted if the vertex layout has no gaps)\
            .format         SG_VERTEXFORMAT_INVALID (must be initialized!)\
    .depth:\
        .pixel_format:      sg_desc.context.depth_format\
        .compare:           SG_COMPAREFUNC_ALWAYS\
        .write_enabled:     false\
        .bias:              0.0f\
        .bias_slope_scale:  0.0f\
        .bias_clamp:        0.0f\
    .stencil:\
        .enabled:           false\
        .front/back:\
            .compare:       SG_COMPAREFUNC_ALWAYS\
            .fail_op:       SG_STENCILOP_KEEP\
            .depth_fail_op: SG_STENCILOP_KEEP\
            .pass_op:       SG_STENCILOP_KEEP\
        .read_mask:         0\
        .write_mask:        0\
        .ref:               0\
    .color_count            1\
    .colors[0..color_count]\
        .pixel_format       sg_desc.context.color_format\
        .write_mask:        SG_COLORMASK_RGBA\
        .blend:\
            .enabled:           false\
            .src_factor_rgb:    SG_BLENDFACTOR_ONE\
            .dst_factor_rgb:    SG_BLENDFACTOR_ZERO\
            .op_rgb:            SG_BLENDOP_ADD\
            .src_factor_alpha:  SG_BLENDFACTOR_ONE\
            .dst_factor_alpha:  SG_BLENDFACTOR_ZERO\
            .op_alpha:          SG_BLENDOP_ADD\
    .primitive_type:            SG_PRIMITIVETYPE_TRIANGLES\
    .index_type:                SG_INDEXTYPE_NONE\
    .cull_mode:                 SG_CULLMODE_NONE\
    .face_winding:              SG_FACEWINDING_CW\
    .sample_count:              sg_desc.context.sample_count\
    .blend_color:               (sg_color) { 0.0f, 0.0f, 0.0f, 0.0f }\
    .alpha_to_coverage_enabled: false\
    .label  0       (optional string label for trace hooks)\
*/\
typedef struct sg_vertex_buffer_layout_state {\
    int stride;\
    sg_vertex_step step_func;\
    int step_rate;\
} sg_vertex_buffer_layout_state;\
\
typedef struct sg_vertex_attr_state {\
    int buffer_index;\
    int offset;\
    sg_vertex_format format;\
} sg_vertex_attr_state;\
\
typedef struct sg_vertex_layout_state {\
    sg_vertex_buffer_layout_state buffers[SG_MAX_VERTEX_BUFFERS];\
    sg_vertex_attr_state attrs[SG_MAX_VERTEX_ATTRIBUTES];\
} sg_vertex_layout_state;\
\
typedef struct sg_stencil_face_state {\
    sg_compare_func compare;\
    sg_stencil_op fail_op;\
    sg_stencil_op depth_fail_op;\
    sg_stencil_op pass_op;\
} sg_stencil_face_state;\
\
typedef struct sg_stencil_state {\
    bool enabled;\
    sg_stencil_face_state front;\
    sg_stencil_face_state back;\
    uint8_t read_mask;\
    uint8_t write_mask;\
    uint8_t ref;\
} sg_stencil_state;\
\
typedef struct sg_depth_state {\
    sg_pixel_format pixel_format;\
    sg_compare_func compare;\
    bool write_enabled;\
    float bias;\
    float bias_slope_scale;\
    float bias_clamp;\
} sg_depth_state;\
\
typedef struct sg_blend_state {\
    bool enabled;\
    sg_blend_factor src_factor_rgb;\
    sg_blend_factor dst_factor_rgb;\
    sg_blend_op op_rgb;\
    sg_blend_factor src_factor_alpha;\
    sg_blend_factor dst_factor_alpha;\
    sg_blend_op op_alpha;\
} sg_blend_state;\
\
typedef struct sg_color_target_state {\
    sg_pixel_format pixel_format;\
    sg_color_mask write_mask;\
    sg_blend_state blend;\
} sg_color_target_state;\
\
typedef struct sg_pipeline_desc {\
    uint32_t _start_canary;\
    sg_shader shader;\
    sg_vertex_layout_state layout;\
    sg_depth_state depth;\
    sg_stencil_state stencil;\
    int color_count;\
    sg_color_target_state colors[SG_MAX_COLOR_ATTACHMENTS];\
    sg_primitive_type primitive_type;\
    sg_index_type index_type;\
    sg_cull_mode cull_mode;\
    sg_face_winding face_winding;\
    int sample_count;\
    sg_color blend_color;\
    bool alpha_to_coverage_enabled;\
    const char* label;\
    uint32_t _end_canary;\
} sg_pipeline_desc;\
\
/*\
    sg_attachments_desc\
\
    Creation parameters for an sg_attachments object, used as argument to the\
    sg_make_attachments() function.\
\
    An attachments object bundles 0..4 color attachments, 0..4 msaa-resolve\
    attachments, and none or one depth-stencil attachmente for use\
    in a render pass. At least one color attachment or one depth-stencil\
    attachment must be provided (no color attachment and a depth-stencil\
    attachment is useful for a depth-only render pass).\
\
    Each attachment definition consists of an image object, and two additional indices\
    describing which subimage the pass will render into: one mipmap index, and if the image\
    is a cubemap, array-texture or 3D-texture, the face-index, array-layer or\
    depth-slice.\
\
    All attachments must have the same width and height.\
\
    All color attachments and the depth-stencil attachment must have the\
    same sample count.\
\
    If a resolve attachment is set, an MSAA-resolve operation from the\
    associated color attachment image into the resolve attachment image will take\
    place in the sg_end_pass() function. In this case, the color attachment\
    must have a (sample_count>1), and the resolve attachment a\
    (sample_count==1). The resolve attachment also must have the same pixel\
    format as the color attachment.\
\
    NOTE that MSAA depth-stencil attachments cannot be msaa-resolved!\
*/\
typedef struct sg_attachment_desc {\
    sg_image image;\
    int mip_level;\
    int slice;      // cube texture: face; array texture: layer; 3D texture: slice\
} sg_attachment_desc;\
\
typedef struct sg_attachments_desc {\
    uint32_t _start_canary;\
    sg_attachment_desc colors[SG_MAX_COLOR_ATTACHMENTS];\
    sg_attachment_desc resolves[SG_MAX_COLOR_ATTACHMENTS];\
    sg_attachment_desc depth_stencil;\
    const char* label;\
    uint32_t _end_canary;\
} sg_attachments_desc;\
\
/*\
    sg_trace_hooks\
\
    Installable callback functions to keep track of the sokol-gfx calls,\
    this is useful for debugging, or keeping track of resource creation\
    and destruction.\
\
    Trace hooks are installed with sg_install_trace_hooks(), this returns\
    another sg_trace_hooks struct with the previous set of\
    trace hook function pointers. These should be invoked by the\
    new trace hooks to form a proper call chain.\
*/\
typedef struct sg_trace_hooks {\
    void* user_data;\
    void (*reset_state_cache)(void* user_data);\
    void (*make_buffer)(const sg_buffer_desc* desc, sg_buffer result, void* user_data);\
    void (*make_image)(const sg_image_desc* desc, sg_image result, void* user_data);\
    void (*make_sampler)(const sg_sampler_desc* desc, sg_sampler result, void* user_data);\
    void (*make_shader)(const sg_shader_desc* desc, sg_shader result, void* user_data);\
    void (*make_pipeline)(const sg_pipeline_desc* desc, sg_pipeline result, void* user_data);\
    void (*make_attachments)(const sg_attachments_desc* desc, sg_attachments result, void* user_data);\
    void (*destroy_buffer)(sg_buffer buf, void* user_data);\
    void (*destroy_image)(sg_image img, void* user_data);\
    void (*destroy_sampler)(sg_sampler smp, void* user_data);\
    void (*destroy_shader)(sg_shader shd, void* user_data);\
    void (*destroy_pipeline)(sg_pipeline pip, void* user_data);\
    void (*destroy_attachments)(sg_attachments atts, void* user_data);\
    void (*update_buffer)(sg_buffer buf, const sg_range* data, void* user_data);\
    void (*update_image)(sg_image img, const sg_image_data* data, void* user_data);\
    void (*append_buffer)(sg_buffer buf, const sg_range* data, int result, void* user_data);\
    void (*begin_pass)(const sg_pass* pass, void* user_data);\
    void (*apply_viewport)(int x, int y, int width, int height, bool origin_top_left, void* user_data);\
    void (*apply_scissor_rect)(int x, int y, int width, int height, bool origin_top_left, void* user_data);\
    void (*apply_pipeline)(sg_pipeline pip, void* user_data);\
    void (*apply_bindings)(const sg_bindings* bindings, void* user_data);\
    void (*apply_uniforms)(sg_shader_stage stage, int ub_index, const sg_range* data, void* user_data);\
    void (*draw)(int base_element, int num_elements, int num_instances, void* user_data);\
    void (*end_pass)(void* user_data);\
    void (*commit)(void* user_data);\
    void (*alloc_buffer)(sg_buffer result, void* user_data);\
    void (*alloc_image)(sg_image result, void* user_data);\
    void (*alloc_sampler)(sg_sampler result, void* user_data);\
    void (*alloc_shader)(sg_shader result, void* user_data);\
    void (*alloc_pipeline)(sg_pipeline result, void* user_data);\
    void (*alloc_attachments)(sg_attachments result, void* user_data);\
    void (*dealloc_buffer)(sg_buffer buf_id, void* user_data);\
    void (*dealloc_image)(sg_image img_id, void* user_data);\
    void (*dealloc_sampler)(sg_sampler smp_id, void* user_data);\
    void (*dealloc_shader)(sg_shader shd_id, void* user_data);\
    void (*dealloc_pipeline)(sg_pipeline pip_id, void* user_data);\
    void (*dealloc_attachments)(sg_attachments atts_id, void* user_data);\
    void (*init_buffer)(sg_buffer buf_id, const sg_buffer_desc* desc, void* user_data);\
    void (*init_image)(sg_image img_id, const sg_image_desc* desc, void* user_data);\
    void (*init_sampler)(sg_sampler smp_id, const sg_sampler_desc* desc, void* user_data);\
    void (*init_shader)(sg_shader shd_id, const sg_shader_desc* desc, void* user_data);\
    void (*init_pipeline)(sg_pipeline pip_id, const sg_pipeline_desc* desc, void* user_data);\
    void (*init_attachments)(sg_attachments atts_id, const sg_attachments_desc* desc, void* user_data);\
    void (*uninit_buffer)(sg_buffer buf_id, void* user_data);\
    void (*uninit_image)(sg_image img_id, void* user_data);\
    void (*uninit_sampler)(sg_sampler smp_id, void* user_data);\
    void (*uninit_shader)(sg_shader shd_id, void* user_data);\
    void (*uninit_pipeline)(sg_pipeline pip_id, void* user_data);\
    void (*uninit_attachments)(sg_attachments atts_id, void* user_data);\
    void (*fail_buffer)(sg_buffer buf_id, void* user_data);\
    void (*fail_image)(sg_image img_id, void* user_data);\
    void (*fail_sampler)(sg_sampler smp_id, void* user_data);\
    void (*fail_shader)(sg_shader shd_id, void* user_data);\
    void (*fail_pipeline)(sg_pipeline pip_id, void* user_data);\
    void (*fail_attachments)(sg_attachments atts_id, void* user_data);\
    void (*push_debug_group)(const char* name, void* user_data);\
    void (*pop_debug_group)(void* user_data);\
} sg_trace_hooks;\
\
/*\
    sg_buffer_info\
    sg_image_info\
    sg_sampler_info\
    sg_shader_info\
    sg_pipeline_info\
    sg_attachments_info\
\
    These structs contain various internal resource attributes which\
    might be useful for debug-inspection. Please don't rely on the\
    actual content of those structs too much, as they are quite closely\
    tied to sokol_gfx.h internals and may change more frequently than\
    the other public API elements.\
\
    The *_info structs are used as the return values of the following functions:\
\
    sg_query_buffer_info()\
    sg_query_image_info()\
    sg_query_sampler_info()\
    sg_query_shader_info()\
    sg_query_pipeline_info()\
    sg_query_pass_info()\
*/\
typedef struct sg_slot_info {\
    sg_resource_state state;    // the current state of this resource slot\
    uint32_t res_id;            // type-neutral resource if (e.g. sg_buffer.id)\
} sg_slot_info;\
\
typedef struct sg_buffer_info {\
    sg_slot_info slot;              // resource pool slot info\
    uint32_t update_frame_index;    // frame index of last sg_update_buffer()\
    uint32_t append_frame_index;    // frame index of last sg_append_buffer()\
    int append_pos;                 // current position in buffer for sg_append_buffer()\
    bool append_overflow;           // is buffer in overflow state (due to sg_append_buffer)\
    int num_slots;                  // number of renaming-slots for dynamically updated buffers\
    int active_slot;                // currently active write-slot for dynamically updated buffers\
} sg_buffer_info;\
\
typedef struct sg_image_info {\
    sg_slot_info slot;              // resource pool slot info\
    uint32_t upd_frame_index;       // frame index of last sg_update_image()\
    int num_slots;                  // number of renaming-slots for dynamically updated images\
    int active_slot;                // currently active write-slot for dynamically updated images\
} sg_image_info;\
\
typedef struct sg_sampler_info {\
    sg_slot_info slot;              // resource pool slot info\
} sg_sampler_info;\
\
typedef struct sg_shader_info {\
    sg_slot_info slot;              // resource pool slot info\
} sg_shader_info;\
\
typedef struct sg_pipeline_info {\
    sg_slot_info slot;              // resource pool slot info\
} sg_pipeline_info;\
\
typedef struct sg_attachments_info {\
    sg_slot_info slot;              // resource pool slot info\
} sg_attachments_info;\
\
/*\
    sg_frame_stats\
\
    Allows to track generic and backend-specific stats about a\
    render frame. Obtained by calling sg_query_frame_stats(). The returned\
    struct contains information about the *previous* frame.\
*/\
typedef struct sg_frame_stats_gl {\
    uint32_t num_bind_buffer;\
    uint32_t num_active_texture;\
    uint32_t num_bind_texture;\
    uint32_t num_bind_sampler;\
    uint32_t num_use_program;\
    uint32_t num_render_state;\
    uint32_t num_vertex_attrib_pointer;\
    uint32_t num_vertex_attrib_divisor;\
    uint32_t num_enable_vertex_attrib_array;\
    uint32_t num_disable_vertex_attrib_array;\
    uint32_t num_uniform;\
} sg_frame_stats_gl;\
\
typedef struct sg_frame_stats_d3d11_pass {\
    uint32_t num_om_set_render_targets;\
    uint32_t num_clear_render_target_view;\
    uint32_t num_clear_depth_stencil_view;\
    uint32_t num_resolve_subresource;\
} sg_frame_stats_d3d11_pass;\
\
typedef struct sg_frame_stats_d3d11_pipeline {\
    uint32_t num_rs_set_state;\
    uint32_t num_om_set_depth_stencil_state;\
    uint32_t num_om_set_blend_state;\
    uint32_t num_ia_set_primitive_topology;\
    uint32_t num_ia_set_input_layout;\
    uint32_t num_vs_set_shader;\
    uint32_t num_vs_set_constant_buffers;\
    uint32_t num_ps_set_shader;\
    uint32_t num_ps_set_constant_buffers;\
} sg_frame_stats_d3d11_pipeline;\
\
typedef struct sg_frame_stats_d3d11_bindings {\
    uint32_t num_ia_set_vertex_buffers;\
    uint32_t num_ia_set_index_buffer;\
    uint32_t num_vs_set_shader_resources;\
    uint32_t num_ps_set_shader_resources;\
    uint32_t num_vs_set_samplers;\
    uint32_t num_ps_set_samplers;\
} sg_frame_stats_d3d11_bindings;\
\
typedef struct sg_frame_stats_d3d11_uniforms {\
    uint32_t num_update_subresource;\
} sg_frame_stats_d3d11_uniforms;\
\
typedef struct sg_frame_stats_d3d11_draw {\
    uint32_t num_draw_indexed_instanced;\
    uint32_t num_draw_indexed;\
    uint32_t num_draw_instanced;\
    uint32_t num_draw;\
} sg_frame_stats_d3d11_draw;\
\
typedef struct sg_frame_stats_d3d11 {\
    sg_frame_stats_d3d11_pass pass;\
    sg_frame_stats_d3d11_pipeline pipeline;\
    sg_frame_stats_d3d11_bindings bindings;\
    sg_frame_stats_d3d11_uniforms uniforms;\
    sg_frame_stats_d3d11_draw draw;\
    uint32_t num_map;\
    uint32_t num_unmap;\
} sg_frame_stats_d3d11;\
\
typedef struct sg_frame_stats_metal_idpool {\
    uint32_t num_added;\
    uint32_t num_released;\
    uint32_t num_garbage_collected;\
} sg_frame_stats_metal_idpool;\
\
typedef struct sg_frame_stats_metal_pipeline {\
    uint32_t num_set_blend_color;\
    uint32_t num_set_cull_mode;\
    uint32_t num_set_front_facing_winding;\
    uint32_t num_set_stencil_reference_value;\
    uint32_t num_set_depth_bias;\
    uint32_t num_set_render_pipeline_state;\
    uint32_t num_set_depth_stencil_state;\
} sg_frame_stats_metal_pipeline;\
\
typedef struct sg_frame_stats_metal_bindings {\
    uint32_t num_set_vertex_buffer;\
    uint32_t num_set_vertex_texture;\
    uint32_t num_set_vertex_sampler_state;\
    uint32_t num_set_fragment_buffer;\
    uint32_t num_set_fragment_texture;\
    uint32_t num_set_fragment_sampler_state;\
} sg_frame_stats_metal_bindings;\
\
typedef struct sg_frame_stats_metal_uniforms {\
    uint32_t num_set_vertex_buffer_offset;\
    uint32_t num_set_fragment_buffer_offset;\
} sg_frame_stats_metal_uniforms;\
\
typedef struct sg_frame_stats_metal {\
    sg_frame_stats_metal_idpool idpool;\
    sg_frame_stats_metal_pipeline pipeline;\
    sg_frame_stats_metal_bindings bindings;\
    sg_frame_stats_metal_uniforms uniforms;\
} sg_frame_stats_metal;\
\
typedef struct sg_frame_stats_wgpu_uniforms {\
    uint32_t num_set_bindgroup;\
    uint32_t size_write_buffer;\
} sg_frame_stats_wgpu_uniforms;\
\
typedef struct sg_frame_stats_wgpu_bindings {\
    uint32_t num_set_vertex_buffer;\
    uint32_t num_skip_redundant_vertex_buffer;\
    uint32_t num_set_index_buffer;\
    uint32_t num_skip_redundant_index_buffer;\
    uint32_t num_create_bindgroup;\
    uint32_t num_discard_bindgroup;\
    uint32_t num_set_bindgroup;\
    uint32_t num_skip_redundant_bindgroup;\
    uint32_t num_bindgroup_cache_hits;\
    uint32_t num_bindgroup_cache_misses;\
    uint32_t num_bindgroup_cache_collisions;\
    uint32_t num_bindgroup_cache_invalidates;\
    uint32_t num_bindgroup_cache_hash_vs_key_mismatch;\
} sg_frame_stats_wgpu_bindings;\
\
typedef struct sg_frame_stats_wgpu {\
    sg_frame_stats_wgpu_uniforms uniforms;\
    sg_frame_stats_wgpu_bindings bindings;\
} sg_frame_stats_wgpu;\
\
typedef struct sg_frame_stats {\
    uint32_t frame_index;   // current frame counter, starts at 0\
\
    uint32_t num_passes;\
    uint32_t num_apply_viewport;\
    uint32_t num_apply_scissor_rect;\
    uint32_t num_apply_pipeline;\
    uint32_t num_apply_bindings;\
    uint32_t num_apply_uniforms;\
    uint32_t num_draw;\
    uint32_t num_update_buffer;\
    uint32_t num_append_buffer;\
    uint32_t num_update_image;\
\
    uint32_t size_apply_uniforms;\
    uint32_t size_update_buffer;\
    uint32_t size_append_buffer;\
    uint32_t size_update_image;\
\
    sg_frame_stats_gl gl;\
    sg_frame_stats_d3d11 d3d11;\
    sg_frame_stats_metal metal;\
    sg_frame_stats_wgpu wgpu;\
} sg_frame_stats;\
\
/*\
    sg_desc\
\
    The sg_desc struct contains configuration values for sokol_gfx,\
    it is used as parameter to the sg_setup() call.\
\
    The default configuration is:\
\
    .buffer_pool_size       128\
    .image_pool_size        128\
    .sampler_pool_size      64\
    .shader_pool_size       32\
    .pipeline_pool_size     64\
    .pass_pool_size         16\
    .uniform_buffer_size    4 MB (4*1024*1024)\
    .max_commit_listeners   1024\
    .disable_validation     false\
    .mtl_force_managed_storage_mode false\
    .wgpu_disable_bindgroups_cache  false\
    .wgpu_bindgroups_cache_size     1024\
\
    .allocator.alloc_fn     0 (in this case, malloc() will be called)\
    .allocator.free_fn      0 (in this case, free() will be called)\
    .allocator.user_data    0\
\
    .environment.defaults.color_format: default value depends on selected backend:\
        all GL backends:    SG_PIXELFORMAT_RGBA8\
        Metal and D3D11:    SG_PIXELFORMAT_BGRA8\
        WebGPU:             *no default* (must be queried from WebGPU swapchain object)\
    .environment.defaults.depth_format: SG_PIXELFORMAT_DEPTH_STENCIL\
    .environment.defaults.sample_count: 1\
\
    Metal specific:\
        (NOTE: All Objective-C object references are transferred through\
        a bridged (const void*) to sokol_gfx, which will use a unretained\
        bridged cast (__bridged id<xxx>) to retrieve the Objective-C\
        references back. Since the bridge cast is unretained, the caller\
        must hold a strong reference to the Objective-C object for the\
        duration of the sokol_gfx call!\
\
        .mtl_force_managed_storage_mode\
            when enabled, Metal buffers and texture resources are created in managed storage\
            mode, otherwise sokol-gfx will decide whether to create buffers and\
            textures in managed or shared storage mode (this is mainly a debugging option)\
        .mtl_use_command_buffer_with_retained_references\
            when true, the sokol-gfx Metal backend will use Metal command buffers which\
            bump the reference count of resource objects as long as they are inflight,\
            this is slower than the default command-buffer-with-unretained-references\
            method, this may be a workaround when confronted with lifetime validation\
            errors from the Metal validation layer until a proper fix has been implemented\
        .environment.metal.device\
            a pointer to the MTLDevice object\
\
    D3D11 specific:\
        .environment.d3d11.device\
            a pointer to the ID3D11Device object, this must have been created\
            before sg_setup() is called\
        .environment.d3d11.device_context\
            a pointer to the ID3D11DeviceContext object\
        .d3d11_shader_debugging\
            set this to true to compile shaders which are provided as HLSL source\
            code with debug information and without optimization, this allows\
            shader debugging in tools like RenderDoc, to output source code\
            instead of byte code from sokol-shdc, omit the `--binary` cmdline\
            option\
\
    WebGPU specific:\
        .wgpu_disable_bindgroups_cache\
            When this is true, the WebGPU backend will create and immediately\
            release a BindGroup object in the sg_apply_bindings() call, only\
            use this for debugging purposes.\
        .wgpu_bindgroups_cache_size\
            The size of the bindgroups cache for re-using BindGroup objects\
            between sg_apply_bindings() calls. The smaller the cache size,\
            the more likely are cache slot collisions which will cause\
            a BindGroups object to be destroyed and a new one created.\
            Use the information returned by sg_query_stats() to check\
            if this is a frequent occurrence, and increase the cache size as\
            needed (the default is 1024).\
            NOTE: wgpu_bindgroups_cache_size must be a power-of-2 number!\
        .environment.wgpu.device\
            a WGPUDevice handle\
\
    When using sokol_gfx.h and sokol_app.h together, consider using the\
    helper function sglue_environment() in the sokol_glue.h header to\
    initialize the sg_desc.environment nested struct. sglue_environment() returns\
    a completely initialized sg_environment struct with information\
    provided by sokol_app.h.\
*/\
typedef struct sg_environment_defaults {\
   sg_pixel_format color_format;\
   sg_pixel_format depth_format;\
   int sample_count;\
} sg_environment_defaults;\
\
typedef struct sg_metal_environment {\
   const void* device;\
} sg_metal_environment;\
\
typedef struct sg_d3d11_environment {\
   const void* device;\
   const void* device_context;\
} sg_d3d11_environment;\
\
typedef struct sg_wgpu_environment {\
   const void* device;\
} sg_wgpu_environment;\
\
typedef struct sg_environment {\
   sg_environment_defaults defaults;\
   sg_metal_environment metal;\
   sg_d3d11_environment d3d11;\
   sg_wgpu_environment wgpu;\
} sg_environment;\
\
/*\
   sg_commit_listener\
\
   Used with function sg_add_commit_listener() to add a callback\
   which will be called in sg_commit(). This is useful for libraries\
   building on top of sokol-gfx to be notified about when a frame\
   ends (instead of having to guess, or add a manual 'new-frame'\
   function.\
*/\
typedef struct sg_commit_listener {\
   void (*func)(void* user_data);\
   void* user_data;\
} sg_commit_listener;\
\
/*\
   sg_allocator\
\
   Used in sg_desc to provide custom memory-alloc and -free functions\
   to sokol_gfx.h. If memory management should be overridden, both the\
   alloc_fn and free_fn function must be provided (e.g. it's not valid to\
   override one function but not the other).\
*/\
typedef struct sg_allocator {\
   void* (*alloc_fn)(size_t size, void* user_data);\
   void (*free_fn)(void* ptr, void* user_data);\
   void* user_data;\
} sg_allocator;\
\
/*\
   sg_logger\
\
   Used in sg_desc to provide a logging function. Please be aware\
   that without logging function, sokol-gfx will be completely\
   silent, e.g. it will not report errors, warnings and\
   validation layer messages. For maximum error verbosity,\
   compile in debug mode (e.g. NDEBUG *not* defined) and provide a\
   compatible logger function in the sg_setup() call\
   (for instance the standard logging function from sokol_log.h).\
*/\
typedef struct sg_logger {\
   void (*func)(\
       const char* tag,                // always \"sg\"\
       uint32_t log_level,             // 0=panic, 1=error, 2=warning, 3=info\
       uint32_t log_item_id,           // SG_LOGITEM_*\
       const char* message_or_null,    // a message string, may be nullptr in release mode\
       uint32_t line_nr,               // line number in sokol_gfx.h\
       const char* filename_or_null,   // source filename, may be nullptr in release mode\
       void* user_data);\
   void* user_data;\
} sg_logger;\
\
typedef struct sg_desc {\
   uint32_t _start_canary;\
   int buffer_pool_size;\
   int image_pool_size;\
   int sampler_pool_size;\
   int shader_pool_size;\
   int pipeline_pool_size;\
   int attachments_pool_size;\
   int uniform_buffer_size;\
   int max_commit_listeners;\
   bool disable_validation;    // disable validation layer even in debug mode, useful for tests\
   bool d3d11_shader_debugging;    // if true, HLSL shaders are compiled with D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION\
   bool mtl_force_managed_storage_mode; // for debugging: use Metal managed storage mode for resources even with UMA\
   bool mtl_use_command_buffer_with_retained_references;    // Metal: use a managed MTLCommandBuffer which ref-counts used resources\
   bool wgpu_disable_bindgroups_cache;  // set to true to disable the WebGPU backend BindGroup cache\
   int wgpu_bindgroups_cache_size;      // number of slots in the WebGPU bindgroup cache (must be 2^N)\
   sg_allocator allocator;\
   sg_logger logger; // optional log function override\
   sg_environment environment;\
   uint32_t _end_canary;\
} sg_desc;\
\
// setup and misc functions\
void sg_setup(const sg_desc* desc);\
void sg_shutdown(void);\
bool sg_isvalid(void);\
void sg_reset_state_cache(void);\
sg_trace_hooks sg_install_trace_hooks(const sg_trace_hooks* trace_hooks);\
void sg_push_debug_group(const char* name);\
void sg_pop_debug_group(void);\
bool sg_add_commit_listener(sg_commit_listener listener);\
bool sg_remove_commit_listener(sg_commit_listener listener);\
\
// resource creation, destruction and updating\
sg_buffer sg_make_buffer(const sg_buffer_desc* desc);\
sg_image sg_make_image(const sg_image_desc* desc);\
sg_sampler sg_make_sampler(const sg_sampler_desc* desc);\
sg_shader sg_make_shader(const sg_shader_desc* desc);\
sg_pipeline sg_make_pipeline(const sg_pipeline_desc* desc);\
sg_attachments sg_make_attachments(const sg_attachments_desc* desc);\
void sg_destroy_buffer(sg_buffer buf);\
void sg_destroy_image(sg_image img);\
void sg_destroy_sampler(sg_sampler smp);\
void sg_destroy_shader(sg_shader shd);\
void sg_destroy_pipeline(sg_pipeline pip);\
void sg_destroy_attachments(sg_attachments atts);\
void sg_update_buffer(sg_buffer buf, const sg_range* data);\
void sg_update_image(sg_image img, const sg_image_data* data);\
int sg_append_buffer(sg_buffer buf, const sg_range* data);\
bool sg_query_buffer_overflow(sg_buffer buf);\
bool sg_query_buffer_will_overflow(sg_buffer buf, size_t size);\
\
// rendering functions\
void sg_begin_pass(const sg_pass* pass);\
void sg_apply_viewport(int x, int y, int width, int height, bool origin_top_left);\
void sg_apply_viewportf(float x, float y, float width, float height, bool origin_top_left);\
void sg_apply_scissor_rect(int x, int y, int width, int height, bool origin_top_left);\
void sg_apply_scissor_rectf(float x, float y, float width, float height, bool origin_top_left);\
void sg_apply_pipeline(sg_pipeline pip);\
void sg_apply_bindings(const sg_bindings* bindings);\
void sg_apply_uniforms(sg_shader_stage stage, int ub_index, const sg_range* data);\
void sg_draw(int base_element, int num_elements, int num_instances);\
void sg_end_pass(void);\
void sg_commit(void);\
\
// getting information\
sg_desc sg_query_desc(void);\
sg_backend sg_query_backend(void);\
sg_features sg_query_features(void);\
sg_limits sg_query_limits(void);\
sg_pixelformat_info sg_query_pixelformat(sg_pixel_format fmt);\
int sg_query_row_pitch(sg_pixel_format fmt, int width, int row_align_bytes);\
int sg_query_surface_pitch(sg_pixel_format fmt, int width, int height, int row_align_bytes);\
// get current state of a resource (INITIAL, ALLOC, VALID, FAILED, INVALID)\
sg_resource_state sg_query_buffer_state(sg_buffer buf);\
sg_resource_state sg_query_image_state(sg_image img);\
sg_resource_state sg_query_sampler_state(sg_sampler smp);\
sg_resource_state sg_query_shader_state(sg_shader shd);\
sg_resource_state sg_query_pipeline_state(sg_pipeline pip);\
sg_resource_state sg_query_attachments_state(sg_attachments atts);\
// get runtime information about a resource\
sg_buffer_info sg_query_buffer_info(sg_buffer buf);\
sg_image_info sg_query_image_info(sg_image img);\
sg_sampler_info sg_query_sampler_info(sg_sampler smp);\
sg_shader_info sg_query_shader_info(sg_shader shd);\
sg_pipeline_info sg_query_pipeline_info(sg_pipeline pip);\
sg_attachments_info sg_query_attachments_info(sg_attachments atts);\
// get desc structs matching a specific resource (NOTE that not all creation attributes may be provided)\
sg_buffer_desc sg_query_buffer_desc(sg_buffer buf);\
sg_image_desc sg_query_image_desc(sg_image img);\
sg_sampler_desc sg_query_sampler_desc(sg_sampler smp);\
sg_shader_desc sg_query_shader_desc(sg_shader shd);\
sg_pipeline_desc sg_query_pipeline_desc(sg_pipeline pip);\
sg_attachments_desc sg_query_attachments_desc(sg_attachments atts);\
// get resource creation desc struct with their default values replaced\
sg_buffer_desc sg_query_buffer_defaults(const sg_buffer_desc* desc);\
sg_image_desc sg_query_image_defaults(const sg_image_desc* desc);\
sg_sampler_desc sg_query_sampler_defaults(const sg_sampler_desc* desc);\
sg_shader_desc sg_query_shader_defaults(const sg_shader_desc* desc);\
sg_pipeline_desc sg_query_pipeline_defaults(const sg_pipeline_desc* desc);\
sg_attachments_desc sg_query_attachments_defaults(const sg_attachments_desc* desc);\
\
// separate resource allocation and initialization (for async setup)\
sg_buffer sg_alloc_buffer(void);\
sg_image sg_alloc_image(void);\
sg_sampler sg_alloc_sampler(void);\
sg_shader sg_alloc_shader(void);\
sg_pipeline sg_alloc_pipeline(void);\
sg_attachments sg_alloc_attachments(void);\
void sg_dealloc_buffer(sg_buffer buf);\
void sg_dealloc_image(sg_image img);\
void sg_dealloc_sampler(sg_sampler smp);\
void sg_dealloc_shader(sg_shader shd);\
void sg_dealloc_pipeline(sg_pipeline pip);\
void sg_dealloc_attachments(sg_attachments attachments);\
void sg_init_buffer(sg_buffer buf, const sg_buffer_desc* desc);\
void sg_init_image(sg_image img, const sg_image_desc* desc);\
void sg_init_sampler(sg_sampler smg, const sg_sampler_desc* desc);\
void sg_init_shader(sg_shader shd, const sg_shader_desc* desc);\
void sg_init_pipeline(sg_pipeline pip, const sg_pipeline_desc* desc);\
void sg_init_attachments(sg_attachments attachments, const sg_attachments_desc* desc);\
void sg_uninit_buffer(sg_buffer buf);\
void sg_uninit_image(sg_image img);\
void sg_uninit_sampler(sg_sampler smp);\
void sg_uninit_shader(sg_shader shd);\
void sg_uninit_pipeline(sg_pipeline pip);\
void sg_uninit_attachments(sg_attachments atts);\
void sg_fail_buffer(sg_buffer buf);\
void sg_fail_image(sg_image img);\
void sg_fail_sampler(sg_sampler smp);\
void sg_fail_shader(sg_shader shd);\
void sg_fail_pipeline(sg_pipeline pip);\
void sg_fail_attachments(sg_attachments atts);\
\
// frame stats\
void sg_enable_frame_stats(void);\
void sg_disable_frame_stats(void);\
bool sg_frame_stats_enabled(void);\
sg_frame_stats sg_query_frame_stats(void);\
\
\9cdef\9load\9arch\7os\
Other\1\0\1\8x64\0\
POSIX\1\0\1\8x64\0\8BSD\1\0\1\8x64\0\
Linux\8arm\1\0\2\8arm\0\8x64\0\12Windows\1\0\1\8x64\0\9.dll\8OSX\1\0\6\8BSD\0\12Windows\0\
Linux\0\8OSX\0\
Other\0\
POSIX\0\8x64\1\0\1\8x64\0\8.so\18ffi_sokol_gfx\14sokol_dll\14SOKOL_DLL\7_G\8ffi\12require\1\0\1\0\1\0\3\0\3\0\3\0\3\0\3\0\4\0\4\0\4\0\4\0\5\0\5\0\5\0\5\0\5\0\5\0\6\0\6\0\6\0\6\0\6\0\6\0\7\0\7\0\7\0\7\0\7\0\7\0\7\0\7\0\7\0\7\0\8\0\8\0\8\0\8\0\8\0\8\0\9\0\9\0\9\0\9\0\9\0\9\0\
\0\
\0\
\0\
\0\
\0\
\0\13\0\13\0\13\0\13\0\13\0\13\0\13\0\14\0\14\0\14\0\16\0√\8√\8≈\8ffi\0\4?sokol_filename\0\5:libs\0,\14lib\0\7\7sokol_gfx\0\3\4\0\0");t['F:.devjit.Thunc.sokol-luajit.ffi.sokol.sokol_libs']=load("\27LJ\2\0081F:.devjit.Thunc.sokol-luajit.ffi.sokol.sokol_libs˚d\2\0\8\0\28\0B∂\1\0§\0026\0\0\0'\2\1\0B\0\2\0026\1\2\0009\1\3\1\14\0\1\0X\2\1Ä'\1\4\0006\2\5\0\14\0\2\0X\3)Ä5\2\9\0005\3\7\0\18\4\1\0'\5\6\0&\4\5\4=\4\8\3=\3\
\0025\3\12\0\18\4\1\0'\5\11\0&\4\5\4=\4\8\3=\3\13\0025\3\14\0\18\4\1\0'\5\6\0&\4\5\4=\4\8\3\18\4\1\0'\5\6\0&\4\5\4=\4\15\3=\3\16\0025\3\17\0\18\4\1\0'\5\6\0&\4\5\4=\4\8\3=\3\18\0025\3\19\0\18\4\1\0'\5\6\0&\4\5\4=\4\8\3=\3\20\0025\3\21\0\18\4\1\0'\5\6\0&\4\5\4=\4\8\3=\3\22\0026\3\5\0\14\0\3\0X\4\4Ä9\3\23\0008\3\3\0029\4\24\0008\3\4\0039\4\25\0\18\6\3\0B\4\2\0029\5\26\0'\7\27\0B\5\2\1L\4\2\0›_\
/********** sokol_args ****************************************************************/\
\
/*\
    sargs_allocator\
\
    Used in sargs_desc to provide custom memory-alloc and -free functions\
    to sokol_args.h. If memory management should be overridden, both the\
    alloc_fn and free_fn function must be provided (e.g. it's not valid to\
    override one function but not the other).\
*/\
typedef struct sargs_allocator {\
   void* (*alloc_fn)(size_t size, void* user_data);\
   void (*free_fn)(void* ptr, void* user_data);\
   void* user_data;\
} sargs_allocator;\
\
typedef struct sargs_desc {\
   int argc;\
   char** argv;\
   int max_args;\
   int buf_size;\
   sargs_allocator allocator;\
} sargs_desc;\
\
/* setup sokol-args */\
void sargs_setup(const sargs_desc* desc);\
/* shutdown sokol-args */\
void sargs_shutdown(void);\
/* true between sargs_setup() and sargs_shutdown() */\
bool sargs_isvalid(void);\
/* test if an argument exists by key name */\
bool sargs_exists(const char* key);\
/* get value by key name, return empty string if key doesn't exist or an existing key has no value */\
const char* sargs_value(const char* key);\
/* get value by key name, return provided default if key doesn't exist or has no value */\
const char* sargs_value_def(const char* key, const char* def);\
/* return true if val arg matches the value associated with key */\
bool sargs_equals(const char* key, const char* val);\
/* return true if key's value is \"true\", \"yes\", \"on\" or an existing key has no value */\
bool sargs_boolean(const char* key);\
/* get index of arg by key name, return -1 if not exists */\
int sargs_find(const char* key);\
/* get number of parsed arguments */\
int sargs_num_args(void);\
/* get key name of argument at index, or empty string */\
const char* sargs_key_at(int index);\
/* get value string of argument at index, or empty string */\
const char* sargs_value_at(int index);\
\
/********** sokol_audio ****************************************************************/\
\
/*\
    saudio_logger\
\
    Used in saudio_desc to provide a custom logging and error reporting\
    callback to sokol-audio.\
*/\
typedef struct saudio_logger {\
   void (*func)(\
       const char* tag,                // always \"saudio\"\
       uint32_t log_level,             // 0=panic, 1=error, 2=warning, 3=info\
       uint32_t log_item_id,           // SAUDIO_LOGITEM_*\
       const char* message_or_null,    // a message string, may be nullptr in release mode\
       uint32_t line_nr,               // line number in sokol_audio.h\
       const char* filename_or_null,   // source filename, may be nullptr in release mode\
       void* user_data);\
   void* user_data;\
} saudio_logger;\
\
/*\
   saudio_allocator\
\
   Used in saudio_desc to provide custom memory-alloc and -free functions\
   to sokol_audio.h. If memory management should be overridden, both the\
   alloc_fn and free_fn function must be provided (e.g. it's not valid to\
   override one function but not the other).\
*/\
typedef struct saudio_allocator {\
   void* (*alloc_fn)(size_t size, void* user_data);\
   void (*free_fn)(void* ptr, void* user_data);\
   void* user_data;\
} saudio_allocator;\
\
typedef struct saudio_desc {\
   int sample_rate;        // requested sample rate\
   int num_channels;       // number of channels, default: 1 (mono)\
   int buffer_frames;      // number of frames in streaming buffer\
   int packet_frames;      // number of frames in a packet\
   int num_packets;        // number of packets in packet queue\
   void (*stream_cb)(float* buffer, int num_frames, int num_channels);  // optional streaming callback (no user data)\
   void (*stream_userdata_cb)(float* buffer, int num_frames, int num_channels, void* user_data); //... and with user data\
   void* user_data;        // optional user data argument for stream_userdata_cb\
   saudio_allocator allocator;     // optional allocation override functions\
   saudio_logger logger;           // optional logging function (default: NO LOGGING!)\
} saudio_desc;\
\
/* setup sokol-audio */\
void saudio_setup(const saudio_desc* desc);\
/* shutdown sokol-audio */\
void saudio_shutdown(void);\
/* true after setup if audio backend was successfully initialized */\
bool saudio_isvalid(void);\
/* return the saudio_desc.user_data pointer */\
void* saudio_userdata(void);\
/* return a copy of the original saudio_desc struct */\
saudio_desc saudio_query_desc(void);\
/* actual sample rate */\
int saudio_sample_rate(void);\
/* return actual backend buffer size in number of frames */\
int saudio_buffer_frames(void);\
/* actual number of channels */\
int saudio_channels(void);\
/* return true if audio context is currently suspended (only in WebAudio backend, all other backends return false) */\
bool saudio_suspended(void);\
/* get current number of frames to fill packet queue */\
int saudio_expect(void);\
/* push sample frames from main thread, returns number of frames actually pushed */\
int saudio_push(const float* frames, int num_frames);\
\
/********** sokol_fetch ****************************************************************/\
\
\
/*\
    sfetch_logger_t\
\
    Used in sfetch_desc_t to provide a custom logging and error reporting\
    callback to sokol-fetch.\
*/\
typedef struct sfetch_logger_t {\
   void (*func)(\
       const char* tag,                // always \"sfetch\"\
       uint32_t log_level,             // 0=panic, 1=error, 2=warning, 3=info\
       uint32_t log_item_id,           // SFETCH_LOGITEM_*\
       const char* message_or_null,    // a message string, may be nullptr in release mode\
       uint32_t line_nr,               // line number in sokol_fetch.h\
       const char* filename_or_null,   // source filename, may be nullptr in release mode\
       void* user_data);\
   void* user_data;\
} sfetch_logger_t;\
\
/*\
   sfetch_range_t\
\
   A pointer-size pair struct to pass memory ranges into and out of sokol-fetch.\
   When initialized from a value type (array or struct) you can use the\
   SFETCH_RANGE() helper macro to build an sfetch_range_t struct.\
*/\
typedef struct sfetch_range_t {\
   const void* ptr;\
   size_t size;\
} sfetch_range_t;\
\
/*\
   sfetch_allocator_t\
\
   Used in sfetch_desc_t to provide custom memory-alloc and -free functions\
   to sokol_fetch.h. If memory management should be overridden, both the\
   alloc and free function must be provided (e.g. it's not valid to\
   override one function but not the other).\
*/\
typedef struct sfetch_allocator_t {\
   void* (*alloc_fn)(size_t size, void* user_data);\
   void (*free_fn)(void* ptr, void* user_data);\
   void* user_data;\
} sfetch_allocator_t;\
\
/* configuration values for sfetch_setup() */\
typedef struct sfetch_desc_t {\
   uint32_t max_requests;          // max number of active requests across all channels (default: 128)\
   uint32_t num_channels;          // number of channels to fetch requests in parallel (default: 1)\
   uint32_t num_lanes;             // max number of requests active on the same channel (default: 1)\
   sfetch_allocator_t allocator;   // optional memory allocation overrides (default: malloc/free)\
   sfetch_logger_t logger;         // optional log function overrides (default: NO LOGGING!)\
} sfetch_desc_t;\
\
/* a request handle to identify an active fetch request, returned by sfetch_send() */\
typedef struct sfetch_handle_t { uint32_t id; } sfetch_handle_t;\
\
/* error codes */\
typedef enum sfetch_error_t {\
   SFETCH_ERROR_NO_ERROR,\
   SFETCH_ERROR_FILE_NOT_FOUND,\
   SFETCH_ERROR_NO_BUFFER,\
   SFETCH_ERROR_BUFFER_TOO_SMALL,\
   SFETCH_ERROR_UNEXPECTED_EOF,\
   SFETCH_ERROR_INVALID_HTTP_STATUS,\
   SFETCH_ERROR_CANCELLED\
} sfetch_error_t;\
\
/* the response struct passed to the response callback */\
typedef struct sfetch_response_t {\
   sfetch_handle_t handle;         // request handle this response belongs to\
   bool dispatched;                // true when request is in DISPATCHED state (lane has been assigned)\
   bool fetched;                   // true when request is in FETCHED state (fetched data is available)\
   bool paused;                    // request is currently in paused state\
   bool finished;                  // this is the last response for this request\
   bool failed;                    // request has failed (always set together with 'finished')\
   bool cancelled;                 // request was cancelled (always set together with 'finished')\
   sfetch_error_t error_code;      // more detailed error code when failed is true\
   uint32_t channel;               // the channel which processes this request\
   uint32_t lane;                  // the lane this request occupies on its channel\
   const char* path;               // the original filesystem path of the request\
   void* user_data;                // pointer to read/write user-data area\
   uint32_t data_offset;           // current offset of fetched data chunk in the overall file data\
   sfetch_range_t data;            // the fetched data as ptr/size pair (data.ptr == buffer.ptr, data.size <= buffer.size)\
   sfetch_range_t buffer;          // the user-provided buffer which holds the fetched data\
} sfetch_response_t;\
\
/* request parameters passed to sfetch_send() */\
typedef struct sfetch_request_t {\
   uint32_t channel;                                // index of channel this request is assigned to (default: 0)\
   const char* path;                                // filesystem path or HTTP URL (required)\
   void (*callback) (const sfetch_response_t*);     // response callback function pointer (required)\
   uint32_t chunk_size;                             // number of bytes to load per stream-block (optional)\
   sfetch_range_t buffer;                           // a memory buffer where the data will be loaded into (optional)\
   sfetch_range_t user_data;                        // ptr/size of a POD user data block which will be memcpy'd (optional)\
} sfetch_request_t;\
\
\
/* setup sokol-fetch (can be called on multiple threads) */\
void sfetch_setup(const sfetch_desc_t* desc);\
/* discard a sokol-fetch context */\
void sfetch_shutdown(void);\
/* return true if sokol-fetch has been setup */\
bool sfetch_valid(void);\
/* get the desc struct that was passed to sfetch_setup() */\
sfetch_desc_t sfetch_desc(void);\
/* return the max userdata size in number of bytes (SFETCH_MAX_USERDATA_UINT64 * sizeof(uint64_t)) */\
int sfetch_max_userdata_bytes(void);\
/* return the value of the SFETCH_MAX_PATH implementation config value */\
int sfetch_max_path(void);\
\
/* send a fetch-request, get handle to request back */\
sfetch_handle_t sfetch_send(const sfetch_request_t* request);\
/* return true if a handle is valid *and* the request is alive */\
bool sfetch_handle_valid(sfetch_handle_t h);\
/* do per-frame work, moves requests into and out of IO threads, and invokes response-callbacks */\
void sfetch_dowork(void);\
\
/* bind a data buffer to a request (request must not currently have a buffer bound, must be called from response callback */\
void sfetch_bind_buffer(sfetch_handle_t h, sfetch_range_t buffer);\
/* clear the 'buffer binding' of a request, returns previous buffer pointer (can be 0), must be called from response callback */\
void* sfetch_unbind_buffer(sfetch_handle_t h);\
/* cancel a request that's in flight (will call response callback with .cancelled + .finished) */\
void sfetch_cancel(sfetch_handle_t h);\
/* pause a request (will call response callback each frame with .paused) */\
void sfetch_pause(sfetch_handle_t h);\
/* continue a paused request */\
void sfetch_continue(sfetch_handle_t h);\
\
/********** sokol_glue ****************************************************************/\
\
sg_environment sglue_environment(void);\
sg_swapchain sglue_swapchain(void);\
\
/********** sokol_log ****************************************************************/\
\
void slog_func(const char* tag, uint32_t log_level, uint32_t log_item, const char* message, uint32_t line_nr, const char* filename, void* user_data);\
\
/********** sokol_time ****************************************************************/\
\
void stm_setup(void);\
uint64_t stm_now(void);\
uint64_t stm_diff(uint64_t new_ticks, uint64_t old_ticks);\
uint64_t stm_since(uint64_t start_ticks);\
uint64_t stm_laptime(uint64_t* last_time);\
uint64_t stm_round_to_common_refresh_rate(uint64_t frame_ticks);\
double stm_sec(uint64_t ticks);\
double stm_ms(uint64_t ticks);\
double stm_us(uint64_t ticks);\
double stm_ns(uint64_t ticks);\
\
\9cdef\9load\9arch\7os\
Other\1\0\1\8x64\0\
POSIX\1\0\1\8x64\0\8BSD\1\0\1\8x64\0\
Linux\8arm\1\0\2\8arm\0\8x64\0\12Windows\1\0\1\8x64\0\9.dll\8OSX\1\0\6\12Windows\0\8BSD\0\
Linux\0\
Other\0\
POSIX\0\8OSX\0\8x64\1\0\1\8x64\0\8.so\19ffi_sokol_libs\14sokol_dll\14SOKOL_DLL\7_G\8ffi\12require\1\0\1\0\1\0\3\0\3\0\3\0\3\0\3\0\4\0\4\0\4\0\4\0\5\0\5\0\5\0\5\0\5\0\5\0\6\0\6\0\6\0\6\0\6\0\6\0\7\0\7\0\7\0\7\0\7\0\7\0\7\0\7\0\7\0\7\0\8\0\8\0\8\0\8\0\8\0\8\0\9\0\9\0\9\0\9\0\9\0\9\0\
\0\
\0\
\0\
\0\
\0\
\0\13\0\13\0\13\0\13\0\13\0\13\0\13\0\14\0\14\0\14\0\16\0\"\1\"\1$\1ffi\0\4?sokol_filename\0\5:libs\0,\14lib\0\7\7sokol_libs\0\3\4\0\0");t['F:.devjit.Thunc.sokol-luajit.ffi.sokol.hmm']=load("\27LJ\2\8*F:.devjit.Thunc.sokol-luajit.ffi.sokol.hmmæ9\2\0\7\0\21\0!`\0≥\0026\0\0\0'\2\1\0B\0\2\0026\1\2\0\14\0\1\0X\2\13Ä5\1\4\0005\2\3\0=\2\5\0015\2\6\0=\2\7\0015\2\8\0=\2\9\0015\2\
\0=\2\11\0015\2\12\0=\2\13\0015\2\14\0=\2\15\0016\2\2\0\14\0\2\0X\3\4Ä9\2\16\0008\2\2\0019\3\17\0008\2\3\0029\3\18\0\18\5\2\0B\3\2\0029\4\19\0'\6\20\0B\4\2\1L\3\2\0‚5\
/********** hmm_lib ****************************************************************/\
\
typedef union hmm_vec2\
{\
    struct\
    {\
        float x, y;\
    };\
\
    struct\
    {\
        float X, Y;\
    };\
\
    struct\
    {\
        float U, V;\
    };\
\
    struct\
    {\
        float Left, Right;\
    };\
    \
    struct\
    {\
        float Width, Height;\
    };\
\
    float Elements[2];\
} hmm_vec2;\
\
typedef union hmm_vec3\
{\
    struct\
    {\
        float x, y, z;\
    };\
\
    struct\
    {\
        float X, Y, Z;\
    };\
\
    struct\
    {\
        float U, V, W;\
    };\
\
    struct\
    {\
        float R, G, B;\
    };\
\
    struct\
    {\
        hmm_vec2 XY;\
        float Ignored0_;\
    };\
\
    struct\
    {\
        float Ignored1_;\
        hmm_vec2 YZ;\
    };\
\
    struct\
    {\
        hmm_vec2 UV;\
        float Ignored2_;\
    };\
\
    struct\
    {\
        float Ignored3_;\
        hmm_vec2 VW;\
    };\
\
    float Elements[3];\
} hmm_vec3;\
\
typedef union hmm_vec4\
{\
    struct\
    {\
        union\
        {\
            hmm_vec3 XYZ;\
            struct\
            {\
                float X, Y, Z;\
            };\
            struct\
            {\
                float x, y, z;\
            };        \
        };\
\
        float W;\
    };\
    struct\
    {\
        union\
        {\
            hmm_vec3 RGB;\
            struct\
            {\
                float R, G, B;\
            };\
            struct\
            {\
                float x, y, z;\
            };        \
        };\
\
        float A;\
    };\
\
    struct\
    {\
        hmm_vec2 XY;\
        float Ignored0_;\
        float Ignored1_;\
    };\
\
    struct\
    {\
        float Ignored2_;\
        hmm_vec2 YZ;\
        float Ignored3_;\
    };\
\
    struct\
    {\
        float Ignored4_;\
        float Ignored5_;\
        hmm_vec2 ZW;\
    };\
\
    float Elements[4];\
} hmm_vec4;\
\
typedef union hmm_mat4\
{\
    float Elements[4][4];\
\
} hmm_mat4;\
\
typedef union hmm_quaternion\
{\
    struct\
    {\
        union\
        {\
            hmm_vec3 XYZ;\
            struct\
            {\
                float X, Y, Z;\
            };\
            struct\
            {\
                float x, y, z;\
            };        \
        };\
        \
        union\
        {\
            float W;\
            float w;\
        };\
    };\
    \
    float Elements[4];\
} hmm_quaternion;\
\
typedef int32_t hmm_bool;\
\
typedef hmm_vec2 hmm_v2;\
typedef hmm_vec3 hmm_v3;\
typedef hmm_vec4 hmm_v4;\
typedef hmm_mat4 hmm_m4;    \
\
float HMM_SinF(float Angle);\
float HMM_TanF(float Angle);\
float HMM_ATanF(float Theta);\
float HMM_ATan2F(float Theta, float Theta2);\
float HMM_CosF(float Angle);\
float HMM_ACosF(float Theta);\
float HMM_ExpF(float Float);\
float HMM_LogF(float Float);\
\
float HMM_ToRadians(float Degrees);\
float HMM_SquareRootF(float Float);\
float HMM_RSquareRootF(float Float);\
\
float HMM_LengthSquaredVec2(hmm_vec2 A);\
float HMM_LengthSquaredVec3(hmm_vec3 A);\
float HMM_LengthSquaredVec4(hmm_vec4 A);\
\
float HMM_LengthVec2(hmm_vec2 A);    \
float HMM_LengthVec3(hmm_vec3 A);    \
float HMM_LengthVec4(hmm_vec4 A);    \
\
float HMM_Power(float Base, int Exponent);\
float HMM_PowerF(float Base, float Exponent);\
float HMM_Lerp(float A, float Time, float B);\
float HMM_Clamp(float Min, float Value, float Max);\
\
hmm_vec2 HMM_NormalizeVec2(hmm_vec2 A);\
hmm_vec3 HMM_NormalizeVec3(hmm_vec3 A);\
hmm_vec4 HMM_NormalizeVec4(hmm_vec4 A);\
\
float HMM_DotVec2(hmm_vec2 VecOne, hmm_vec2 VecTwo);\
float HMM_DotVec3(hmm_vec3 VecOne, hmm_vec3 VecTwo);\
float HMM_DotVec4(hmm_vec4 VecOne, hmm_vec4 VecTwo);\
\
hmm_vec3 HMM_Cross(hmm_vec3 VecOne, hmm_vec3 VecTwo);\
\
hmm_vec2 HMM_Vec2(float X, float Y);\
hmm_vec2 HMM_Vec2i(int X, int Y);\
hmm_vec3 HMM_Vec3(float X, float Y, float Z);\
hmm_vec3 HMM_Vec3i(int X, int Y, int Z);\
hmm_vec4 HMM_Vec4(float X, float Y, float Z, float W);\
hmm_vec4 HMM_Vec4i(int X, int Y, int Z, int W);\
hmm_vec4 HMM_Vec4v(hmm_vec3 Vector, float W);\
\
hmm_vec2 HMM_AddVec2(hmm_vec2 Left, hmm_vec2 Right);\
hmm_vec3 HMM_AddVec3(hmm_vec3 Left, hmm_vec3 Right);\
hmm_vec4 HMM_AddVec4(hmm_vec4 Left, hmm_vec4 Right);\
\
hmm_vec2 HMM_SubtractVec2(hmm_vec2 Left, hmm_vec2 Right);\
hmm_vec3 HMM_SubtractVec3(hmm_vec3 Left, hmm_vec3 Right);\
hmm_vec4 HMM_SubtractVec4(hmm_vec4 Left, hmm_vec4 Right);\
\
hmm_vec2 HMM_MultiplyVec2(hmm_vec2 Left, hmm_vec2 Right);\
hmm_vec2 HMM_MultiplyVec2f(hmm_vec2 Left, float Right);\
hmm_vec3 HMM_MultiplyVec3(hmm_vec3 Left, hmm_vec3 Right);\
hmm_vec3 HMM_MultiplyVec3f(hmm_vec3 Left, float Right);\
hmm_vec4 HMM_MultiplyVec4(hmm_vec4 Left, hmm_vec4 Right);\
hmm_vec4 HMM_MultiplyVec4f(hmm_vec4 Left, float Right);\
\
hmm_vec2 HMM_DivideVec2(hmm_vec2 Left, hmm_vec2 Right);\
hmm_vec2 HMM_DivideVec2f(hmm_vec2 Left, float Right);\
hmm_vec3 HMM_DivideVec3(hmm_vec3 Left, hmm_vec3 Right);\
hmm_vec3 HMM_DivideVec3f(hmm_vec3 Left, float Right);\
hmm_vec4 HMM_DivideVec4(hmm_vec4 Left, hmm_vec4 Right);\
hmm_vec4 HMM_DivideVec4f(hmm_vec4 Left, float Right);\
\
hmm_bool HMM_EqualsVec2(hmm_vec2 Left, hmm_vec2 Right);\
hmm_bool HMM_EqualsVec3(hmm_vec3 Left, hmm_vec3 Right);\
hmm_bool HMM_EqualsVec4(hmm_vec4 Left, hmm_vec4 Right);\
\
hmm_mat4 HMM_Mat4(void);\
hmm_mat4 HMM_Mat4d(float Diagonal);\
hmm_mat4 HMM_AddMat4(hmm_mat4 Left, hmm_mat4 Right);\
hmm_mat4 HMM_SubtractMat4(hmm_mat4 Left, hmm_mat4 Right);\
\
hmm_mat4 HMM_MultiplyMat4(hmm_mat4 Left, hmm_mat4 Right);\
hmm_mat4 HMM_MultiplyMat4f(hmm_mat4 Matrix, float Scalar);\
hmm_vec4 HMM_MultiplyMat4ByVec4(hmm_mat4 Matrix, hmm_vec4 Vector);\
hmm_mat4 HMM_DivideMat4f(hmm_mat4 Matrix, float Scalar);\
\
hmm_mat4 HMM_Transpose(hmm_mat4 Matrix);\
\
hmm_mat4 HMM_Orthographic(float Left, float Right, float Bottom, float Top, float Near, float Far);\
hmm_mat4 HMM_Perspective(float FOV, float AspectRatio, float Near, float Far);\
\
hmm_mat4 HMM_Translate(hmm_vec3 Translation);\
hmm_mat4 HMM_Rotate(float Angle, hmm_vec3 Axis);\
hmm_mat4 HMM_Scale(hmm_vec3 Scale);\
\
hmm_mat4 HMM_LookAt(hmm_vec3 Eye, hmm_vec3 Center, hmm_vec3 Up);\
\
hmm_quaternion HMM_Quaternion(float X, float Y, float Z, float W);\
hmm_quaternion HMM_QuaternionV4(hmm_vec4 Vector);\
hmm_quaternion HMM_AddQuaternion(hmm_quaternion Left, hmm_quaternion Right);\
hmm_quaternion HMM_SubtractQuaternion(hmm_quaternion Left, hmm_quaternion Right);\
hmm_quaternion HMM_MultiplyQuaternion(hmm_quaternion Left, hmm_quaternion Right);\
hmm_quaternion HMM_MultiplyQuaternionF(hmm_quaternion Left, float Multiplicative);\
hmm_quaternion HMM_DivideQuaternionF(hmm_quaternion Left, float Dividend);\
hmm_quaternion HMM_InverseQuaternion(hmm_quaternion Left);\
float HMM_DotQuaternion(hmm_quaternion Left, hmm_quaternion Right);\
hmm_quaternion HMM_NormalizeQuaternion(hmm_quaternion Left);\
hmm_quaternion HMM_NLerp(hmm_quaternion Left, float Time, hmm_quaternion Right);\
hmm_quaternion HMM_Slerp(hmm_quaternion Left, float Time, hmm_quaternion Right);\
hmm_mat4 HMM_QuaternionToMat4(hmm_quaternion Left);\
hmm_quaternion HMM_QuaternionFromAxisAngle(hmm_vec3 Axis, float AngleOfRotation);\
\
\9cdef\9load\9arch\7os\
Other\1\0\1\8x64\15hmm_dll.so\
POSIX\1\0\1\8x64\15hmm_dll.so\8BSD\1\0\1\8x64\15hmm_dll.so\
Linux\1\0\2\8arm\15hmm_dll.so\8x64\15hmm_dll.so\12Windows\1\0\1\8x64\16hmm_dll.dll\8OSX\1\0\6\12Windows\0\8BSD\0\
Linux\0\
Other\0\
POSIX\0\8OSX\0\1\0\1\8x64\12hmm_dll\16ffi_hmm_dll\8ffi\12require\1\0\1\0\1\0\3\0\3\0\3\0\3\0\4\0\4\0\5\0\5\0\6\0\6\0\7\0\7\0\8\0\8\0\9\0\9\0\12\0\12\0\12\0\12\0\12\0\12\0\12\0\13\0\13\0\13\0\15\0001\0011\0013\1ffi\0\4\30libs\0\16\14lib\0\7\7hmm_lib\0\3\4\0\0");t['F:.devjit.Thunc.sokol-luajit.ffi.sokol.hmm_utils']=load("\27LJ\2\0080F:.devjit.Thunc.sokol-luajit.ffi.sokol.hmm_utilsÛ\3\0\1\12\0\8\0TY\5\0076\1\0\0'\3\1\0B\1\2\0016\1\0\0'\3\2\0009\4\3\0:\4\0\4:\4\0\4'\5\4\0009\6\3\0:\6\0\6:\6\1\6'\7\4\0009\8\3\0:\8\0\8:\8\2\8'\9\4\0009\
\3\0:\
\0\
:\
\3\
'\11\4\0&\3\11\3B\1\2\0016\1\0\0'\3\5\0009\4\3\0:\4\1\4:\4\0\4'\5\4\0009\6\3\0:\6\1\6:\6\1\6'\7\4\0009\8\3\0:\8\1\8:\8\2\8'\9\4\0009\
\3\0:\
\1\
:\
\3\
'\11\4\0&\3\11\3B\1\2\0016\1\0\0'\3\6\0009\4\3\0:\4\2\4:\4\0\4'\5\4\0009\6\3\0:\6\2\6:\6\1\6'\7\4\0009\8\3\0:\8\2\8:\8\2\8'\9\4\0009\
\3\0:\
\2\
:\
\3\
'\11\4\0&\3\11\3B\1\2\0016\1\0\0'\3\7\0009\4\3\0:\4\3\4:\4\0\4'\5\4\0009\6\3\0:\6\3\6:\6\1\6'\7\4\0009\8\3\0:\8\3\8:\8\2\8'\9\4\0009\
\3\0:\
\3\
:\
\3\
'\11\4\0&\3\11\3B\1\2\1K\0\1\0\12Row 3: \12Row 2: \12Row 1: \6 \13Elements\12Row 0: \19----- hmm_mat4\
print\2\2\2\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\4\4\4\4\4\4\4\4\4\4\4\4\4\4\4\4\4\4\4\4\5\5\5\5\5\5\5\5\5\5\5\5\5\5\5\5\5\5\5\5\6\6\6\6\6\6\6\6\6\6\6\6\6\6\6\6\6\6\6\6\7m\0\0U\0y\0\1\9\0\8\0\13\18\14\0046\1\0\0'\3\1\0B\1\2\0016\1\0\0'\3\2\0009\4\3\0'\5\4\0009\6\5\0'\7\6\0009\8\7\0&\3\8\3B\1\2\1K\0\1\0\6Z\9 Z: \6Y\9 Y: \6X\8X: \19----- hmm_vec3\
print\2\2\2\3\3\3\3\3\3\3\3\3\4v\0\0\14\0ä\1\0\1\11\0\
\0\15\20\20\0046\1\0\0'\3\1\0B\1\2\0016\1\0\0'\3\2\0009\4\3\0'\5\4\0009\6\5\0'\7\6\0009\8\7\0'\9\8\0009\
\9\0&\3\
\3B\1\2\1K\0\1\0\6W\9 W: \6Z\9 Z: \6Y\9 Y: \6X\8X: \19----- hmm_vec4\
print\2\2\2\3\3\3\3\3\3\3\3\3\3\3\4v\0\0\16\0√\6\0\0\9\1\26\0Rt\26\16-\0\0\0009\0\0\0B\0\1\2\11\0\1\0X\0\3Ä-\0\0\0009\0\1\0B\0\1\1-\0\0\0009\0\2\0B\0\1\2'\1\3\0'\2\4\0009\3\5\0)\4\1\0\1\4\3\0X\3\4Ä6\3\6\0009\3\7\3'\5\8\0B\3\2\0016\3\6\0009\3\7\3\18\5\1\0'\6\9\0009\7\5\0'\8\
\0&\5\8\5B\3\2\0016\3\6\0009\3\7\3\18\5\2\0'\6\11\0009\7\12\0'\8\
\0&\5\8\5B\3\2\0016\3\6\0009\3\7\3'\5\13\0009\6\14\0'\7\
\0&\5\7\5B\3\2\0016\3\6\0009\3\7\3'\5\15\0009\6\16\0'\7\
\0&\5\7\5B\3\2\0016\3\6\0009\3\7\3'\5\17\0009\6\18\0'\7\
\0&\5\7\5B\3\2\0016\3\6\0009\3\7\3'\5\19\0009\6\20\0'\7\
\0&\5\7\5B\3\2\0016\3\6\0009\3\7\3'\5\21\0009\6\22\0009\6\23\6'\7\
\0&\5\7\5B\3\2\0016\3\6\0009\3\7\3'\5\24\0009\6\22\0009\6\25\6'\7\
\0&\5\7\5B\3\2\1K\0\1\0\0¿\21num_bind_sampler\23num_bind_sampler: \20num_bind_buffer\7gl\22num_bind_buffer: \24size_apply_uniforms\26size_apply_uniforms: \23num_apply_uniforms\25num_apply_uniforms: \23num_apply_bindings\25num_apply_bindings: \23num_apply_pipeline\25num_apply_pipeline: \15num_passes\17num_passes: \6\
\18frame_index: \9\27[8A\
write\7io\16frame_index\
\27[37m\
\27[31m\25sg_query_frame_stats\26sg_enable_frame_stats\27sg_frame_stats_enabled\2\2\2\2\2\2\2\2\4\4\4\5\6\7\7\7\7\7\7\7\7\8\8\8\8\8\8\8\8\9\9\9\9\9\9\9\9\
\
\
\
\
\
\
\11\11\11\11\11\11\11\12\12\12\12\12\12\12\13\13\13\13\13\13\13\14\14\14\14\14\14\14\14\15\15\15\15\15\15\15\15\16sg\0stats\0\12Gredtext\0\1Fwhitetext\0\1E\0ª\1\3\0\3\0\12\0\18$\0,6\0\0\0009\0\1\0\14\0\0\0X\1\3Ä6\0\2\0'\2\3\0B\0\2\0024\1\0\0003\2\5\0=\2\4\0013\2\7\0=\2\6\0013\2\9\0=\2\8\0013\2\11\0=\2\
\0012\0\0ÄL\1\2\0\0\15show_stats\0\14dump_vec4\0\14dump_vec3\0\14dump_mat4\14sokol_gfx\12require\7sg\7_G\1\1\1\1\1\1\1\3\12\12\18\18\24\24**,,sg\0\8\11hmm_utils\0\1\
\0\0");t['F:.devjit.Thunc.sokol-luajit.utils']=load("\27LJ\2\8\"F:.devjit.Thunc.sokol-luajit.utilsM\0\0\9\0\4\0\
\11\15\0006\0\0\0'\2\1\0\18\4\2\0009\2\2\0026\5\3\0)\7\1\0)\8\6\0B\5\3\0A\2\1\0C\0\0\0\6m\9byte\11aeiouy\6c\0\0\0\0\0\0\0\0\0\0\0-\0\0\6\0\2\0\6\7\15\0006\0\0\0006\2\1\0)\4a\0)\5z\0B\2\3\0C\0\0\0\6m\6c\0\0\0\0\0\0\0Ó\1\1\0\7\0\16\1\"#\13\0046\0\0\0009\0\1\0'\1\2\0009\1\3\0017\1\4\0007\0\5\0'\0\6\0\18\2\0\0009\0\7\0)\3\9\0B\0\3\2\18\2\0\0009\0\8\0'\3\9\0003\4\
\0B\0\4\2\18\2\0\0009\0\8\0'\3\11\0003\4\12\0B\0\4\0027\0\13\0006\0\14\0009\0\15\0006\2\13\0)\3\1\0006\4\0\0009\4\1\4)\6\4\0B\4\2\2\22\4\0\4B\0\4\0022\0\0ÄL\0\2\0\8sub\11string\9name\0\7.-\0\6.\9gsub\8rep\6 \6m\6c\9char\5\11random\9math\
\1\1\1\1\1\1\2\2\2\2\2\2\2\2\2\2\2\2\2\2\2\2\3\3\3\3\3\3\3\3\3\3\3\3\0k\0\1\9\0\1\1\12*\21\7)\1\0\0\11\0\0\0X\2\1ÄL\1\2\0006\2\0\0\18\4\0\0B\2\2\4H\5\1Ä\22\1\0\1F\5\3\3R\5˝\127L\1\2\0\
pairs\2\1\2\2\2\3\3\3\3\4\3\3\6tbl\0\0\13cnt\0\2\11\4\6\4\5\0\4\6\0\4k\0\1\1v\0\0\1\0¯\1\0\1\8\0\3\1*4 \0084\1\5\0006\2\0\0009\2\1\2\18\4\0\0)\5ˇ\0B\2\3\2\25\2\0\2>\2\1\0016\2\0\0009\2\1\0026\4\0\0009\4\2\4\18\6\0\0)\7\8\0B\4\3\2)\5ˇ\0B\2\3\2\25\2\0\2>\2\2\0016\2\0\0009\2\1\0026\4\0\0009\4\2\4\18\6\0\0)\7\16\0B\4\3\2)\5ˇ\0B\2\3\2\25\2\0\2>\2\3\0016\2\0\0009\2\1\0026\4\0\0009\4\2\4\18\6\0\0)\7\24\0B\4\3\2)\5ˇ\0B\2\3\2\25\2\0\2>\2\4\1L\1\2\0\11rshift\9band\8bit˛\3\2\3\3\3\3\3\3\3\4\4\4\4\4\4\4\4\4\4\4\5\5\5\5\5\5\5\5\5\5\5\6\6\6\6\6\6\6\6\6\6\6\7ucolor\0\0+\0û\4\0\1\14\1\15\0Ny,\0154\1\0\0\18\4\0\0009\2\0\0)\5\1\0)\6\8\0B\2\4\0026\3\1\0009\3\2\3'\5\3\0)\6â\0)\7P\0)\8N\0)\9G\0)\
\13\0)\11\
\0)\12\26\0)\13\
\0B\3\
\2\5\2\3\0X\0038Ä-\3\0\0009\3\4\3'\5\5\0\18\6\0\0)\7\9\0B\3\4\2-\4\0\0009\4\4\4'\6\7\0\18\7\0\0)\8\17\0B\4\4\2=\4\6\1-\4\0\0009\4\4\4'\6\7\0\18\7\0\0)\8\21\0B\4\4\2=\4\8\1-\4\0\0009\4\4\4'\6\
\0\18\7\0\0)\8\25\0B\4\4\2=\4\9\1-\4\0\0009\4\4\4'\6\
\0\18\7\0\0)\8\26\0B\4\4\2=\4\11\1-\4\0\0009\4\4\4'\6\
\0\18\7\0\0)\8\27\0B\4\4\2=\4\12\1-\4\0\0009\4\4\4'\6\
\0\18\7\0\0)\8\28\0B\4\4\2=\4\13\1-\4\0\0009\4\4\4'\6\
\0\18\7\0\0)\8\29\0B\4\4\2=\4\14\1L\1\2\0+\3\0\0L\3\2\0\4¿\14interlace\11filter\9comp\9type\7>B\
depth\11height\7>I\
width\7<L\11unpack\21%c%c%c%c%c%c%c%c\11format\11string\8sub\1\2\2\2\2\2\3\3\3\3\3\3\3\3\3\3\3\3\3\3\4\4\4\4\4\4\5\5\5\5\5\5\5\6\6\6\6\6\6\6\7\7\7\7\7\7\7\8\8\8\8\8\8\8\9\9\9\9\9\9\9\
\
\
\
\
\
\
\11\11\11\11\11\11\11\12\14\14struct\0header\0\0Opnginfo\0\2Mfilesig\0\5Htmp\0\0202\0»\2\0\1\8\1\8\0\"[?\0146\1\0\0009\1\1\1\18\3\0\0'\4\2\0B\1\3\2\11\1\0\0X\2\7Ä6\2\3\0'\4\4\0\18\5\0\0&\4\5\4B\2\2\1+\2\0\0L\2\2\0\18\4\1\0009\2\5\1)\5\29\0B\2\3\2\18\5\1\0009\3\6\1B\3\2\1-\3\0\0\18\5\2\0B\3\2\2\15\0\3\0X\4\1ÄL\3\2\0006\4\3\0'\6\7\0\18\7\0\0&\6\7\6B\4\2\1+\4\0\0L\4\2\0\9¿$[Error] Png header unreadable: \
close\9read![Error] png file not found: \
print\7rb\9open\7io\2\2\2\2\2\3\3\4\4\4\4\4\5\5\7\7\7\7\8\8\8\9\9\9\
\
\
\12\12\12\12\12\13\13processPngHeader\0filenamepath\0\0#fh\0\6\29header\0\13\16pnginfo\0\6\
\0ﬁ\1\0\2\11\0\4\0 <Q\12\11\0\0\0X\2\1Ä4\0\0\0\11\1\0\0X\2\1ÄL\0\2\0006\2\0\0\18\4\1\0B\2\2\4H\5\19Ä6\7\1\0\18\9\6\0B\7\2\2\7\7\2\0X\7\13Ä6\7\1\0008\9\5\0\14\0\9\0X\
\1Ä+\9\1\0B\7\2\2\7\7\2\0X\7\5Ä6\7\3\0008\9\5\0008\
\5\1B\7\3\1X\7\1Ä<\6\5\0F\5\3\3R\5Î\127L\0\2\0\11tmerge\
table\9type\
pairs\1\1\1\2\2\2\4\4\4\4\5\5\5\5\5\5\5\5\5\5\5\5\5\6\6\6\6\6\8\4\4\11t1\0\0!t2\0\0!\4\
\22\5\0\22\6\0\22k\0\1\19v\0\0\19\0›\3\0\2\18\2\14\2D|a\16\12\2\1\0X\2\1Ä)\2\1\0\9\2\0\0X\3\2Ä4\3\0\0.\0\3\0006\3\0\0\18\5\0\0B\3\2\2\7\3\1\0X\0031Ä'\3\2\0006\4\3\0\18\6\0\0B\4\2\4H\7 Ä6\9\0\0\18\11\7\0B\9\2\2\6\9\4\0X\9\6Ä'\9\5\0006\
\6\0\18\12\7\0B\
\2\2'\11\5\0&\7\11\9-\9\0\0008\9\8\9\11\9\0\0X\9\17Ä-\9\0\0+\
\2\0<\
\8\9\18\9\3\0006\
\7\0009\
\8\
'\12\9\0\18\13\2\0B\
\3\2'\11\
\0\18\12\7\0'\13\11\0-\14\1\0\18\16\8\0\22\17\1\2B\14\3\2&\3\14\9F\7\3\3R\7ﬁ\127\18\4\3\0006\5\7\0009\5\8\5'\7\9\0\23\8\1\2B\5\3\2'\6\12\0&\4\6\4L\4\2\0X\3\6Ä6\3\6\0\18\5\0\0B\3\2\2'\4\13\0&\3\4\3L\3\2\0K\0\1\0\11Ä\12¿\6\
\7}\
\9] = \6[\7  \8rep\11string\13tostring\6\"\11number\
pairs\8 {\
\
table\9type\0\2\1\1\1\2\2\2\2\3\3\3\3\3\4\5\5\5\5\6\6\6\6\6\6\6\6\6\6\6\7\7\7\7\8\8\8\9\9\9\9\9\9\9\9\9\9\9\9\9\9\5\5\12\12\12\12\12\12\12\12\12\12\14\14\14\14\14\14\16visited\0tdump\0o\0\0Elevel\0\0Elevel\0\4As\0\
/\4\3#\5\0#\6\0#k\0\1 v\0\0 \0º\3\0\1\15\1\12\1Bmu\19'\1\0\0)\2\1\0006\3\1\0\18\5\0\0B\3\2\4H\0066Ä\8\2\0\0X\8\3Ä\18\8\1\0'\9\2\0&\1\9\0086\8\3\0\18\
\7\0B\8\2\2\7\8\4\0X\8\11Ä\18\8\1\0'\9\5\0006\
\6\0\18\12\6\0B\
\2\2'\11\7\0-\12\0\0\18\14\7\0B\12\2\2&\1\12\8X\8 Ä6\8\3\0\18\
\7\0B\8\2\2\7\8\8\0X\8\11Ä\18\8\1\0'\9\5\0006\
\6\0\18\12\6\0B\
\2\2'\11\9\0006\12\6\0\18\14\7\0B\12\2\2&\1\12\8X\8\16Ä6\8\3\0\18\
\7\0B\8\2\2\6\8\
\0X\8\11Ä\18\8\1\0'\9\5\0006\
\6\0\18\12\6\0B\
\2\2'\11\7\0006\12\6\0\18\14\7\0B\12\2\2'\13\5\0&\1\13\8\22\2\0\2F\6\3\3R\6»\127\18\3\1\0'\4\11\0&\1\4\3L\1\2\0\13¿\7 }\13function\7\":\11number\8\":\"\13tostring\6\"\
table\9type\6,\
pairs\6{\2\2\3\4\4\4\4\5\5\5\5\5\7\7\7\7\7\8\8\8\8\8\8\8\8\8\8\8\9\9\9\9\9\
\
\
\
\
\
\
\
\
\
\
\11\11\11\11\11\12\12\12\12\12\12\12\12\12\12\12\14\4\4\16\16\16\18tablejson\0list\0\0Cp\0\2Ai\0\1@\4\0039\5\0009\6\0009k\0\0016v\0\0006\0˚\1\0\1\11\0\6\0\31@é\1\0126\1\0\0\18\3\0\0B\1\2\2\6\1\1\0X\1\1ÄL\0\2\0006\1\2\0\18\3\0\0B\1\2\0024\2\0\0006\3\3\0\18\5\0\0B\3\2\4H\6\
Ä6\8\0\0\18\
\7\0B\8\2\2\7\8\1\0X\8\4Ä6\8\4\0\18\
\7\0B\8\2\2\18\7\8\0<\7\6\2F\6\3\3R\6Ù\1276\3\5\0\18\5\2\0\18\6\1\0B\3\3\1L\2\2\0\17setmetatable\13deepcopy\
pairs\17getmetatable\
table\9type\1\1\1\1\1\1\2\2\2\3\4\4\4\4\5\5\5\5\5\6\6\6\6\8\4\4\
\
\
\
\11t\0\0 mt\0\
\22res\0\1\21\4\3\13\5\0\13\6\0\13k\0\1\
v\0\0\
\0Ó\1\0\1\7\0\8\0\0262û\1\11+\1\0\0006\2\0\0009\2\1\2\18\4\0\0'\5\2\0B\2\3\0026\3\3\0\18\5\0\0B\3\2\1\15\0\2\0X\3\9Ä\18\5\2\0009\3\4\2'\6\5\0B\3\3\2\18\1\3\0\18\5\2\0009\3\6\2B\3\2\1X\3\5Ä6\3\3\0'\5\7\0\18\6\0\0&\5\6\5B\3\2\1L\1\2\0.[Error] utils.loaddata: Unable to load - \
close\7*a\9read\
print\7rb\9open\7io\1\2\2\2\2\2\3\3\3\4\4\5\5\5\5\5\6\6\6\6\8\8\8\8\8\
filepath\0\0\27data\0\2\25fh\0\5\20\0ï\1\0\3\5\0\2\0\20,≠\1\
9\3\0\0\11\3\0\0X\3\1ÄK\0\1\0009\3\0\0009\4\0\0009\4\1\4!\4\1\4=\4\1\0039\3\0\0009\3\1\3)\4\0\0\1\3\4\0X\3\5Ä9\3\0\0)\4\0\0=\4\1\3\18\3\2\0B\3\1\1K\0\1\0\12timeout\
round\2\2\2\2\4\4\4\4\4\6\6\6\6\6\7\7\7\8\8\
self\0\0\21dt\0\0\21callback\0\0\21\0Û\1\0\1\6\0\6\0(/ª\1\13\11\0\0\0X\1\1ÄL\0\2\0006\1\0\0009\1\1\1\18\3\0\0)\4\1\0)\5\1\0B\1\4\2\7\1\2\0X\1\7Ä6\1\0\0009\1\1\1\18\3\0\0)\4\2\0)\5ˇˇB\1\4\2\18\0\1\0006\1\0\0009\1\1\1\18\3\0\0)\4ˇˇB\1\3\2\7\1\2\0X\1\7Ä6\1\0\0009\1\1\1\18\3\0\0)\4\1\0)\5˛ˇB\1\4\2\18\0\1\0006\1\0\0009\1\3\1\18\3\0\0'\4\4\0'\5\5\0B\1\4\2\18\0\1\0L\0\2\0\6 \9%%20\9gsub\6'\8sub\11string\1\1\1\2\2\2\2\2\2\2\2\3\3\3\3\3\3\3\5\5\5\5\5\5\5\6\6\6\6\6\6\6\8\8\8\8\8\8\8\12str\0\0)\0Æ\1\0\2\11\0\4\1\22:Ã\1\0124\2\0\0)\3\1\0\18\6\0\0009\4\0\0'\7\1\0\18\8\1\0'\9\2\0&\7\9\7B\4\3\4X\7\9Ä\7\7\3\0X\8\2Ä\22\3\0\3X\8\5Ä8\8\3\2\14\0\8\0X\9\1Ä\18\8\7\0<\8\3\2E\7\3\2R\7ı\127L\2\2\0\5\8]*)\8([^\11gmatch\2\1\2\3\3\3\3\3\3\3\3\5\5\6\6\8\8\8\8\8\3\3\11str\0\0\23sep\0\0\23ret\0\2\21n\0\1\20\4\7\12\5\0\12\6\0\12w\0\1\9\0Ì\1\0\1\9\0\9\0\0261‹\1\9+\1\0\0006\2\0\0009\2\1\2'\4\2\0006\5\3\0\18\7\0\0B\5\2\2'\6\4\0&\4\6\4B\2\2\2\15\0\2\0X\3\6Ä\18\5\2\0009\3\5\2'\6\6\0B\3\3\2\18\1\3\0X\3\7Ä6\3\7\0'\5\8\0006\6\3\0\18\8\0\0B\6\2\2&\5\6\5B\3\2\1L\1\2\0\30[Error] failed to read - \
print\7*a\9read\6\"\13tostring\17dir /AD /b \"\
popen\7io\1\2\2\2\2\2\2\2\2\2\3\3\4\4\4\4\4\4\6\6\6\6\6\6\6\8folder\0\0\27result\0\2\25f\0\9\16\0ˆ\1\0\1\9\0\9\0\0261È\1\9+\1\0\0006\2\0\0009\2\1\2'\4\2\0006\5\3\0\18\7\0\0B\5\2\2'\6\4\0&\4\6\4B\2\2\2\15\0\2\0X\3\6Ä\18\5\2\0009\3\5\2'\6\6\0B\3\3\2\18\1\3\0X\3\7Ä6\3\7\0'\5\8\0006\6\3\0\18\8\0\0B\6\2\2&\5\6\5B\3\2\1L\1\2\0\30[Error] failed to read - \
print\7*a\9read\6\"\13tostring\26ls -d -A -G -N -1 * \"\
popen\7io\1\2\2\2\2\2\2\2\2\2\3\3\4\4\4\4\4\4\6\6\6\6\6\6\6\8folder\0\0\27result\0\2\25f\0\9\16\0Ô\1\0\1\7\4\5\0\28Xˆ\1\17'\1\0\0-\2\0\0009\2\1\2\7\2\2\0X\2\1ÄX\2\13Ä-\2\0\0009\2\1\2\7\2\3\0X\2\5Ä-\2\1\0\18\4\0\0B\2\2\2\18\1\2\0X\2\4Ä-\2\2\0\18\4\0\0B\2\2\2\18\1\2\0+\2\0\0\15\0\1\0X\3\5Ä-\3\3\0\18\5\1\0'\6\4\0B\3\3\2\18\2\3\0L\2\2\0\3¿\18¿\19¿\17¿\6\
\12Windows\
HTML5\7os\5\1\2\2\2\2\2\4\4\4\4\5\5\5\5\5\7\7\7\7\11\12\12\13\13\13\13\13\16ffi\0windows_dir\0unix_dir\0csplit\0folder\0\0\29dirstr\0\2\27restbl\0\19\8\0Û\1\0\2\12\0\4\2$?ã\2\
6\2\0\0009\2\1\2\18\4\0\0\18\5\1\0B\2\3\2\18\0\2\0)\2\0\0)\3\7\0)\4\1\0M\2\25Ä6\6\0\0009\6\2\6\18\8\0\0)\9\1\0B\6\3\2\9\6\0\0X\6\7Ä6\6\0\0009\6\3\6\18\8\0\0)\9\1\0B\6\3\2\18\0\6\0X\6\
Ä6\6\0\0009\6\1\0066\8\0\0009\8\3\8\18\
\0\0)\11\1\0B\8\3\2*\9\1\0B\6\3\2\18\0\6\0O\2Á\127L\0\2\0\11rshift\9band\9bxor\8bit\0ÇÄ\5\1\1\1\1\1\1\2\2\2\2\3\3\3\3\3\3\3\4\4\4\4\4\4\4\6\6\6\6\6\6\6\6\6\6\2\9sum\0\0%data\0\0%\1\
\26\2\0\26\3\0\26i\0\1\24\0´\1\0\2\12\1\2\1\19Cô\2\8*\2\0\0+\3\0\0)\4\1\0\18\5\1\0)\6\1\0M\4\12Ä6\8\0\0009\8\1\8\18\
\0\0\18\11\7\0B\8\3\2\18\3\8\0-\8\0\0\18\
\2\0\18\11\3\0B\8\3\2\18\2\8\0O\4Ù\127L\2\2\0\21¿\9byte\11string˛ˇ\7\1\2\3\3\3\3\4\4\4\4\4\4\5\5\5\5\5\3\7ByteCRC\0data\0\0\20length\0\0\20sum\0\2\18d\0\1\17\1\3\13\2\0\13\3\0\13i\0\1\11\0Ê\2\0\1\8\0\14\0008=•\2\0116\1\0\0\18\3\0\0B\1\2\2\7\1\1\0X\1#Ä6\1\1\0009\1\2\1\18\3\0\0'\4\3\0'\5\4\0B\1\4\2\18\0\1\0006\1\1\0009\1\5\0016\3\1\0009\3\2\3\18\5\0\0'\6\6\0'\7\7\0B\3\4\2'\4\8\0B\1\3\2\15\0\1\0X\2\5Ä'\1\9\0\18\2\0\0'\3\9\0&\1\3\1L\1\2\0'\1\
\0006\2\1\0009\2\2\2\18\4\0\0'\5\
\0'\6\11\0B\2\4\2'\3\
\0&\1\3\1L\1\2\0X\1\15Ä6\1\0\0\18\3\0\0B\1\2\2\7\1\12\0X\1\6Ä6\1\12\0009\1\13\1\18\3\0\0B\1\2\2\14\0\1\0X\2\3Ä6\1\13\0\18\3\0\0B\1\2\2L\1\2\0K\0\1\0\13tostring\
table\7\\\"\6\"\6'\9^\"+$\5\
[^'\"]\
match\7\\n\6\
\9gsub\11string\9type\1\1\1\1\1\2\2\2\2\2\2\2\3\3\3\3\3\3\3\3\3\3\3\3\4\4\4\4\4\6\6\6\6\6\6\6\6\6\6\6\8\8\8\8\8\8\8\8\8\8\8\9\9\9\9\11v\0\0009\0∫\1\0\1\5\0\8\0\23\28≤\2\0066\1\0\0\18\3\0\0B\1\2\2\7\1\1\0X\1\9Ä6\1\1\0009\1\2\1\18\3\0\0'\4\3\0B\1\3\2\15\0\1\0X\2\2ÄL\0\2\0X\1\8Ä'\1\4\0006\2\5\0009\2\6\2\18\4\0\0B\2\2\2'\3\7\0&\1\3\1L\1\2\0K\0\1\0\6]\15val_to_str\
table\6[\20^[_%a][_%a%d]*$\
match\11string\9type\1\1\1\1\1\1\1\1\1\1\1\1\2\2\4\4\4\4\4\4\4\4\6k\0\0\24\0˝\2\0\1\16\0\11\0002k∫\2\0134\1\0\0004\2\0\0006\3\0\0\18\5\0\0B\3\2\4X\6\
Ä6\8\1\0009\8\2\8\18\
\1\0006\11\1\0009\11\3\11\18\13\7\0B\11\2\0A\8\1\1+\8\2\0<\8\6\2E\6\3\3R\6Ù\1276\3\4\0\18\5\0\0B\3\2\4H\6\17Ä8\8\6\2\14\0\8\0X\8\14Ä6\8\1\0009\8\2\8\18\
\1\0006\11\1\0009\11\5\11\18\13\6\0B\11\2\2'\12\6\0006\13\1\0009\13\3\13\18\15\7\0B\13\2\2&\11\13\11B\8\3\1F\6\3\3R\6Ì\127'\3\7\0006\4\1\0009\4\8\4\18\6\1\0'\7\9\0B\4\3\2'\5\
\0&\3\5\3L\3\2\0\6}\6,\11concat\6{\6=\15key_to_str\
pairs\15val_to_str\11insert\
table\11ipairs\1\1\2\2\2\2\3\3\3\3\3\3\3\3\4\4\2\2\6\6\6\6\7\7\7\8\8\8\9\9\9\9\9\9\9\9\9\9\8\6\6\12\12\12\12\12\12\12\12\12tbl\0\0003result\0\0030done\0\0000\4\3\13\5\0\13\6\0\13k\0\1\
v\0\0\
\4\15\20\5\0\20\6\0\20k\0\1\17v\0\0\17\0â\8\3\0\25\0000\0A˜\2\0„\0026\0\0\0009\0\1\0006\1\0\0009\1\2\0016\2\0\0009\2\3\0026\3\4\0'\5\5\0B\3\2\0026\4\4\0'\6\6\0B\4\2\0026\5\4\0'\7\7\0B\5\2\0023\6\8\0003\7\9\0003\8\
\0003\9\11\0003\
\12\0003\11\13\0007\11\14\0004\11\0\0003\12\15\0003\13\16\0003\14\17\0007\14\18\0003\14\19\0003\15\20\0003\16\21\0003\17\22\0003\18\23\0003\19\24\0003\20\25\0003\21\26\0003\22\27\0006\23\0\0003\24\29\0=\24\28\0236\23\0\0003\24\31\0=\24\30\0236\23\0\0003\24!\0=\24 \0235\23\"\0=\20#\23=\17$\23=\16%\23=\8&\23=\
'\23=\9(\23=\22)\23=\6*\23=\7+\0236\24\14\0=\24\14\23=\12,\23=\13-\0236\24\18\0=\24\18\23=\15.\23=\14/\0232\0\0ÄL\23\2\0\13loaddata\14tickround\14tablejson\
tdump\11tcount\12genname\8crc\17getpngheader\15getpngfile\16uinttocolor\16cleanstring\11csplit\12getdirs\1\0\15\16uinttocolor\0\12genname\0\11tmerge\0\14tickround\0\11tcount\0\8crc\0\17getpngheader\0\13loaddata\0\15getpngfile\0\11csplit\0\12getdirs\0\13deepcopy\0\14tablejson\0\16cleanstring\0\
tdump\0\0\13tostring\0\15key_to_str\0\15val_to_str\0\0\0\0\0\0\0\0\0\13deepcopy\0\0\0\11tmerge\0\0\0\0\0\0\
tween\11struct\8ffi\12require\9getn\11remove\11insert\
table\1\0\1\0\2\0\2\0\3\0\3\0\4\0\4\0\4\0\8\0\8\0\8\0\9\0\9\0\9\0\17\0\28\0(\0;\0M\0]\0Q\0`\0q\0à\0ö\0é\0©\0∑\0»\0ÿ\0Â\0Ú\0\7\1\21\1!\1%\0010\1%\0012\0018\0012\1:\1G\1:\1J\1L\1M\1N\1P\1Q\1R\1T\1V\1W\1X\1X\1Y\1Z\1\\\1\\\1^\1`\1a\1a\1tinsert\0\3?tremove\0\2=tcount\0\2;ffi\0\0038struct\0\0035tween\0\0032genname\0\0011tcount\0\0010uinttocolor\0\1/processPngHeader\0\1.getpngfile\0\1-visited\0\3*tdump\0\1)tablejson\0\1(loaddata\0\3%tickround\0\1$cleanstring\0\1#csplit\0\1\"windows_dir\0\1!unix_dir\0\1 getdirs\0\1\31ByteCRC\0\1\30CRC\0\1\29\0\0");load("\27LJ\2\8@@F:\\dev\\luajit\\Thunc\\sokol-luajit\\examples\\samples\\cube_sapp.lua¬\1\0\7\20\0\3\0\18[#\0036\7\0\0'\9\1\0B\7\2\0016\7\0\0\18\9\0\0'\
\2\0\18\11\1\0'\12\2\0\18\13\2\0'\14\2\0\18\15\3\0'\16\2\0\18\17\4\0'\18\2\0\18\19\5\0&\9\19\9B\7\2\1K\0\1\0\6 \17-------->>> \
print\1\1\1\2\2\2\2\2\2\2\2\2\2\2\2\2\2\3tag\0\0\19log_level\0\0\19log_item\0\0\19message\0\0\19line_nr\0\0\19filename\0\0\19user_data\0\0\19\0Ÿ\16\0\0\13\0064\0ù\1ô\2.Q-\0\0\0009\0\0\0'\2\1\0B\0\2\2:\1\0\0-\2\1\0009\2\3\2B\2\1\2=\2\2\1:\1\0\0009\1\4\1-\2\1\0009\2\6\2=\2\5\1:\1\0\0+\2\1\0=\2\7\1-\1\2\0009\1\8\1\18\3\0\0B\1\2\0016\1\9\0'\3\
\0006\4\11\0-\6\2\0009\6\12\6B\6\1\0A\4\0\2&\3\4\3B\1\2\1-\1\0\0009\1\0\1'\3\13\0005\4\14\0B\1\3\2-\2\0\0009\2\0\2'\4\15\0B\2\2\2:\3\0\0029\3\16\3=\1\17\3:\3\0\0029\3\16\3-\4\0\0009\4\19\4\18\6\1\0B\4\2\2=\4\18\3:\3\0\2'\4\21\0=\4\20\3-\3\2\0009\3\22\3\18\5\2\0B\3\2\2-\4\0\0009\4\0\4'\6\23\0005\7\24\0B\4\3\2-\5\0\0009\5\0\5'\7\15\0004\8\0\0B\5\3\2:\6\0\5-\7\2\0009\7\26\7=\7\25\6:\6\0\0059\6\16\6=\4\17\6:\6\0\0059\6\16\6-\7\0\0009\7\19\7\18\9\4\0B\7\2\2=\7\18\6:\6\0\5'\7\27\0=\7\20\6-\6\2\0009\6\22\6\18\8\5\0B\6\2\2-\7\2\0009\7\28\7-\9\3\0B\7\2\2-\8\0\0009\8\0\8'\
\29\0004\11\0\0B\8\3\2:\9\0\0089\9\30\0099\9\31\9:\9\0\9)\
\28\0=\
 \9:\9\0\0089\9\30\0099\9!\9:\9\0\9-\
\2\0009\
#\
=\
\"\9:\9\0\0089\9\30\0099\9!\9:\9\1\9-\
\2\0009\
$\
=\
\"\9:\9\0\8=\7%\9:\9\0\8-\
\2\0009\
'\
=\
&\9:\9\0\8-\
\2\0009\
)\
=\
(\9:\9\0\0089\9*\9+\
\2\0=\
+\9:\9\0\0089\9*\9-\
\2\0009\
-\
=\
,\9:\9\0\8'\
.\0=\
\20\9-\9\4\0:\9\0\9-\
\2\0009\
0\
\18\12\8\0B\
\2\2=\
/\9-\9\5\0:\9\0\0099\0091\9>\3\0\9-\9\5\0:\9\0\9=\0062\9-\9\4\0:\9\0\9-\
\5\0=\
3\9K\0\1\0\7¿\3¿\2¿\9¿\11¿\13¿\9bind\17index_buffer\19vertex_buffers\21sg_make_pipeline\8pip\18cube-pipeline\30SG_COMPAREFUNC_LESS_EQUAL\12compare\18write_enabled\
depth\21SG_CULLMODE_BACK\14cull_mode\24SG_INDEXTYPE_UINT16\15index_type\11shader\27SG_VERTEXFORMAT_FLOAT4\27SG_VERTEXFORMAT_FLOAT3\11format\
attrs\11stride\12buffers\11layout\24sg_pipeline_desc[1]\19sg_make_shader\17cube-indices\30SG_BUFFERTYPE_INDEXBUFFER\9type\1%\0\0\3\0\3\1\3\2\3\0\3\2\3\3\3\6\3\5\3\4\3\7\3\6\3\4\3\8\3\9\3\
\3\8\3\
\3\11\3\14\3\13\3\12\3\15\3\14\3\12\3\16\3\17\3\18\3\16\3\18\3\19\3\22\3\21\3\20\3\23\3\22\3\20\17uint16_t[36]\19sg_make_buffer\18cube-vertices\
label\11sizeof\9size\8ptr\9data\22sg_buffer_desc[1]\1©\1\0\0\3ˇˇˇˇ\15\3ˇˇˇˇ\15\3ˇˇˇˇ\15\3\1\3\0\3\0\3\1\3\1\3ˇˇˇˇ\15\3ˇˇˇˇ\15\3\1\3\0\3\0\3\1\3\1\3\1\3ˇˇˇˇ\15\3\1\3\0\3\0\3\1\3ˇˇˇˇ\15\3\1\3ˇˇˇˇ\15\3\1\3\0\3\0\3\1\3ˇˇˇˇ\15\3ˇˇˇˇ\15\3\1\3\0\3\1\3\0\3\1\3\1\3ˇˇˇˇ\15\3\1\3\0\3\1\3\0\3\1\3\1\3\1\3\1\3\0\3\1\3\0\3\1\3ˇˇˇˇ\15\3\1\3\1\3\0\3\1\3\0\3\1\3ˇˇˇˇ\15\3ˇˇˇˇ\15\3ˇˇˇˇ\15\3\0\3\0\3\1\3\1\3ˇˇˇˇ\15\3\1\3ˇˇˇˇ\15\3\0\3\0\3\1\3\1\3ˇˇˇˇ\15\3\1\3\1\3\0\3\0\3\1\3\1\3ˇˇˇˇ\15\3ˇˇˇˇ\15\3\1\3\0\3\0\3\1\3\1\3\1\3ˇˇˇˇ\15\3ˇˇˇˇ\15\3\1\4\0ÄÄÄˇ\3\3\0\3\1\3\1\3\1\3ˇˇˇˇ\15\3\1\4\0ÄÄÄˇ\3\3\0\3\1\3\1\3\1\3\1\3\1\4\0ÄÄÄˇ\3\3\0\3\1\3\1\3ˇˇˇˇ\15\3\1\3\1\4\0ÄÄÄˇ\3\3\0\3\1\3ˇˇˇˇ\15\3ˇˇˇˇ\15\3ˇˇˇˇ\15\3\0\4\0ÄÄÄˇ\3\3\1\3\1\3ˇˇˇˇ\15\3ˇˇˇˇ\15\3\1\3\0\4\0ÄÄÄˇ\3\3\1\3\1\3\1\3ˇˇˇˇ\15\3\1\3\0\4\0ÄÄÄˇ\3\3\1\3\1\3\1\3ˇˇˇˇ\15\3ˇˇˇˇ\15\3\0\4\0ÄÄÄˇ\3\3\1\3\1\3ˇˇˇˇ\15\3\1\3ˇˇˇˇ\15\3\1\3\0\4\0ÄÄÄˇ\3\3\1\3ˇˇˇˇ\15\3\1\3\1\3\1\3\0\4\0ÄÄÄˇ\3\3\1\3\1\3\1\3\1\3\1\3\0\4\0ÄÄÄˇ\3\3\1\3\1\3\1\3ˇˇˇˇ\15\3\1\3\0\4\0ÄÄÄˇ\3\3\1\15float[168]\15sg_isvalid\13tostring\21Sokol Is Valid: \
print\13sg_setup\23disable_validation\14slog_func\9func\11logger\22sglue_environment\16environment\15sg_desc[1]\8new\2\2\2\2\3\3\3\3\3\4\4\4\4\4\5\5\5\6\6\6\6\7\7\7\7\7\7\7\7\7\9\9\9\9\9))))***+++++++,,,----/////888889999:::;;;;;;;<<<====????AAAAABBBBBBCCCCCCCDDDDDDDEEFFFFGGGGHHHHIIIIIJJJKKKKKKKMMMMNNNOOOOQffi\0slib\0sg\0shader\0state\0binding\0desc\0\5ô\1vertices\0\31zbuffer_desc\0\4vvbuf\0\17eindices\0\5`ibuffer_desc\0\5[ibuf\0\21Fshd\0\4Bpipe_desc\0\5=\0ˇ\
\0\0\17\7#\5ß\1§\2É\1(-\0\0\0009\0\0\0B\0\1\2-\1\0\0009\1\1\1B\1\1\2-\2\0\0009\2\2\2B\2\1\2\24\2\0\2-\3\1\0009\3\3\3)\5<\0#\6\1\0*\7\1\0)\8\
\0B\3\5\2-\4\1\0009\4\4\4-\6\1\0009\6\5\6)\8\0\0*\9\2\0)\
\6\0B\6\4\2-\7\1\0009\7\5\7)\9\0\0)\
\0\0)\11\0\0B\7\4\2-\8\1\0009\8\5\8)\
\0\0)\11\1\0)\12\0\0B\8\4\0A\4\2\2-\5\1\0009\5\6\5\18\7\3\0\18\8\4\0B\5\3\2-\6\2\0:\6\0\6-\7\2\0:\7\0\0079\7\7\7\29\8\3\2 \7\8\7=\7\7\6-\6\2\0:\6\0\6-\7\2\0:\7\0\0079\7\8\7\29\8\4\2 \7\8\7=\7\8\6-\6\1\0009\6\9\6-\8\2\0:\8\0\0089\8\7\8-\9\1\0009\9\5\9)\11\1\0)\12\0\0)\13\0\0B\9\4\0A\6\1\2-\7\1\0009\7\9\7-\9\2\0:\9\0\0099\9\8\9-\
\1\0009\
\5\
)\12\0\0)\13\1\0)\14\0\0B\
\4\0A\7\1\2-\8\1\0009\8\6\8\18\
\6\0\18\11\7\0B\8\3\2-\9\1\0009\9\6\9\18\11\5\0\18\12\8\0B\9\3\2-\
\3\0009\
\
\
'\12\11\0B\
\2\2:\11\0\
9\11\12\0119\11\13\11:\11\0\11-\12\4\0009\12\15\12=\12\14\11:\11\0\
9\11\12\0119\11\13\11:\11\0\0115\12\17\0=\12\16\11:\11\0\
-\12\5\0009\12\19\12B\12\1\2=\12\18\11-\11\4\0009\11\20\11\18\13\
\0B\11\2\1-\11\4\0009\11\21\11-\13\2\0:\13\0\0139\13\22\13B\11\2\1-\11\4\0009\11\23\11-\13\2\0:\13\0\0139\13\24\13B\11\2\1-\11\3\0009\11\
\11'\13\25\0B\11\2\2:\12\0\11=\9\26\12-\12\6\0:\12\0\12=\11\27\12-\12\6\0:\12\0\12-\13\3\0009\13\29\13:\15\0\11B\13\2\2=\13\28\12-\12\4\0009\12\30\12-\14\4\0009\14\31\14)\15\0\0-\16\6\0B\12\4\1-\12\4\0009\12 \12)\14\0\0)\15$\0)\16\1\0B\12\4\1-\12\4\0009\12!\12B\12\1\1-\12\4\0009\12\"\12B\12\1\1K\0\1\0\1¿\4¿\11¿\7¿\2¿\3¿\12¿\14sg_commit\16sg_end_pass\12sg_draw\22SG_SHADERSTAGE_VS\22sg_apply_uniforms\11sizeof\9size\8ptr\8mvp\19vs_params_t[1]\9bind\22sg_apply_bindings\8pip\22sg_apply_pipeline\18sg_begin_pass\20sglue_swapchain\14swapchain\1\5\0\0\4\0ÄÄ¿˛\3\4\0ÄÄÄˇ\3\4\0ÄÄ†ˇ\3\3\1\16clear_value\24SG_LOADACTION_CLEAR\16load_action\11colors\11action\15sg_pass[1]\8new\15HMM_Rotate\7ry\7rx\21HMM_MultiplyMat4\13HMM_Vec3\15HMM_LookAt\20HMM_Perspective\24sapp_frame_duration\17sapp_heightf\16sapp_widthfx˜—˙\8·ıë¸\3\1ÄÄ‡ˇ\3\2\4\3\3\3\4\4\4\5\5\5\5\7\7\7\7\7\7\7\8\8\8\8\8\8\8\8\8\8\8\8\8\8\8\8\8\8\8\8\8\9\9\9\9\9\
\
\
\
\
\
\
\
\11\11\11\11\11\11\11\11\13\13\13\13\13\13\13\13\13\13\13\13\14\14\14\14\14\14\14\14\14\14\14\14\15\15\15\15\15\17\17\17\17\17\19\19\19\19\20\20\20\20\20\20\20\21\21\21\21\21\21\22\22\22\22\22\23\23\23\23\25\25\25\25\25\25\26\26\26\26\26\26\28\28\28\28\29\29\30\30\30\31\31\31\31\31\31\31       \"\"\"\"\"\"###$$$(sapp\0hmm\0state\0ffi\0sg\0slib\0sg_range\0w\0\4§\1h\0\3°\1t\0\4ù\1proj\0\7ñ\1view\0\21Å\1view_proj\0\5|rxm\0\28`rym\0\12Tmodel\0\5Omvp\0\5Jpass\0\4Fvs_params\0& \0001\0\0\2\1\1\0\4\8Ø\1\2-\0\0\0009\0\0\0B\0\1\1K\0\1\0\2¿\16sg_shutdown\1\1\1\2sg\0\0Ê\8\3\0\23\0+\0`ı\1\0√\0016\0\0\0006\1\0\0009\1\1\1'\2\2\0&\1\2\1=\1\1\0006\0\3\0'\2\4\0B\0\2\0029\0\5\0'\2\6\0B\0\2\0026\1\3\0'\3\7\0B\1\2\0026\2\3\0'\4\8\0B\2\2\0026\3\3\0'\5\9\0B\3\2\0026\4\3\0'\6\
\0B\4\2\0026\5\3\0'\7\11\0B\5\2\0026\6\3\0'\8\12\0B\6\2\0026\7\3\0'\9\13\0B\7\2\0029\8\14\7'\
\15\0B\8\2\0016\8\3\0'\
\16\0B\8\2\0029\8\5\8'\
\6\0+\11\2\0B\8\3\0029\9\17\8'\11\18\0B\9\2\0023\
\19\0009\11\20\7'\13\21\0B\11\2\0029\12\20\7'\14\22\0B\12\2\0029\13\20\7'\15\23\0004\16\0\0B\13\3\0023\14\24\0003\15\25\0003\16\26\0009\17\20\7'\19\27\0B\17\2\2:\18\0\17=\14\28\18:\18\0\17=\15\29\18:\18\0\17=\16\30\18:\18\0\17)\19Ä\7=\19\31\18:\18\0\17)\0198\4=\19 \18:\18\0\17'\19\"\0=\19!\18:\18\0\0179\18#\18+\19\2\0=\19$\18:\18\0\0179\18%\0189\19'\3=\19&\0189\18(\1\18\20\17\0B\18\2\0016\18)\0009\20*\0066\22\0\0B\20\2\0A\18\0\0012\0\0ÄK\0\1\0\
tdump\
print\13sapp_run\14slog_func\9func\11logger\18sokol_default\9icon\21Cube (sokol-app)\17window_title\11height\
width\15cleanup_cb\13frame_cb\12init_cb\17sapp_desc[1]\0\0\0\19sg_bindings[1]\16sg_range[1]\13state[1]\8new\0\29./samples/cube-sapp.glsl\12compile\22tools.shc_compile{/* application state */\
typedef struct state {\
    float rx, ry;\
    sg_pipeline pip;\
    sg_bindings* bind;\
} state;\
\9cdef\8ffi\
utils\14hmm_utils\8hmm\15sokol_libs\14sokol_gfx\14sokol_app\18sokol%-luajit\9init\19tools.dirtools\12require\14;../?.lua\9path\12package\3\3\3\3\3\3\4\4\4\4\4\4\7\7\7\8\8\8\9\9\9\
\
\
\11\11\11\13\13\13\15\15\15\19\26\26\30\30\30\30\30\30\30\31\31\31&***+++,,,,\127´±µµµ∂∂∑∑∏∏πππ∫∫∫ªªªººººΩΩΩΩøøø√√√√√√√dirtools\0\13Tsapp\0\3Qsg\0\3Nslib\0\3Khmm\0\3Hhutils\0\3Eutils\0\3Bffi\0\3?shc\0\
5shader\0\0032logout\0\0011state\0\3.sg_range\0\3+binding\0\4'init\0\1&frame\0\1%cleanup\0\1$app_desc\0\3!\0\0")(...);ﬁî	   $M œ6   9  6 ' B= 6 ' B= 6 ' B= 6 '
 B=	 6 ' B= 6 ' B= 6 ' B= 6 ' BG  A K  Ü'LJ@@F:\dev\luajit\Thunc\sokol-luajit\examples\samples\cube_sapp.lua¬   [#6  '	 B6  	  '
  '  '  '  '  &		BK   -------->>> 
printtag  log_level  log_item  message  line_nr  filename  user_data   Ÿ  4 ùô.Q-   9   ' B :  - 9B=:  9- 9=:  + =- 9  B6	 '
 6 - 9B A &B-  9 ' 5 B-  9 ' B: 9=: 9-  9 B=: ' =- 9 B-  9 ' 5 B-  9 ' 4  B: - 9=: 9=: 9-  9	 B=: ' =- 9 B- 9-	 B-  9 '
 4  B:	 9		9		:	 	)
 =
 	:	 9		9	!	:	 	-
 9
#
=
"	:	 9		9	!	:		-
 9
$
=
"	:	 =%	:	 -
 9
'
=
&	:	 -
 9
)
=
(	:	 9	*	+
 =
+	:	 9	*	-
 9
-
=
,	:	 '
. =
	-	 :	 	-
 9
0
 B
=
/	-	 :	 	9	1	> 	-	 :	 	=2	-	 :	 	-
 =
3	K  ¿¿¿	¿¿¿	bindindex_buffervertex_bufferssg_make_pipelinepipcube-pipelineSG_COMPAREFUNC_LESS_EQUALcomparewrite_enabled
depthSG_CULLMODE_BACKcull_modeSG_INDEXTYPE_UINT16index_typeshaderSG_VERTEXFORMAT_FLOAT4SG_VERTEXFORMAT_FLOAT3format
attrsstridebufferslayoutsg_pipeline_desc[1]sg_make_shadercube-indicesSG_BUFFERTYPE_INDEXBUFFER	type%    	

uint16_t[36]sg_make_buffercube-vertices
labelsizeof	sizeptr	datasg_buffer_desc[1]©  ˇˇˇˇˇˇˇˇˇˇˇˇ  ˇˇˇˇˇˇˇˇ  ˇˇˇˇ  ˇˇˇˇˇˇˇˇ  ˇˇˇˇˇˇˇˇ  ˇˇˇˇ    ˇˇˇˇ  ˇˇˇˇˇˇˇˇˇˇˇˇ  ˇˇˇˇˇˇˇˇ  ˇˇˇˇ  ˇˇˇˇˇˇˇˇ  ˇˇˇˇˇˇˇˇ ÄÄÄˇ ˇˇˇˇ ÄÄÄˇ  ÄÄÄˇ ˇˇˇˇ ÄÄÄˇ ˇˇˇˇˇˇˇˇˇˇˇˇ  ÄÄÄˇˇˇˇˇˇˇˇˇ  ÄÄÄˇˇˇˇˇ  ÄÄÄˇˇˇˇˇˇˇˇˇ  ÄÄÄˇˇˇˇˇˇˇˇˇ  ÄÄÄˇˇˇˇˇ  ÄÄÄˇ  ÄÄÄˇˇˇˇˇ  ÄÄÄˇfloat[168]sg_isvalidtostringSokol Is Valid: 
printsg_setupdisable_validationslog_func	funcloggersglue_environmentenvironmentsg_desc[1]new					))))***+++++++,,,----/////888889999:::;;;;;;;<<<====????AAAAABBBBBBCCCCCCCDDDDDDDEEFFFFGGGGHHHHIIIIIJJJKKKKKKKMMMMNNNOOOOQffi slib sg shader state binding desc ôvertices zbuffer_desc vvbuf eindices `ibuffer_desc [ibuf Fshd Bpipe_desc = ˇ
  #ß§É(-   9   B -  9B-  9B - 9)< # * )
 B- 9- 9)  *	 )
 B- 9)	  )
  )  B- 9)
  ) )  B A- 9  B- : - : 9 =- : - : 9 =- 9	- : 9-	 9		) )  )  B	 A- 9	-	 :	 	9		-
 9

)  ) )  B
 A- 9
  B-	 9		  B	-
 9


' B
: 
99: - 9=: 
99: 5 =: 
- 9B=- 9
 B- 9- : 9B- 9- : 9B- 9
' B: =	- : =- : - 9: B=- 9- 9)  - B- 9 )  )$ ) B- 9!B- 9"BK  ¿¿¿¿¿¿¿sg_commitsg_end_passsg_drawSG_SHADERSTAGE_VSsg_apply_uniformssizeof	sizeptrmvpvs_params_t[1]	bindsg_apply_bindingspipsg_apply_pipelinesg_begin_passsglue_swapchainswapchain   ÄÄ¿˛ ÄÄÄˇ ÄÄ†ˇclear_valueSG_LOADACTION_CLEARload_actioncolorsactionsg_pass[1]newHMM_RotateryrxHMM_MultiplyMat4HMM_Vec3HMM_LookAtHMM_Perspectivesapp_frame_durationsapp_heightfsapp_widthfx˜—˙·ıë¸ÄÄ‡ˇ					







       """"""###$$$(sapp hmm state ffi sg slib sg_range w §h °t ùproj ñview Åview_proj |rxm `rym Tmodel Omvp Jpass Fvs_params &  1   Ø-   9   B K  ¿sg_shutdownsg  Ê  + `ı √6   6  9' &= 6  ' B 9  ' B 6 ' B6 ' B6 '	 B6 '
 B6 ' B6 ' B6 '	 B9'
 B6 '
 B9'
 + B9	' B	3
 9' B9' B9' 4  B3 3 3 9' B: =: =: =: )Ä=: )8= : '" =!: 9#+ =$: 9%9'=&9( B6) 9*6  B A 2  ÄK  
tdump
printsapp_runslog_func	funcloggersokol_default	iconCube (sokol-app)window_titleheight
widthcleanup_cbframe_cbinit_cbsapp_desc[1]   sg_bindings[1]sg_range[1]state[1]new ./samples/cube-sapp.glslcompiletools.shc_compile{/* application state */
typedef struct state {
    float rx, ry;
    sg_pipeline pip;
    sg_bindings* bind;
} state;
	cdefffi
utilshmm_utilshmmsokol_libssokol_gfxsokol_appsokol%-luajit	inittools.dirtoolsrequire;../?.lua	pathpackage			


&***+++,,,,´±µµµ∂∂∑∑∏∏πππ∫∫∫ªªªººººΩΩΩΩøøø√√√√√√√dirtools Tsapp Qsg Nslib Khmm Hhutils Eutils Bffi ?shc 
5shader 2logout 1state .sg_range +binding 'init &frame %cleanup $app_desc !  ∏6LJ"F:.devjit.Thunc.sokol-luajit.utilsM  	  
 6   '  96 ) ) B A C   m	byteaeiouyc           -     6   6 )a )z B C   mc       Ó  "#6   9  ' 97 7  '    9  )	 B   9  '	 3
 B   9  ' 3 B 7  6  9  6 ) 6  9) B B 2  ÄL  substring	name .- .	gsubrep mc	charrandom	math
 k 	 *)     XÄL 6    BHÄ FR˝L 
pairstbl  cnt   k v   ¯  *4 4 6  9  )ˇ B >6  96  9  ) B)ˇ B >6  96  9  ) B)ˇ B >6  96  9  ) B)ˇ B >L rshift	bandbit˛ucolor  + û  Ny,4    9  ) ) B6 9' )â )P )N )	G )
 )
 ) )
 B
 X8Ä-  9'   )	 B-  9'   ) B=-  9'   ) B=-  9'
   ) B=	-  9'
   ) B=-  9'
   ) B=-  9'
   ) B=-  9'
   ) B=L +  L ¿interlacefilter	comp	type>B
depthheight>I
width<Lunpack%c%c%c%c%c%c%c%cformatstringsub							






struct header  Opnginfo Mfilesig Htmp 2 »  "[?6  9  ' B  XÄ6 '   &B+  L  9) B 9B-   B  XÄL 6 '   &B+  L 	¿$[Error] Png header unreadable: 
close	read![Error] png file not found: 
printrb	openio			


processPngHeader filenamepath  #fh header pnginfo 
 ﬁ    <Q   XÄ4     XÄL  6   BHÄ6 	 B XÄ6 8	  	 X
Ä+	 B XÄ6 8	 8
BXÄ< FRÎL  tmerge
table	type
pairst1  !t2  !
  k v   › D|a XÄ) 	  XÄ4  .  6    B X1Ä' 6   BH Ä6	   B		 X	Ä'	 6
  B
' &	-	  8			  X	Ä-	  +
 <
		 6
 9

'	  B
'
  ' -  B&	FRﬁ 6 9'	 B' &L XÄ6   B' &L K  Ä¿
}
	] = [  repstringtostring"number
pairs {

table	type 														visited tdump o  Elevel  Elevel As 
/# # #k  v    º Bmu'  ) 6   BH6Ä  XÄ '	 &	6 
 B XÄ '	 6
  B
' -   B&X Ä6 
 B XÄ '	 6
  B
'	 6  B&XÄ6 
 B
 XÄ '	 6
  B
' 6  B' & FR» ' &L ¿ }function":number":"tostring"
table	type,
pairs{					










tablejson list  Cp Ai @9 9 9k 6v  6 ˚   @é6    B XÄL  6   B4  6   BH
Ä6  
 B XÄ6 
 B <FRÙ6   BL setmetatabledeepcopy
pairsgetmetatable
table	type



t   mt 
res   k 
v  
 Ó   2û+  6  9  ' B6   B  X	Ä 9' B  9BXÄ6 '   &BL .[Error] utils.loaddata: Unable to load - 
close*a	read
printrb	openio
filepath  data fh  ï   ,≠
9    XÄK  9  9  9!=9  9)   XÄ9  )  = BK  timeout
round
self  dt  callback   Û   (/ª   XÄL  6  9  ) ) B XÄ6  9  ) )ˇˇB  6  9  )ˇˇB XÄ6  9  ) )˛ˇB  6  9  ' ' B  L   	%%20	gsub'substringstr  ) Æ  :Ã4  )   9  '  '	 &	BX	Ä XÄ XÄ8  X	Ä <ERıL ]*)([^gmatchstr  sep  ret n   w 	 Ì 	 	 1‹	+  6  9' 6   B' &B  XÄ 9' B XÄ6 ' 6   B&BL [Error] failed to read - 
print*a	read"tostringdir /AD /b "
popeniofolder  result f 	 ˆ 	 	 1È	+  6  9' 6   B' &B  XÄ 9' B XÄ6 ' 6   B&BL [Error] failed to read - 
print*a	read"tostringls -d -A -G -N -1 * "
popeniofolder  result f 	 Ô  Xˆ'  -  9 XÄXÄ-  9 XÄ-   B XÄ-   B +    XÄ-  ' B L ¿¿¿¿
Windows
HTML5osffi windows_dir unix_dir csplit folder  dirstr restbl  Û  $?ã
6  9   B  )  ) ) MÄ6  9  )	 B	  XÄ6  9  )	 B  X
Ä6  96  9
  ) B*	 B  OÁL  rshift	band	bxorbit ÇÄ	sum  %data  %
  i  ´ Cô*  +  )  ) MÄ6  9
   B -  
  B OÙL ¿	bytestring˛ˇByteCRC data  length  sum d   i  Ê   8=•6    B X#Ä6 9  ' ' B  6 96 9  ' ' B' B  XÄ'	   '	 &L '
 6 9  '
 ' B'
 &L XÄ6    B XÄ6 9  B  XÄ6   BL K  tostring
table\""'	^"+$
[^'"]
match\n
	gsubstring	type				v  9 ∫   ≤6    B X	Ä6 9  ' B  XÄL  XÄ' 6 9  B' &L K  ]val_to_str
table[^[_%a][_%a%d]*$
matchstring	typek   ˝   2k∫4  4  6    BX
Ä6 9
 6 9 B A+ <ERÙ6   BHÄ8  XÄ6 9
 6 9 B' 6 9 B&BFRÌ' 6 9 '	 B'
 &L },concat{=key_to_str
pairsval_to_strinsert
tableipairs										tbl  3result 0done  0  k 
v  
  k v   â  0 A˜ „6   9  6  96  96 ' B6 ' B6 ' B3 3	 3
 3	 3
 3 7 4  3 3 3 7 3 3 3 3 3 3 3 3 3 6  3 =6  3 =6  3! = 5" =#=$=%=&=
'=	(=)=*=+6 ==,=-6 ==.=/2  ÄL loaddatatickroundtablejson
tdumptcountgennamecrcgetpngheadergetpngfileuinttocolorcleanstringcsplitgetdirs uinttocolor genname tmerge tickround tcount crc getpngheader loaddata getpngfile csplit getdirs deepcopy tablejson cleanstring 
tdump  tostring key_to_str val_to_str         deepcopy   tmerge      
tweenstructffirequire	getnremoveinsert
table            	 	 	   ( ; M ] Q ` q à ö é © ∑ » ÿ Â Ú !%0%282:G:JLMNPQRTVWXXYZ\\^`aatinsert ?tremove =tcount ;ffi 8struct 5tween 2genname 1tcount 0uinttocolor /processPngHeader .getpngfile -visited *tdump )tablejson (loaddata %tickround $cleanstring #csplit "windows_dir !unix_dir  getdirs ByteCRC CRC   'F:.devjit.Thunc.sokol-luajit.utilsπLJ0F:.devjit.Thunc.sokol-luajit.ffi.sokol.hmm_utilsÛ   TY6  ' B6  ' 9 : : ' 9 : :' 9 : :'	 9
 :
 
:

' &B6  ' 9 :: ' 9 ::' 9 ::'	 9
 :

:

' &B6  ' 9 :: ' 9 ::' 9 ::'	 9
 :

:

' &B6  ' 9 :: ' 9 ::' 9 ::'	 9
 :

:

' &BK  Row 3: Row 2: Row 1:  ElementsRow 0: ----- hmm_mat4
printm  U y 	  6  ' B6  ' 9 ' 9 ' 9 &BK  Z	 Z: Y	 Y: XX: ----- hmm_vec3
printv   ä  
 6  ' B6  ' 9 ' 9 ' 9 '	 9
	 &
BK  W	 W: Z	 Z: Y	 Y: XX: ----- hmm_vec4
printv   √  	 Rt-   9   B   X Ä-   9  B -   9  B ' ' 9 )  XÄ6 9' B6 9 '	 9 '
 &B6 9 ' 9 '
 &B6 9' 9 '
 &B6 9' 9 '
 &B6 9' 9 '
 &B6 9' 9 '
 &B6 9' 9 9'
 &B6 9' 9 9'
 &BK   ¿num_bind_samplernum_bind_sampler: num_bind_bufferglnum_bind_buffer: size_apply_uniformssize_apply_uniforms: num_apply_uniformsnum_apply_uniforms: num_apply_bindingsnum_apply_bindings: num_apply_pipelinenum_apply_pipeline: num_passesnum_passes: 
frame_index: 	[8A
writeioframe_index
[37m
[31msg_query_frame_statssg_enable_frame_statssg_frame_stats_enabled								






sg stats Gredtext Fwhitetext E ª   $ ,6   9     XÄ6  ' B 4  3 =3 =3	 =3 =
2  ÄL  show_stats dump_vec4 dump_vec3 dump_mat4sokol_gfxrequiresg_G**,,sg hmm_utils 
  5F:.devjit.Thunc.sokol-luajit.ffi.sokol.hmm_utilsˆ9LJ*F:.devjit.Thunc.sokol-luajit.ffi.sokol.hmmæ9   !` ≥6   ' B 6   XÄ5 5 =5 =5 =	5
 =5 =5 =6   XÄ9 89 89  B9 ' BL ‚5
/********** hmm_lib ****************************************************************/

typedef union hmm_vec2
{
    struct
    {
        float x, y;
    };

    struct
    {
        float X, Y;
    };

    struct
    {
        float U, V;
    };

    struct
    {
        float Left, Right;
    };
    
    struct
    {
        float Width, Height;
    };

    float Elements[2];
} hmm_vec2;

typedef union hmm_vec3
{
    struct
    {
        float x, y, z;
    };

    struct
    {
        float X, Y, Z;
    };

    struct
    {
        float U, V, W;
    };

    struct
    {
        float R, G, B;
    };

    struct
    {
        hmm_vec2 XY;
        float Ignored0_;
    };

    struct
    {
        float Ignored1_;
        hmm_vec2 YZ;
    };

    struct
    {
        hmm_vec2 UV;
        float Ignored2_;
    };

    struct
    {
        float Ignored3_;
        hmm_vec2 VW;
    };

    float Elements[3];
} hmm_vec3;

typedef union hmm_vec4
{
    struct
    {
        union
        {
            hmm_vec3 XYZ;
            struct
            {
                float X, Y, Z;
            };
            struct
            {
                float x, y, z;
            };        
        };

        float W;
    };
    struct
    {
        union
        {
            hmm_vec3 RGB;
            struct
            {
                float R, G, B;
            };
            struct
            {
                float x, y, z;
            };        
        };

        float A;
    };

    struct
    {
        hmm_vec2 XY;
        float Ignored0_;
        float Ignored1_;
    };

    struct
    {
        float Ignored2_;
        hmm_vec2 YZ;
        float Ignored3_;
    };

    struct
    {
        float Ignored4_;
        float Ignored5_;
        hmm_vec2 ZW;
    };

    float Elements[4];
} hmm_vec4;

typedef union hmm_mat4
{
    float Elements[4][4];

} hmm_mat4;

typedef union hmm_quaternion
{
    struct
    {
        union
        {
            hmm_vec3 XYZ;
            struct
            {
                float X, Y, Z;
            };
            struct
            {
                float x, y, z;
            };        
        };
        
        union
        {
            float W;
            float w;
        };
    };
    
    float Elements[4];
} hmm_quaternion;

typedef int32_t hmm_bool;

typedef hmm_vec2 hmm_v2;
typedef hmm_vec3 hmm_v3;
typedef hmm_vec4 hmm_v4;
typedef hmm_mat4 hmm_m4;    

float HMM_SinF(float Angle);
float HMM_TanF(float Angle);
float HMM_ATanF(float Theta);
float HMM_ATan2F(float Theta, float Theta2);
float HMM_CosF(float Angle);
float HMM_ACosF(float Theta);
float HMM_ExpF(float Float);
float HMM_LogF(float Float);

float HMM_ToRadians(float Degrees);
float HMM_SquareRootF(float Float);
float HMM_RSquareRootF(float Float);

float HMM_LengthSquaredVec2(hmm_vec2 A);
float HMM_LengthSquaredVec3(hmm_vec3 A);
float HMM_LengthSquaredVec4(hmm_vec4 A);

float HMM_LengthVec2(hmm_vec2 A);    
float HMM_LengthVec3(hmm_vec3 A);    
float HMM_LengthVec4(hmm_vec4 A);    

float HMM_Power(float Base, int Exponent);
float HMM_PowerF(float Base, float Exponent);
float HMM_Lerp(float A, float Time, float B);
float HMM_Clamp(float Min, float Value, float Max);

hmm_vec2 HMM_NormalizeVec2(hmm_vec2 A);
hmm_vec3 HMM_NormalizeVec3(hmm_vec3 A);
hmm_vec4 HMM_NormalizeVec4(hmm_vec4 A);

float HMM_DotVec2(hmm_vec2 VecOne, hmm_vec2 VecTwo);
float HMM_DotVec3(hmm_vec3 VecOne, hmm_vec3 VecTwo);
float HMM_DotVec4(hmm_vec4 VecOne, hmm_vec4 VecTwo);

hmm_vec3 HMM_Cross(hmm_vec3 VecOne, hmm_vec3 VecTwo);

hmm_vec2 HMM_Vec2(float X, float Y);
hmm_vec2 HMM_Vec2i(int X, int Y);
hmm_vec3 HMM_Vec3(float X, float Y, float Z);
hmm_vec3 HMM_Vec3i(int X, int Y, int Z);
hmm_vec4 HMM_Vec4(float X, float Y, float Z, float W);
hmm_vec4 HMM_Vec4i(int X, int Y, int Z, int W);
hmm_vec4 HMM_Vec4v(hmm_vec3 Vector, float W);

hmm_vec2 HMM_AddVec2(hmm_vec2 Left, hmm_vec2 Right);
hmm_vec3 HMM_AddVec3(hmm_vec3 Left, hmm_vec3 Right);
hmm_vec4 HMM_AddVec4(hmm_vec4 Left, hmm_vec4 Right);

hmm_vec2 HMM_SubtractVec2(hmm_vec2 Left, hmm_vec2 Right);
hmm_vec3 HMM_SubtractVec3(hmm_vec3 Left, hmm_vec3 Right);
hmm_vec4 HMM_SubtractVec4(hmm_vec4 Left, hmm_vec4 Right);

hmm_vec2 HMM_MultiplyVec2(hmm_vec2 Left, hmm_vec2 Right);
hmm_vec2 HMM_MultiplyVec2f(hmm_vec2 Left, float Right);
hmm_vec3 HMM_MultiplyVec3(hmm_vec3 Left, hmm_vec3 Right);
hmm_vec3 HMM_MultiplyVec3f(hmm_vec3 Left, float Right);
hmm_vec4 HMM_MultiplyVec4(hmm_vec4 Left, hmm_vec4 Right);
hmm_vec4 HMM_MultiplyVec4f(hmm_vec4 Left, float Right);

hmm_vec2 HMM_DivideVec2(hmm_vec2 Left, hmm_vec2 Right);
hmm_vec2 HMM_DivideVec2f(hmm_vec2 Left, float Right);
hmm_vec3 HMM_DivideVec3(hmm_vec3 Left, hmm_vec3 Right);
hmm_vec3 HMM_DivideVec3f(hmm_vec3 Left, float Right);
hmm_vec4 HMM_DivideVec4(hmm_vec4 Left, hmm_vec4 Right);
hmm_vec4 HMM_DivideVec4f(hmm_vec4 Left, float Right);

hmm_bool HMM_EqualsVec2(hmm_vec2 Left, hmm_vec2 Right);
hmm_bool HMM_EqualsVec3(hmm_vec3 Left, hmm_vec3 Right);
hmm_bool HMM_EqualsVec4(hmm_vec4 Left, hmm_vec4 Right);

hmm_mat4 HMM_Mat4(void);
hmm_mat4 HMM_Mat4d(float Diagonal);
hmm_mat4 HMM_AddMat4(hmm_mat4 Left, hmm_mat4 Right);
hmm_mat4 HMM_SubtractMat4(hmm_mat4 Left, hmm_mat4 Right);

hmm_mat4 HMM_MultiplyMat4(hmm_mat4 Left, hmm_mat4 Right);
hmm_mat4 HMM_MultiplyMat4f(hmm_mat4 Matrix, float Scalar);
hmm_vec4 HMM_MultiplyMat4ByVec4(hmm_mat4 Matrix, hmm_vec4 Vector);
hmm_mat4 HMM_DivideMat4f(hmm_mat4 Matrix, float Scalar);

hmm_mat4 HMM_Transpose(hmm_mat4 Matrix);

hmm_mat4 HMM_Orthographic(float Left, float Right, float Bottom, float Top, float Near, float Far);
hmm_mat4 HMM_Perspective(float FOV, float AspectRatio, float Near, float Far);

hmm_mat4 HMM_Translate(hmm_vec3 Translation);
hmm_mat4 HMM_Rotate(float Angle, hmm_vec3 Axis);
hmm_mat4 HMM_Scale(hmm_vec3 Scale);

hmm_mat4 HMM_LookAt(hmm_vec3 Eye, hmm_vec3 Center, hmm_vec3 Up);

hmm_quaternion HMM_Quaternion(float X, float Y, float Z, float W);
hmm_quaternion HMM_QuaternionV4(hmm_vec4 Vector);
hmm_quaternion HMM_AddQuaternion(hmm_quaternion Left, hmm_quaternion Right);
hmm_quaternion HMM_SubtractQuaternion(hmm_quaternion Left, hmm_quaternion Right);
hmm_quaternion HMM_MultiplyQuaternion(hmm_quaternion Left, hmm_quaternion Right);
hmm_quaternion HMM_MultiplyQuaternionF(hmm_quaternion Left, float Multiplicative);
hmm_quaternion HMM_DivideQuaternionF(hmm_quaternion Left, float Dividend);
hmm_quaternion HMM_InverseQuaternion(hmm_quaternion Left);
float HMM_DotQuaternion(hmm_quaternion Left, hmm_quaternion Right);
hmm_quaternion HMM_NormalizeQuaternion(hmm_quaternion Left);
hmm_quaternion HMM_NLerp(hmm_quaternion Left, float Time, hmm_quaternion Right);
hmm_quaternion HMM_Slerp(hmm_quaternion Left, float Time, hmm_quaternion Right);
hmm_mat4 HMM_QuaternionToMat4(hmm_quaternion Left);
hmm_quaternion HMM_QuaternionFromAxisAngle(hmm_vec3 Axis, float AngleOfRotation);

	cdef	load	archos
Other x64hmm_dll.so
POSIX x64hmm_dll.soBSD x64hmm_dll.so
Linux armhmm_dll.sox64hmm_dll.soWindows x64hmm_dll.dllOSX Windows BSD 
Linux 
Other 
POSIX OSX  x64hmm_dllffi_hmm_dllffirequire                 	 	            113ffi libs lib hmm_lib   /F:.devjit.Thunc.sokol-luajit.ffi.sokol.hmm∫eLJ1F:.devjit.Thunc.sokol-luajit.ffi.sokol.sokol_libs˚d   B∂ §6   ' B 6 9  XÄ' 6   X)Ä5	 5  ' &==
5  ' &==5  ' &= ' &==5  ' &==5  ' &==5  ' &==6   XÄ9 89 89  B9 ' BL ›_
/********** sokol_args ****************************************************************/

/*
    sargs_allocator

    Used in sargs_desc to provide custom memory-alloc and -free functions
    to sokol_args.h. If memory management should be overridden, both the
    alloc_fn and free_fn function must be provided (e.g. it's not valid to
    override one function but not the other).
*/
typedef struct sargs_allocator {
   void* (*alloc_fn)(size_t size, void* user_data);
   void (*free_fn)(void* ptr, void* user_data);
   void* user_data;
} sargs_allocator;

typedef struct sargs_desc {
   int argc;
   char** argv;
   int max_args;
   int buf_size;
   sargs_allocator allocator;
} sargs_desc;

/* setup sokol-args */
void sargs_setup(const sargs_desc* desc);
/* shutdown sokol-args */
void sargs_shutdown(void);
/* true between sargs_setup() and sargs_shutdown() */
bool sargs_isvalid(void);
/* test if an argument exists by key name */
bool sargs_exists(const char* key);
/* get value by key name, return empty string if key doesn't exist or an existing key has no value */
const char* sargs_value(const char* key);
/* get value by key name, return provided default if key doesn't exist or has no value */
const char* sargs_value_def(const char* key, const char* def);
/* return true if val arg matches the value associated with key */
bool sargs_equals(const char* key, const char* val);
/* return true if key's value is "true", "yes", "on" or an existing key has no value */
bool sargs_boolean(const char* key);
/* get index of arg by key name, return -1 if not exists */
int sargs_find(const char* key);
/* get number of parsed arguments */
int sargs_num_args(void);
/* get key name of argument at index, or empty string */
const char* sargs_key_at(int index);
/* get value string of argument at index, or empty string */
const char* sargs_value_at(int index);

/********** sokol_audio ****************************************************************/

/*
    saudio_logger

    Used in saudio_desc to provide a custom logging and error reporting
    callback to sokol-audio.
*/
typedef struct saudio_logger {
   void (*func)(
       const char* tag,                // always "saudio"
       uint32_t log_level,             // 0=panic, 1=error, 2=warning, 3=info
       uint32_t log_item_id,           // SAUDIO_LOGITEM_*
       const char* message_or_null,    // a message string, may be nullptr in release mode
       uint32_t line_nr,               // line number in sokol_audio.h
       const char* filename_or_null,   // source filename, may be nullptr in release mode
       void* user_data);
   void* user_data;
} saudio_logger;

/*
   saudio_allocator

   Used in saudio_desc to provide custom memory-alloc and -free functions
   to sokol_audio.h. If memory management should be overridden, both the
   alloc_fn and free_fn function must be provided (e.g. it's not valid to
   override one function but not the other).
*/
typedef struct saudio_allocator {
   void* (*alloc_fn)(size_t size, void* user_data);
   void (*free_fn)(void* ptr, void* user_data);
   void* user_data;
} saudio_allocator;

typedef struct saudio_desc {
   int sample_rate;        // requested sample rate
   int num_channels;       // number of channels, default: 1 (mono)
   int buffer_frames;      // number of frames in streaming buffer
   int packet_frames;      // number of frames in a packet
   int num_packets;        // number of packets in packet queue
   void (*stream_cb)(float* buffer, int num_frames, int num_channels);  // optional streaming callback (no user data)
   void (*stream_userdata_cb)(float* buffer, int num_frames, int num_channels, void* user_data); //... and with user data
   void* user_data;        // optional user data argument for stream_userdata_cb
   saudio_allocator allocator;     // optional allocation override functions
   saudio_logger logger;           // optional logging function (default: NO LOGGING!)
} saudio_desc;

/* setup sokol-audio */
void saudio_setup(const saudio_desc* desc);
/* shutdown sokol-audio */
void saudio_shutdown(void);
/* true after setup if audio backend was successfully initialized */
bool saudio_isvalid(void);
/* return the saudio_desc.user_data pointer */
void* saudio_userdata(void);
/* return a copy of the original saudio_desc struct */
saudio_desc saudio_query_desc(void);
/* actual sample rate */
int saudio_sample_rate(void);
/* return actual backend buffer size in number of frames */
int saudio_buffer_frames(void);
/* actual number of channels */
int saudio_channels(void);
/* return true if audio context is currently suspended (only in WebAudio backend, all other backends return false) */
bool saudio_suspended(void);
/* get current number of frames to fill packet queue */
int saudio_expect(void);
/* push sample frames from main thread, returns number of frames actually pushed */
int saudio_push(const float* frames, int num_frames);

/********** sokol_fetch ****************************************************************/


/*
    sfetch_logger_t

    Used in sfetch_desc_t to provide a custom logging and error reporting
    callback to sokol-fetch.
*/
typedef struct sfetch_logger_t {
   void (*func)(
       const char* tag,                // always "sfetch"
       uint32_t log_level,             // 0=panic, 1=error, 2=warning, 3=info
       uint32_t log_item_id,           // SFETCH_LOGITEM_*
       const char* message_or_null,    // a message string, may be nullptr in release mode
       uint32_t line_nr,               // line number in sokol_fetch.h
       const char* filename_or_null,   // source filename, may be nullptr in release mode
       void* user_data);
   void* user_data;
} sfetch_logger_t;

/*
   sfetch_range_t

   A pointer-size pair struct to pass memory ranges into and out of sokol-fetch.
   When initialized from a value type (array or struct) you can use the
   SFETCH_RANGE() helper macro to build an sfetch_range_t struct.
*/
typedef struct sfetch_range_t {
   const void* ptr;
   size_t size;
} sfetch_range_t;

/*
   sfetch_allocator_t

   Used in sfetch_desc_t to provide custom memory-alloc and -free functions
   to sokol_fetch.h. If memory management should be overridden, both the
   alloc and free function must be provided (e.g. it's not valid to
   override one function but not the other).
*/
typedef struct sfetch_allocator_t {
   void* (*alloc_fn)(size_t size, void* user_data);
   void (*free_fn)(void* ptr, void* user_data);
   void* user_data;
} sfetch_allocator_t;

/* configuration values for sfetch_setup() */
typedef struct sfetch_desc_t {
   uint32_t max_requests;          // max number of active requests across all channels (default: 128)
   uint32_t num_channels;          // number of channels to fetch requests in parallel (default: 1)
   uint32_t num_lanes;             // max number of requests active on the same channel (default: 1)
   sfetch_allocator_t allocator;   // optional memory allocation overrides (default: malloc/free)
   sfetch_logger_t logger;         // optional log function overrides (default: NO LOGGING!)
} sfetch_desc_t;

/* a request handle to identify an active fetch request, returned by sfetch_send() */
typedef struct sfetch_handle_t { uint32_t id; } sfetch_handle_t;

/* error codes */
typedef enum sfetch_error_t {
   SFETCH_ERROR_NO_ERROR,
   SFETCH_ERROR_FILE_NOT_FOUND,
   SFETCH_ERROR_NO_BUFFER,
   SFETCH_ERROR_BUFFER_TOO_SMALL,
   SFETCH_ERROR_UNEXPECTED_EOF,
   SFETCH_ERROR_INVALID_HTTP_STATUS,
   SFETCH_ERROR_CANCELLED
} sfetch_error_t;

/* the response struct passed to the response callback */
typedef struct sfetch_response_t {
   sfetch_handle_t handle;         // request handle this response belongs to
   bool dispatched;                // true when request is in DISPATCHED state (lane has been assigned)
   bool fetched;                   // true when request is in FETCHED state (fetched data is available)
   bool paused;                    // request is currently in paused state
   bool finished;                  // this is the last response for this request
   bool failed;                    // request has failed (always set together with 'finished')
   bool cancelled;                 // request was cancelled (always set together with 'finished')
   sfetch_error_t error_code;      // more detailed error code when failed is true
   uint32_t channel;               // the channel which processes this request
   uint32_t lane;                  // the lane this request occupies on its channel
   const char* path;               // the original filesystem path of the request
   void* user_data;                // pointer to read/write user-data area
   uint32_t data_offset;           // current offset of fetched data chunk in the overall file data
   sfetch_range_t data;            // the fetched data as ptr/size pair (data.ptr == buffer.ptr, data.size <= buffer.size)
   sfetch_range_t buffer;          // the user-provided buffer which holds the fetched data
} sfetch_response_t;

/* request parameters passed to sfetch_send() */
typedef struct sfetch_request_t {
   uint32_t channel;                                // index of channel this request is assigned to (default: 0)
   const char* path;                                // filesystem path or HTTP URL (required)
   void (*callback) (const sfetch_response_t*);     // response callback function pointer (required)
   uint32_t chunk_size;                             // number of bytes to load per stream-block (optional)
   sfetch_range_t buffer;                           // a memory buffer where the data will be loaded into (optional)
   sfetch_range_t user_data;                        // ptr/size of a POD user data block which will be memcpy'd (optional)
} sfetch_request_t;


/* setup sokol-fetch (can be called on multiple threads) */
void sfetch_setup(const sfetch_desc_t* desc);
/* discard a sokol-fetch context */
void sfetch_shutdown(void);
/* return true if sokol-fetch has been setup */
bool sfetch_valid(void);
/* get the desc struct that was passed to sfetch_setup() */
sfetch_desc_t sfetch_desc(void);
/* return the max userdata size in number of bytes (SFETCH_MAX_USERDATA_UINT64 * sizeof(uint64_t)) */
int sfetch_max_userdata_bytes(void);
/* return the value of the SFETCH_MAX_PATH implementation config value */
int sfetch_max_path(void);

/* send a fetch-request, get handle to request back */
sfetch_handle_t sfetch_send(const sfetch_request_t* request);
/* return true if a handle is valid *and* the request is alive */
bool sfetch_handle_valid(sfetch_handle_t h);
/* do per-frame work, moves requests into and out of IO threads, and invokes response-callbacks */
void sfetch_dowork(void);

/* bind a data buffer to a request (request must not currently have a buffer bound, must be called from response callback */
void sfetch_bind_buffer(sfetch_handle_t h, sfetch_range_t buffer);
/* clear the 'buffer binding' of a request, returns previous buffer pointer (can be 0), must be called from response callback */
void* sfetch_unbind_buffer(sfetch_handle_t h);
/* cancel a request that's in flight (will call response callback with .cancelled + .finished) */
void sfetch_cancel(sfetch_handle_t h);
/* pause a request (will call response callback each frame with .paused) */
void sfetch_pause(sfetch_handle_t h);
/* continue a paused request */
void sfetch_continue(sfetch_handle_t h);

/********** sokol_glue ****************************************************************/

sg_environment sglue_environment(void);
sg_swapchain sglue_swapchain(void);

/********** sokol_log ****************************************************************/

void slog_func(const char* tag, uint32_t log_level, uint32_t log_item, const char* message, uint32_t line_nr, const char* filename, void* user_data);

/********** sokol_time ****************************************************************/

void stm_setup(void);
uint64_t stm_now(void);
uint64_t stm_diff(uint64_t new_ticks, uint64_t old_ticks);
uint64_t stm_since(uint64_t start_ticks);
uint64_t stm_laptime(uint64_t* last_time);
uint64_t stm_round_to_common_refresh_rate(uint64_t frame_ticks);
double stm_sec(uint64_t ticks);
double stm_ms(uint64_t ticks);
double stm_us(uint64_t ticks);
double stm_ns(uint64_t ticks);

	cdef	load	archos
Other x64 
POSIX x64 BSD x64 
Linuxarm arm x64 Windows x64 	.dllOSX Windows BSD 
Linux 
Other 
POSIX OSX x64 x64 .soffi_sokol_libssokol_dllSOKOL_DLL_Gffirequire                                        	 	 	 	 	 	 
 
 
 
 
 
            ""$ffi ?sokol_filename :libs ,lib sokol_libs   6F:.devjit.Thunc.sokol-luajit.ffi.sokol.sokol_libs∏çLJ0F:.devjit.Thunc.sokol-luajit.ffi.sokol.sokol_gfx˘å   Bµ ≈6   ' B 6 9  XÄ' 6   X)Ä5	 5  ' &==
5  ' &==5  ' &= ' &==5  ' &==5  ' &==5  ' &==6   XÄ9 89 89  B9 ' BL ‹á
/*
    Resource id typedefs:

    sg_buffer:      vertex- and index-buffers
    sg_image:       images used as textures and render targets
    sg_sampler      sampler object describing how a texture is sampled in a shader
    sg_shader:      vertex- and fragment-shaders and shader interface information
    sg_pipeline:    associated shader and vertex-layouts, and render states
    sg_attachments: a baked collection of render pass attachment images

    Instead of pointers, resource creation functions return a 32-bit
    number which uniquely identifies the resource object.

    The 32-bit resource id is split into a 16-bit pool index in the lower bits,
    and a 16-bit 'generation counter' in the upper bits. The index allows fast
    pool lookups, and combined with the generation-counter it allows to detect
    'dangling accesses' (trying to use an object which no longer exists, and
    its pool slot has been reused for a new object)

    The resource ids are wrapped into a strongly-typed struct so that
    trying to pass an incompatible resource id is a compile error.
*/
typedef struct sg_buffer        { uint32_t id; } sg_buffer;
typedef struct sg_image         { uint32_t id; } sg_image;
typedef struct sg_sampler       { uint32_t id; } sg_sampler;
typedef struct sg_shader        { uint32_t id; } sg_shader;
typedef struct sg_pipeline      { uint32_t id; } sg_pipeline;
typedef struct sg_attachments   { uint32_t id; } sg_attachments;

/*
    sg_range is a pointer-size-pair struct used to pass memory blobs into
    sokol-gfx. When initialized from a value type (array or struct), you can
    use the SG_RANGE() macro to build an sg_range struct. For functions which
    take either a sg_range pointer, or a (C++) sg_range reference, use the
    SG_RANGE_REF macro as a solution which compiles both in C and C++.
*/
typedef struct sg_range {
    const void* ptr;
    size_t size;
} sg_range;

//  various compile-time constants
enum {
    SG_INVALID_ID = 0,
    SG_NUM_SHADER_STAGES = 2,
    SG_NUM_INFLIGHT_FRAMES = 2,
    SG_MAX_COLOR_ATTACHMENTS = 4,
    SG_MAX_VERTEX_BUFFERS = 8,
    SG_MAX_SHADERSTAGE_IMAGES = 12,
    SG_MAX_SHADERSTAGE_SAMPLERS = 8,
    SG_MAX_SHADERSTAGE_IMAGESAMPLERPAIRS = 12,
    SG_MAX_SHADERSTAGE_STORAGEBUFFERS = 8,
    SG_MAX_SHADERSTAGE_UBS = 4,
    SG_MAX_UB_MEMBERS = 16,
    SG_MAX_VERTEX_ATTRIBUTES = 16,
    SG_MAX_MIPMAPS = 16,
    SG_MAX_TEXTUREARRAY_LAYERS = 128
};

/*
    sg_color

    An RGBA color value.
*/
typedef struct sg_color { float r, g, b, a; } sg_color;

/*
    sg_backend

    The active 3D-API backend, use the function sg_query_backend()
    to get the currently active backend.
*/
typedef enum sg_backend {
    SG_BACKEND_GLCORE,
    SG_BACKEND_GLES3,
    SG_BACKEND_D3D11,
    SG_BACKEND_METAL_IOS,
    SG_BACKEND_METAL_MACOS,
    SG_BACKEND_METAL_SIMULATOR,
    SG_BACKEND_WGPU,
    SG_BACKEND_DUMMY,
} sg_backend;

/*
    sg_pixel_format

    sokol_gfx.h basically uses the same pixel formats as WebGPU, since these
    are supported on most newer GPUs.

    A pixelformat name consist of three parts:

        - components (R, RG, RGB or RGBA)
        - bit width per component (8, 16 or 32)
        - component data type:
            - unsigned normalized (no postfix)
            - signed normalized (SN postfix)
            - unsigned integer (UI postfix)
            - signed integer (SI postfix)
            - float (F postfix)

    Not all pixel formats can be used for everything, call sg_query_pixelformat()
    to inspect the capabilities of a given pixelformat. The function returns
    an sg_pixelformat_info struct with the following members:

        - sample: the pixelformat can be sampled as texture at least with
                  nearest filtering
        - filter: the pixelformat can be samples as texture with linear
                  filtering
        - render: the pixelformat can be used for render targets
        - blend:  blending is supported when using the pixelformat for
                  render targets
        - msaa:   multisample-antialiasing is supported when using the
                  pixelformat for render targets
        - depth:  the pixelformat can be used for depth-stencil attachments
        - compressed: this is a block-compressed format
        - bytes_per_pixel: the numbers of bytes in a pixel (0 for compressed formats)

    The default pixel format for texture images is SG_PIXELFORMAT_RGBA8.

    The default pixel format for render target images is platform-dependent
    and taken from the sg_environment struct passed into sg_setup(). Typically
    the default formats are:

        - for the Metal, D3D11 and WebGPU backends: SG_PIXELFORMAT_BGRA8
        - for GL backends: SG_PIXELFORMAT_RGBA8
*/
typedef enum sg_pixel_format {
    _SG_PIXELFORMAT_DEFAULT,    // value 0 reserved for default-init
    SG_PIXELFORMAT_NONE,

    SG_PIXELFORMAT_R8,
    SG_PIXELFORMAT_R8SN,
    SG_PIXELFORMAT_R8UI,
    SG_PIXELFORMAT_R8SI,

    SG_PIXELFORMAT_R16,
    SG_PIXELFORMAT_R16SN,
    SG_PIXELFORMAT_R16UI,
    SG_PIXELFORMAT_R16SI,
    SG_PIXELFORMAT_R16F,
    SG_PIXELFORMAT_RG8,
    SG_PIXELFORMAT_RG8SN,
    SG_PIXELFORMAT_RG8UI,
    SG_PIXELFORMAT_RG8SI,

    SG_PIXELFORMAT_R32UI,
    SG_PIXELFORMAT_R32SI,
    SG_PIXELFORMAT_R32F,
    SG_PIXELFORMAT_RG16,
    SG_PIXELFORMAT_RG16SN,
    SG_PIXELFORMAT_RG16UI,
    SG_PIXELFORMAT_RG16SI,
    SG_PIXELFORMAT_RG16F,
    SG_PIXELFORMAT_RGBA8,
    SG_PIXELFORMAT_SRGB8A8,
    SG_PIXELFORMAT_RGBA8SN,
    SG_PIXELFORMAT_RGBA8UI,
    SG_PIXELFORMAT_RGBA8SI,
    SG_PIXELFORMAT_BGRA8,
    SG_PIXELFORMAT_RGB10A2,
    SG_PIXELFORMAT_RG11B10F,
    SG_PIXELFORMAT_RGB9E5,

    SG_PIXELFORMAT_RG32UI,
    SG_PIXELFORMAT_RG32SI,
    SG_PIXELFORMAT_RG32F,
    SG_PIXELFORMAT_RGBA16,
    SG_PIXELFORMAT_RGBA16SN,
    SG_PIXELFORMAT_RGBA16UI,
    SG_PIXELFORMAT_RGBA16SI,
    SG_PIXELFORMAT_RGBA16F,

    SG_PIXELFORMAT_RGBA32UI,
    SG_PIXELFORMAT_RGBA32SI,
    SG_PIXELFORMAT_RGBA32F,

    // NOTE: when adding/removing pixel formats before DEPTH, also update sokol_app.h/_SAPP_PIXELFORMAT_*
    SG_PIXELFORMAT_DEPTH,
    SG_PIXELFORMAT_DEPTH_STENCIL,

    // NOTE: don't put any new compressed format in front of here
    SG_PIXELFORMAT_BC1_RGBA,
    SG_PIXELFORMAT_BC2_RGBA,
    SG_PIXELFORMAT_BC3_RGBA,
    SG_PIXELFORMAT_BC3_SRGBA,
    SG_PIXELFORMAT_BC4_R,
    SG_PIXELFORMAT_BC4_RSN,
    SG_PIXELFORMAT_BC5_RG,
    SG_PIXELFORMAT_BC5_RGSN,
    SG_PIXELFORMAT_BC6H_RGBF,
    SG_PIXELFORMAT_BC6H_RGBUF,
    SG_PIXELFORMAT_BC7_RGBA,
    SG_PIXELFORMAT_BC7_SRGBA,
    SG_PIXELFORMAT_PVRTC_RGB_2BPP,      // FIXME: deprecated
    SG_PIXELFORMAT_PVRTC_RGB_4BPP,      // FIXME: deprecated
    SG_PIXELFORMAT_PVRTC_RGBA_2BPP,     // FIXME: deprecated
    SG_PIXELFORMAT_PVRTC_RGBA_4BPP,     // FIXME: deprecated
    SG_PIXELFORMAT_ETC2_RGB8,
    SG_PIXELFORMAT_ETC2_SRGB8,
    SG_PIXELFORMAT_ETC2_RGB8A1,
    SG_PIXELFORMAT_ETC2_RGBA8,
    SG_PIXELFORMAT_ETC2_SRGB8A8,
    SG_PIXELFORMAT_EAC_R11,
    SG_PIXELFORMAT_EAC_R11SN,
    SG_PIXELFORMAT_EAC_RG11,
    SG_PIXELFORMAT_EAC_RG11SN,

    SG_PIXELFORMAT_ASTC_4x4_RGBA,
    SG_PIXELFORMAT_ASTC_4x4_SRGBA,

    _SG_PIXELFORMAT_NUM,
    _SG_PIXELFORMAT_FORCE_U32 = 0x7FFFFFFF
} sg_pixel_format;

/*
    Runtime information about a pixel format, returned
    by sg_query_pixelformat().
*/
typedef struct sg_pixelformat_info {
    bool sample;            // pixel format can be sampled in shaders at least with nearest filtering
    bool filter;            // pixel format can be sampled with linear filtering
    bool render;            // pixel format can be used as render target
    bool blend;             // alpha-blending is supported
    bool msaa;              // pixel format can be used as MSAA render target
    bool depth;             // pixel format is a depth format
    bool compressed;        // true if this is a hardware-compressed format
    int bytes_per_pixel;    // NOTE: this is 0 for compressed formats, use sg_query_row_pitch() / sg_query_surface_pitch() as alternative
} sg_pixelformat_info;

/*
    Runtime information about available optional features,
    returned by sg_query_features()
*/
typedef struct sg_features {
    bool origin_top_left;               // framebuffer and texture origin is in top left corner
    bool image_clamp_to_border;         // border color and clamp-to-border UV-wrap mode is supported
    bool mrt_independent_blend_state;   // multiple-render-target rendering can use per-render-target blend state
    bool mrt_independent_write_mask;    // multiple-render-target rendering can use per-render-target color write masks
    bool storage_buffer;                // storage buffers are supported
} sg_features;

/*
    Runtime information about resource limits, returned by sg_query_limit()
*/
typedef struct sg_limits {
    int max_image_size_2d;          // max width/height of SG_IMAGETYPE_2D images
    int max_image_size_cube;        // max width/height of SG_IMAGETYPE_CUBE images
    int max_image_size_3d;          // max width/height/depth of SG_IMAGETYPE_3D images
    int max_image_size_array;       // max width/height of SG_IMAGETYPE_ARRAY images
    int max_image_array_layers;     // max number of layers in SG_IMAGETYPE_ARRAY images
    int max_vertex_attrs;           // max number of vertex attributes, clamped to SG_MAX_VERTEX_ATTRIBUTES
    int gl_max_vertex_uniform_components;    // <= GL_MAX_VERTEX_UNIFORM_COMPONENTS (only on GL backends)
    int gl_max_combined_texture_image_units; // <= GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS (only on GL backends)
} sg_limits;

/*
    sg_resource_state

    The current state of a resource in its resource pool.
    Resources start in the INITIAL state, which means the
    pool slot is unoccupied and can be allocated. When a resource is
    created, first an id is allocated, and the resource pool slot
    is set to state ALLOC. After allocation, the resource is
    initialized, which may result in the VALID or FAILED state. The
    reason why allocation and initialization are separate is because
    some resource types (e.g. buffers and images) might be asynchronously
    initialized by the user application. If a resource which is not
    in the VALID state is attempted to be used for rendering, rendering
    operations will silently be dropped.

    The special INVALID state is returned in sg_query_xxx_state() if no
    resource object exists for the provided resource id.
*/
typedef enum sg_resource_state {
    SG_RESOURCESTATE_INITIAL,
    SG_RESOURCESTATE_ALLOC,
    SG_RESOURCESTATE_VALID,
    SG_RESOURCESTATE_FAILED,
    SG_RESOURCESTATE_INVALID,
    _SG_RESOURCESTATE_FORCE_U32 = 0x7FFFFFFF
} sg_resource_state;

/*
    sg_usage

    A resource usage hint describing the update strategy of
    buffers and images. This is used in the sg_buffer_desc.usage
    and sg_image_desc.usage members when creating buffers
    and images:

    SG_USAGE_IMMUTABLE:     the resource will never be updated with
                            new data, instead the content of the
                            resource must be provided on creation
    SG_USAGE_DYNAMIC:       the resource will be updated infrequently
                            with new data (this could range from "once
                            after creation", to "quite often but not
                            every frame")
    SG_USAGE_STREAM:        the resource will be updated each frame
                            with new content

    The rendering backends use this hint to prevent that the
    CPU needs to wait for the GPU when attempting to update
    a resource that might be currently accessed by the GPU.

    Resource content is updated with the functions sg_update_buffer() or
    sg_append_buffer() for buffer objects, and sg_update_image() for image
    objects. For the sg_update_*() functions, only one update is allowed per
    frame and resource object, while sg_append_buffer() can be called
    multiple times per frame on the same buffer. The application must update
    all data required for rendering (this means that the update data can be
    smaller than the resource size, if only a part of the overall resource
    size is used for rendering, you only need to make sure that the data that
    *is* used is valid).

    The default usage is SG_USAGE_IMMUTABLE.
*/
typedef enum sg_usage {
    _SG_USAGE_DEFAULT,      // value 0 reserved for default-init
    SG_USAGE_IMMUTABLE,
    SG_USAGE_DYNAMIC,
    SG_USAGE_STREAM,
    _SG_USAGE_NUM,
    _SG_USAGE_FORCE_U32 = 0x7FFFFFFF
} sg_usage;

/*
    sg_buffer_type

    Indicates whether a buffer will be bound as vertex-,
    index- or storage-buffer.

    Used in the sg_buffer_desc.type member when creating a buffer.

    The default value is SG_BUFFERTYPE_VERTEXBUFFER.
*/
typedef enum sg_buffer_type {
    _SG_BUFFERTYPE_DEFAULT,         // value 0 reserved for default-init
    SG_BUFFERTYPE_VERTEXBUFFER,
    SG_BUFFERTYPE_INDEXBUFFER,
    SG_BUFFERTYPE_STORAGEBUFFER,
    _SG_BUFFERTYPE_NUM,
    _SG_BUFFERTYPE_FORCE_U32 = 0x7FFFFFFF
} sg_buffer_type;

/*
    sg_index_type

    Indicates whether indexed rendering (fetching vertex-indices from an
    index buffer) is used, and if yes, the index data type (16- or 32-bits).
    This is used in the sg_pipeline_desc.index_type member when creating a
    pipeline object.

    The default index type is SG_INDEXTYPE_NONE.
*/
typedef enum sg_index_type {
    _SG_INDEXTYPE_DEFAULT,   // value 0 reserved for default-init
    SG_INDEXTYPE_NONE,
    SG_INDEXTYPE_UINT16,
    SG_INDEXTYPE_UINT32,
    _SG_INDEXTYPE_NUM,
    _SG_INDEXTYPE_FORCE_U32 = 0x7FFFFFFF
} sg_index_type;

/*
    sg_image_type

    Indicates the basic type of an image object (2D-texture, cubemap,
    3D-texture or 2D-array-texture). Used in the sg_image_desc.type member when
    creating an image, and in sg_shader_image_desc to describe a sampled texture
    in the shader (both must match and will be checked in the validation layer
    when calling sg_apply_bindings).

    The default image type when creating an image is SG_IMAGETYPE_2D.
*/
typedef enum sg_image_type {
    _SG_IMAGETYPE_DEFAULT,  // value 0 reserved for default-init
    SG_IMAGETYPE_2D,
    SG_IMAGETYPE_CUBE,
    SG_IMAGETYPE_3D,
    SG_IMAGETYPE_ARRAY,
    _SG_IMAGETYPE_NUM,
    _SG_IMAGETYPE_FORCE_U32 = 0x7FFFFFFF
} sg_image_type;

/*
    sg_image_sample_type

    The basic data type of a texture sample as expected by a shader.
    Must be provided in sg_shader_image_desc and used by the validation
    layer in sg_apply_bindings() to check if the provided image object
    is compatible with what the shader expects. Apart from the sokol-gfx
    validation layer, WebGPU is the only backend API which actually requires
    matching texture and sampler type to be provided upfront for validation
    (other 3D APIs treat texture/sampler type mismatches as undefined behaviour).

    NOTE that the following texture pixel formats require the use
    of SG_IMAGESAMPLETYPE_UNFILTERABLE_FLOAT, combined with a sampler
    of type SG_SAMPLERTYPE_NONFILTERING:

    - SG_PIXELFORMAT_R32F
    - SG_PIXELFORMAT_RG32F
    - SG_PIXELFORMAT_RGBA32F

    (when using sokol-shdc, also check out the meta tags `@image_sample_type`
    and `@sampler_type`)
*/
typedef enum sg_image_sample_type {
    _SG_IMAGESAMPLETYPE_DEFAULT,  // value 0 reserved for default-init
    SG_IMAGESAMPLETYPE_FLOAT,
    SG_IMAGESAMPLETYPE_DEPTH,
    SG_IMAGESAMPLETYPE_SINT,
    SG_IMAGESAMPLETYPE_UINT,
    SG_IMAGESAMPLETYPE_UNFILTERABLE_FLOAT,
    _SG_IMAGESAMPLETYPE_NUM,
    _SG_IMAGESAMPLETYPE_FORCE_U32 = 0x7FFFFFFF
} sg_image_sample_type;

/*
    sg_sampler_type

    The basic type of a texture sampler (sampling vs comparison) as
    defined in a shader. Must be provided in sg_shader_sampler_desc.

    sg_image_sample_type and sg_sampler_type for a texture/sampler
    pair must be compatible with each other, specifically only
    the following pairs are allowed:

    - SG_IMAGESAMPLETYPE_FLOAT => (SG_SAMPLERTYPE_FILTERING or SG_SAMPLERTYPE_NONFILTERING)
    - SG_IMAGESAMPLETYPE_UNFILTERABLE_FLOAT => SG_SAMPLERTYPE_NONFILTERING
    - SG_IMAGESAMPLETYPE_SINT => SG_SAMPLERTYPE_NONFILTERING
    - SG_IMAGESAMPLETYPE_UINT => SG_SAMPLERTYPE_NONFILTERING
    - SG_IMAGESAMPLETYPE_DEPTH => SG_SAMPLERTYPE_COMPARISON
*/
typedef enum sg_sampler_type {
    _SG_SAMPLERTYPE_DEFAULT,
    SG_SAMPLERTYPE_FILTERING,
    SG_SAMPLERTYPE_NONFILTERING,
    SG_SAMPLERTYPE_COMPARISON,
    _SG_SAMPLERTYPE_NUM,
    _SG_SAMPLERTYPE_FORCE_U32,
} sg_sampler_type;

/*
    sg_cube_face

    The cubemap faces. Use these as indices in the sg_image_desc.content
    array.
*/
typedef enum sg_cube_face {
    SG_CUBEFACE_POS_X,
    SG_CUBEFACE_NEG_X,
    SG_CUBEFACE_POS_Y,
    SG_CUBEFACE_NEG_Y,
    SG_CUBEFACE_POS_Z,
    SG_CUBEFACE_NEG_Z,
    SG_CUBEFACE_NUM,
    _SG_CUBEFACE_FORCE_U32 = 0x7FFFFFFF
} sg_cube_face;

/*
    sg_shader_stage

    There are 2 shader stages: vertex- and fragment-shader-stage.
    Each shader stage

    - SG_MAX_SHADERSTAGE_UBS slots for applying uniform data
    - SG_MAX_SHADERSTAGE_IMAGES slots for images used as textures
    - SG_MAX_SHADERSTAGE_SAMPLERS slots for texture samplers
    - SG_MAX_SHADERSTAGE_STORAGEBUFFERS slots for storage buffer bindings
*/
typedef enum sg_shader_stage {
    SG_SHADERSTAGE_VS,
    SG_SHADERSTAGE_FS,
    _SG_SHADERSTAGE_FORCE_U32 = 0x7FFFFFFF
} sg_shader_stage;

/*
    sg_primitive_type

    This is the common subset of 3D primitive types supported across all 3D
    APIs. This is used in the sg_pipeline_desc.primitive_type member when
    creating a pipeline object.

    The default primitive type is SG_PRIMITIVETYPE_TRIANGLES.
*/
typedef enum sg_primitive_type {
    _SG_PRIMITIVETYPE_DEFAULT,  // value 0 reserved for default-init
    SG_PRIMITIVETYPE_POINTS,
    SG_PRIMITIVETYPE_LINES,
    SG_PRIMITIVETYPE_LINE_STRIP,
    SG_PRIMITIVETYPE_TRIANGLES,
    SG_PRIMITIVETYPE_TRIANGLE_STRIP,
    _SG_PRIMITIVETYPE_NUM,
    _SG_PRIMITIVETYPE_FORCE_U32 = 0x7FFFFFFF
} sg_primitive_type;

/*
    sg_filter

    The filtering mode when sampling a texture image. This is
    used in the sg_sampler_desc.min_filter, sg_sampler_desc.mag_filter
    and sg_sampler_desc.mipmap_filter members when creating a sampler object.

    For the default is SG_FILTER_NEAREST.
*/
typedef enum sg_filter {
    _SG_FILTER_DEFAULT, // value 0 reserved for default-init
    SG_FILTER_NEAREST,
    SG_FILTER_LINEAR,
    _SG_FILTER_NUM,
    _SG_FILTER_FORCE_U32 = 0x7FFFFFFF
} sg_filter;

/*
    sg_wrap

    The texture coordinates wrapping mode when sampling a texture
    image. This is used in the sg_image_desc.wrap_u, .wrap_v
    and .wrap_w members when creating an image.

    The default wrap mode is SG_WRAP_REPEAT.

    NOTE: SG_WRAP_CLAMP_TO_BORDER is not supported on all backends
    and platforms. To check for support, call sg_query_features()
    and check the "clamp_to_border" boolean in the returned
    sg_features struct.

    Platforms which don't support SG_WRAP_CLAMP_TO_BORDER will silently fall back
    to SG_WRAP_CLAMP_TO_EDGE without a validation error.
*/
typedef enum sg_wrap {
    _SG_WRAP_DEFAULT,   // value 0 reserved for default-init
    SG_WRAP_REPEAT,
    SG_WRAP_CLAMP_TO_EDGE,
    SG_WRAP_CLAMP_TO_BORDER,
    SG_WRAP_MIRRORED_REPEAT,
    _SG_WRAP_NUM,
    _SG_WRAP_FORCE_U32 = 0x7FFFFFFF
} sg_wrap;

/*
    sg_border_color

    The border color to use when sampling a texture, and the UV wrap
    mode is SG_WRAP_CLAMP_TO_BORDER.

    The default border color is SG_BORDERCOLOR_OPAQUE_BLACK
*/
typedef enum sg_border_color {
    _SG_BORDERCOLOR_DEFAULT,    // value 0 reserved for default-init
    SG_BORDERCOLOR_TRANSPARENT_BLACK,
    SG_BORDERCOLOR_OPAQUE_BLACK,
    SG_BORDERCOLOR_OPAQUE_WHITE,
    _SG_BORDERCOLOR_NUM,
    _SG_BORDERCOLOR_FORCE_U32 = 0x7FFFFFFF
} sg_border_color;

/*
    sg_vertex_format

    The data type of a vertex component. This is used to describe
    the layout of vertex data when creating a pipeline object.
*/
typedef enum sg_vertex_format {
    SG_VERTEXFORMAT_INVALID,
    SG_VERTEXFORMAT_FLOAT,
    SG_VERTEXFORMAT_FLOAT2,
    SG_VERTEXFORMAT_FLOAT3,
    SG_VERTEXFORMAT_FLOAT4,
    SG_VERTEXFORMAT_BYTE4,
    SG_VERTEXFORMAT_BYTE4N,
    SG_VERTEXFORMAT_UBYTE4,
    SG_VERTEXFORMAT_UBYTE4N,
    SG_VERTEXFORMAT_SHORT2,
    SG_VERTEXFORMAT_SHORT2N,
    SG_VERTEXFORMAT_USHORT2N,
    SG_VERTEXFORMAT_SHORT4,
    SG_VERTEXFORMAT_SHORT4N,
    SG_VERTEXFORMAT_USHORT4N,
    SG_VERTEXFORMAT_UINT10_N2,
    SG_VERTEXFORMAT_HALF2,
    SG_VERTEXFORMAT_HALF4,
    _SG_VERTEXFORMAT_NUM,
    _SG_VERTEXFORMAT_FORCE_U32 = 0x7FFFFFFF
} sg_vertex_format;

/*
    sg_vertex_step

    Defines whether the input pointer of a vertex input stream is advanced
    'per vertex' or 'per instance'. The default step-func is
    SG_VERTEXSTEP_PER_VERTEX. SG_VERTEXSTEP_PER_INSTANCE is used with
    instanced-rendering.

    The vertex-step is part of the vertex-layout definition
    when creating pipeline objects.
*/
typedef enum sg_vertex_step {
    _SG_VERTEXSTEP_DEFAULT,     // value 0 reserved for default-init
    SG_VERTEXSTEP_PER_VERTEX,
    SG_VERTEXSTEP_PER_INSTANCE,
    _SG_VERTEXSTEP_NUM,
    _SG_VERTEXSTEP_FORCE_U32 = 0x7FFFFFFF
} sg_vertex_step;

/*
    sg_uniform_type

    The data type of a uniform block member. This is used to
    describe the internal layout of uniform blocks when creating
    a shader object.
*/
typedef enum sg_uniform_type {
    SG_UNIFORMTYPE_INVALID,
    SG_UNIFORMTYPE_FLOAT,
    SG_UNIFORMTYPE_FLOAT2,
    SG_UNIFORMTYPE_FLOAT3,
    SG_UNIFORMTYPE_FLOAT4,
    SG_UNIFORMTYPE_INT,
    SG_UNIFORMTYPE_INT2,
    SG_UNIFORMTYPE_INT3,
    SG_UNIFORMTYPE_INT4,
    SG_UNIFORMTYPE_MAT4,
    _SG_UNIFORMTYPE_NUM,
    _SG_UNIFORMTYPE_FORCE_U32 = 0x7FFFFFFF
} sg_uniform_type;

/*
    sg_uniform_layout

    A hint for the interior memory layout of uniform blocks. This is
    only really relevant for the GL backend where the internal layout
    of uniform blocks must be known to sokol-gfx. For all other backends the
    internal memory layout of uniform blocks doesn't matter, sokol-gfx
    will just pass uniform data as a single memory blob to the
    3D backend.

    SG_UNIFORMLAYOUT_NATIVE (default)
        Native layout means that a 'backend-native' memory layout
        is used. For the GL backend this means that uniforms
        are packed tightly in memory (e.g. there are no padding
        bytes).

    SG_UNIFORMLAYOUT_STD140
        The memory layout is a subset of std140. Arrays are only
        allowed for the FLOAT4, INT4 and MAT4. Alignment is as
        is as follows:

            FLOAT, INT:         4 byte alignment
            FLOAT2, INT2:       8 byte alignment
            FLOAT3, INT3:       16 byte alignment(!)
            FLOAT4, INT4:       16 byte alignment
            MAT4:               16 byte alignment
            FLOAT4[], INT4[]:   16 byte alignment

        The overall size of the uniform block must be a multiple
        of 16.

    For more information search for 'UNIFORM DATA LAYOUT' in the documentation block
    at the start of the header.
*/
typedef enum sg_uniform_layout {
    _SG_UNIFORMLAYOUT_DEFAULT,     // value 0 reserved for default-init
    SG_UNIFORMLAYOUT_NATIVE,       // default: layout depends on currently active backend
    SG_UNIFORMLAYOUT_STD140,       // std140: memory layout according to std140
    _SG_UNIFORMLAYOUT_NUM,
    _SG_UNIFORMLAYOUT_FORCE_U32 = 0x7FFFFFFF
} sg_uniform_layout;

/*
    sg_cull_mode

    The face-culling mode, this is used in the
    sg_pipeline_desc.cull_mode member when creating a
    pipeline object.

    The default cull mode is SG_CULLMODE_NONE
*/
typedef enum sg_cull_mode {
    _SG_CULLMODE_DEFAULT,   // value 0 reserved for default-init
    SG_CULLMODE_NONE,
    SG_CULLMODE_FRONT,
    SG_CULLMODE_BACK,
    _SG_CULLMODE_NUM,
    _SG_CULLMODE_FORCE_U32 = 0x7FFFFFFF
} sg_cull_mode;

/*
    sg_face_winding

    The vertex-winding rule that determines a front-facing primitive. This
    is used in the member sg_pipeline_desc.face_winding
    when creating a pipeline object.

    The default winding is SG_FACEWINDING_CW (clockwise)
*/
typedef enum sg_face_winding {
    _SG_FACEWINDING_DEFAULT,    // value 0 reserved for default-init
    SG_FACEWINDING_CCW,
    SG_FACEWINDING_CW,
    _SG_FACEWINDING_NUM,
    _SG_FACEWINDING_FORCE_U32 = 0x7FFFFFFF
} sg_face_winding;

/*
    sg_compare_func

    The compare-function for configuring depth- and stencil-ref tests
    in pipeline objects, and for texture samplers which perform a comparison
    instead of regular sampling operation.

    sg_pipeline_desc
        .depth
            .compare
        .stencil
            .front.compare
            .back.compar

    sg_sampler_desc
        .compare

    The default compare func for depth- and stencil-tests is
    SG_COMPAREFUNC_ALWAYS.

    The default compare func for sampler is SG_COMPAREFUNC_NEVER.
*/
typedef enum sg_compare_func {
    _SG_COMPAREFUNC_DEFAULT,    // value 0 reserved for default-init
    SG_COMPAREFUNC_NEVER,
    SG_COMPAREFUNC_LESS,
    SG_COMPAREFUNC_EQUAL,
    SG_COMPAREFUNC_LESS_EQUAL,
    SG_COMPAREFUNC_GREATER,
    SG_COMPAREFUNC_NOT_EQUAL,
    SG_COMPAREFUNC_GREATER_EQUAL,
    SG_COMPAREFUNC_ALWAYS,
    _SG_COMPAREFUNC_NUM,
    _SG_COMPAREFUNC_FORCE_U32 = 0x7FFFFFFF
} sg_compare_func;

/*
    sg_stencil_op

    The operation performed on a currently stored stencil-value when a
    comparison test passes or fails. This is used when creating a pipeline
    object in the members:

    sg_pipeline_desc
        .stencil
            .front
                .fail_op
                .depth_fail_op
                .pass_op
            .back
                .fail_op
                .depth_fail_op
                .pass_op

    The default value is SG_STENCILOP_KEEP.
*/
typedef enum sg_stencil_op {
    _SG_STENCILOP_DEFAULT,      // value 0 reserved for default-init
    SG_STENCILOP_KEEP,
    SG_STENCILOP_ZERO,
    SG_STENCILOP_REPLACE,
    SG_STENCILOP_INCR_CLAMP,
    SG_STENCILOP_DECR_CLAMP,
    SG_STENCILOP_INVERT,
    SG_STENCILOP_INCR_WRAP,
    SG_STENCILOP_DECR_WRAP,
    _SG_STENCILOP_NUM,
    _SG_STENCILOP_FORCE_U32 = 0x7FFFFFFF
} sg_stencil_op;

/*
    sg_blend_factor

    The source and destination factors in blending operations.
    This is used in the following members when creating a pipeline object:

    sg_pipeline_desc
        .colors[i]
            .blend
                .src_factor_rgb
                .dst_factor_rgb
                .src_factor_alpha
                .dst_factor_alpha

    The default value is SG_BLENDFACTOR_ONE for source
    factors, and SG_BLENDFACTOR_ZERO for destination factors.
*/
typedef enum sg_blend_factor {
    _SG_BLENDFACTOR_DEFAULT,    // value 0 reserved for default-init
    SG_BLENDFACTOR_ZERO,
    SG_BLENDFACTOR_ONE,
    SG_BLENDFACTOR_SRC_COLOR,
    SG_BLENDFACTOR_ONE_MINUS_SRC_COLOR,
    SG_BLENDFACTOR_SRC_ALPHA,
    SG_BLENDFACTOR_ONE_MINUS_SRC_ALPHA,
    SG_BLENDFACTOR_DST_COLOR,
    SG_BLENDFACTOR_ONE_MINUS_DST_COLOR,
    SG_BLENDFACTOR_DST_ALPHA,
    SG_BLENDFACTOR_ONE_MINUS_DST_ALPHA,
    SG_BLENDFACTOR_SRC_ALPHA_SATURATED,
    SG_BLENDFACTOR_BLEND_COLOR,
    SG_BLENDFACTOR_ONE_MINUS_BLEND_COLOR,
    SG_BLENDFACTOR_BLEND_ALPHA,
    SG_BLENDFACTOR_ONE_MINUS_BLEND_ALPHA,
    _SG_BLENDFACTOR_NUM,
    _SG_BLENDFACTOR_FORCE_U32 = 0x7FFFFFFF
} sg_blend_factor;

/*
    sg_blend_op

    Describes how the source and destination values are combined in the
    fragment blending operation. It is used in the following members when
    creating a pipeline object:

    sg_pipeline_desc
        .colors[i]
            .blend
                .op_rgb
                .op_alpha

    The default value is SG_BLENDOP_ADD.
*/
typedef enum sg_blend_op {
    _SG_BLENDOP_DEFAULT,    // value 0 reserved for default-init
    SG_BLENDOP_ADD,
    SG_BLENDOP_SUBTRACT,
    SG_BLENDOP_REVERSE_SUBTRACT,
    _SG_BLENDOP_NUM,
    _SG_BLENDOP_FORCE_U32 = 0x7FFFFFFF
} sg_blend_op;

/*
    sg_color_mask

    Selects the active color channels when writing a fragment color to the
    framebuffer. This is used in the members
    sg_pipeline_desc.colors[i].write_mask when creating a pipeline object.

    The default colormask is SG_COLORMASK_RGBA (write all colors channels)

    NOTE: since the color mask value 0 is reserved for the default value
    (SG_COLORMASK_RGBA), use SG_COLORMASK_NONE if all color channels
    should be disabled.
*/
typedef enum sg_color_mask {
    _SG_COLORMASK_DEFAULT = 0,    // value 0 reserved for default-init
    SG_COLORMASK_NONE   = 0x10,   // special value for 'all channels disabled
    SG_COLORMASK_R      = 0x1,
    SG_COLORMASK_G      = 0x2,
    SG_COLORMASK_RG     = 0x3,
    SG_COLORMASK_B      = 0x4,
    SG_COLORMASK_RB     = 0x5,
    SG_COLORMASK_GB     = 0x6,
    SG_COLORMASK_RGB    = 0x7,
    SG_COLORMASK_A      = 0x8,
    SG_COLORMASK_RA     = 0x9,
    SG_COLORMASK_GA     = 0xA,
    SG_COLORMASK_RGA    = 0xB,
    SG_COLORMASK_BA     = 0xC,
    SG_COLORMASK_RBA    = 0xD,
    SG_COLORMASK_GBA    = 0xE,
    SG_COLORMASK_RGBA   = 0xF,
    _SG_COLORMASK_FORCE_U32 = 0x7FFFFFFF
} sg_color_mask;

/*
    sg_load_action

    Defines the load action that should be performed at the start of a render pass:

    SG_LOADACTION_CLEAR:        clear the render target
    SG_LOADACTION_LOAD:         load the previous content of the render target
    SG_LOADACTION_DONTCARE:     leave the render target in an undefined state

    This is used in the sg_pass_action structure.

    The default load action for all pass attachments is SG_LOADACTION_CLEAR,
    with the values rgba = { 0.5f, 0.5f, 0.5f, 1.0f }, depth=1.0f and stencil=0.

    If you want to override the default behaviour, it is important to not
    only set the clear color, but the 'action' field as well (as long as this
    is _SG_LOADACTION_DEFAULT, the value fields will be ignored).
*/
typedef enum sg_load_action {
    _SG_LOADACTION_DEFAULT,
    SG_LOADACTION_CLEAR,
    SG_LOADACTION_LOAD,
    SG_LOADACTION_DONTCARE,
    _SG_LOADACTION_FORCE_U32 = 0x7FFFFFFF
} sg_load_action;

/*
    sg_store_action

    Defines the store action that be performed at the end of a render pass:

    SG_STOREACTION_STORE:       store the rendered content to the color attachment image
    SG_STOREACTION_DONTCARE:    allows the GPU to discard the rendered content
*/
typedef enum sg_store_action {
    _SG_STOREACTION_DEFAULT,
    SG_STOREACTION_STORE,
    SG_STOREACTION_DONTCARE,
    _SG_STOREACTION_FORCE_U32 = 0x7FFFFFFF
} sg_store_action;


/*
    sg_pass_action

    The sg_pass_action struct defines the actions to be performed
    at the start and end of a render pass.

    - at the start of the pass: whether the render targets should be cleared,
      loaded with their previous content, or start in an undefined state
    - for clear operations: the clear value (color, depth, or stencil values)
    - at the end of the pass: whether the rendering result should be
      stored back into the render target or discarded
*/
typedef struct sg_color_attachment_action {
    sg_load_action load_action;         // default: SG_LOADACTION_CLEAR
    sg_store_action store_action;       // default: SG_STOREACTION_STORE
    sg_color clear_value;               // default: { 0.5f, 0.5f, 0.5f, 1.0f }
} sg_color_attachment_action;

typedef struct sg_depth_attachment_action {
    sg_load_action load_action;         // default: SG_LOADACTION_CLEAR
    sg_store_action store_action;       // default: SG_STOREACTION_DONTCARE
    float clear_value;                  // default: 1.0
} sg_depth_attachment_action;

typedef struct sg_stencil_attachment_action {
    sg_load_action load_action;         // default: SG_LOADACTION_CLEAR
    sg_store_action store_action;       // default: SG_STOREACTION_DONTCARE
    uint8_t clear_value;                // default: 0
} sg_stencil_attachment_action;

typedef struct sg_pass_action {
    sg_color_attachment_action colors[SG_MAX_COLOR_ATTACHMENTS];
    sg_depth_attachment_action depth;
    sg_stencil_attachment_action stencil;
} sg_pass_action;

/*
    sg_swapchain

    Used in sg_begin_pass() to provide details about an external swapchain
    (pixel formats, sample count and backend-API specific render surface objects).

    The following information must be provided:

    - the width and height of the swapchain surfaces in number of pixels,
    - the pixel format of the render- and optional msaa-resolve-surface
    - the pixel format of the optional depth- or depth-stencil-surface
    - the MSAA sample count for the render and depth-stencil surface

    If the pixel formats and MSAA sample counts are left zero-initialized,
    their defaults are taken from the sg_environment struct provided in the
    sg_setup() call.

    The width and height *must* be > 0.

    Additionally the following backend API specific objects must be passed in
    as 'type erased' void pointers:

    GL: on all GL backends, a GL framebuffer object must be provided. This
    can be zero for the default framebuffer.

    D3D11:
        - an ID3D11RenderTargetView for the rendering surface, without
          MSAA rendering this surface will also be displayed
        - an optional ID3D11DepthStencilView for the depth- or depth/stencil
          buffer surface
        - when MSAA rendering is used, another ID3D11RenderTargetView
          which serves as MSAA resolve target and will be displayed

    WebGPU (same as D3D11, except different types)
        - a WGPUTextureView for the rendering surface, without
          MSAA rendering this surface will also be displayed
        - an optional WGPUTextureView for the depth- or depth/stencil
          buffer surface
        - when MSAA rendering is used, another WGPUTextureView
          which serves as MSAA resolve target and will be displayed

    Metal (NOTE that the rolves of provided surfaces is slightly different
    than on D3D11 or WebGPU in case of MSAA vs non-MSAA rendering):

        - A current CAMetalDrawable (NOT an MTLDrawable!) which will be presented.
          This will either be rendered to directly (if no MSAA is used), or serve
          as MSAA-resolve target.
        - an optional MTLTexture for the depth- or depth-stencil buffer
        - an optional multisampled MTLTexture which serves as intermediate
          rendering surface which will then be resolved into the
          CAMetalDrawable.

    NOTE that for Metal you must use an ObjC __bridge cast to
    properly tunnel the ObjC object handle through a C void*, e.g.:

        swapchain.metal.current_drawable = (__bridge const void*) [mtkView currentDrawable];

    On all other backends you shouldn't need to mess with the reference count.

    It's a good practice to write a helper function which returns an initialized
    sg_swapchain structs, which can then be plugged directly into
    sg_pass.swapchain. Look at the function sglue_swapchain() in the sokol_glue.h
    as an example.
*/
typedef struct sg_metal_swapchain {
    const void* current_drawable;       // CAMetalDrawable (NOT MTLDrawable!!!)
    const void* depth_stencil_texture;  // MTLTexture
    const void* msaa_color_texture;     // MTLTexture
} sg_metal_swapchain;

typedef struct sg_d3d11_swapchain {
    const void* render_view;            // ID3D11RenderTargetView
    const void* resolve_view;           // ID3D11RenderTargetView
    const void* depth_stencil_view;     // ID3D11DepthStencilView
} sg_d3d11_swapchain;

typedef struct sg_wgpu_swapchain {
    const void* render_view;            // WGPUTextureView
    const void* resolve_view;           // WGPUTextureView
    const void* depth_stencil_view;     // WGPUTextureView
} sg_wgpu_swapchain;

typedef struct sg_gl_swapchain {
    uint32_t framebuffer;               // GL framebuffer object
} sg_gl_swapchain;

typedef struct sg_swapchain {
    int width;
    int height;
    int sample_count;
    sg_pixel_format color_format;
    sg_pixel_format depth_format;
    sg_metal_swapchain metal;
    sg_d3d11_swapchain d3d11;
    sg_wgpu_swapchain wgpu;
    sg_gl_swapchain gl;
} sg_swapchain;

/*
    sg_pass

    The sg_pass structure is passed as argument into the sg_begin_pass()
    function.

    For an offscreen rendering pass, an sg_pass_action struct and sg_attachments
    object must be provided, and for swapchain passes, and sg_pass_action and
    an sg_swapchain struct. It is an error to provide both an sg_attachments
    handle and an initialized sg_swapchain struct in the same sg_begin_pass().

    An sg_begin_pass() call for an offscreen pass would look like this (where
    `attachments` is an sg_attachments handle):

        sg_begin_pass(&(sg_pass){
            .action = { ... },
            .attachments = attachments,
        });

    ...and a swapchain render pass would look like this (using the sokol_glue.h
    helper function sglue_swapchain() which gets the swapchain properties from
    sokol_app.h):

        sg_begin_pass(&(sg_pass){
            .action = { ... },
            .swapchain = sglue_swapchain(),
        });

    You can also omit the .action object to get default pass action behaviour
    (clear to color=grey, depth=1 and stencil=0).
*/
typedef struct sg_pass {
    uint32_t _start_canary;
    sg_pass_action action;
    sg_attachments attachments;
    sg_swapchain swapchain;
    const char* label;
    uint32_t _end_canary;
} sg_pass;

/*
    sg_bindings

    The sg_bindings structure defines the resource binding slots
    of the sokol_gfx render pipeline, used as argument to the
    sg_apply_bindings() function.

    A resource binding struct contains:

    - 1..N vertex buffers
    - 0..N vertex buffer offsets
    - 0..1 index buffers
    - 0..1 index buffer offsets
    - 0..N vertex shader stage images
    - 0..N vertex shader stage samplers
    - 0..N vertex shader storage buffers
    - 0..N fragment shader stage images
    - 0..N fragment shader stage samplers
    - 0..N fragment shader storage buffers

    For the max number of bindings, see the constant definitions:

    - SG_MAX_VERTEX_BUFFERS
    - SG_MAX_SHADERSTAGE_IMAGES
    - SG_MAX_SHADERSTAGE_SAMPLERS
    - SG_MAX_SHADERSTAGE_STORAGEBUFFERS

    The optional buffer offsets can be used to put different unrelated
    chunks of vertex- and/or index-data into the same buffer objects.
*/
typedef struct sg_stage_bindings {
    sg_image images[SG_MAX_SHADERSTAGE_IMAGES];
    sg_sampler samplers[SG_MAX_SHADERSTAGE_SAMPLERS];
    sg_buffer storage_buffers[SG_MAX_SHADERSTAGE_STORAGEBUFFERS];
} sg_stage_bindings;

typedef struct sg_bindings {
    uint32_t _start_canary;
    sg_buffer vertex_buffers[SG_MAX_VERTEX_BUFFERS];
    int vertex_buffer_offsets[SG_MAX_VERTEX_BUFFERS];
    sg_buffer index_buffer;
    int index_buffer_offset;
    sg_stage_bindings vs;
    sg_stage_bindings fs;
    uint32_t _end_canary;
} sg_bindings;

/*
    sg_buffer_desc

    Creation parameters for sg_buffer objects, used in the
    sg_make_buffer() call.

    The default configuration is:

    .size:      0       (*must* be >0 for buffers without data)
    .type:      SG_BUFFERTYPE_VERTEXBUFFER
    .usage:     SG_USAGE_IMMUTABLE
    .data.ptr   0       (*must* be valid for immutable buffers)
    .data.size  0       (*must* be > 0 for immutable buffers)
    .label      0       (optional string label)

    For immutable buffers which are initialized with initial data,
    keep the .size item zero-initialized, and set the size together with the
    pointer to the initial data in the .data item.

    For mutable buffers without initial data, keep the .data item
    zero-initialized, and set the buffer size in the .size item instead.

    You can also set both size values, but currently both size values must
    be identical (this may change in the future when the dynamic resource
    management may become more flexible).

    ADVANCED TOPIC: Injecting native 3D-API buffers:

    The following struct members allow to inject your own GL, Metal
    or D3D11 buffers into sokol_gfx:

    .gl_buffers[SG_NUM_INFLIGHT_FRAMES]
    .mtl_buffers[SG_NUM_INFLIGHT_FRAMES]
    .d3d11_buffer

    You must still provide all other struct items except the .data item, and
    these must match the creation parameters of the native buffers you
    provide. For SG_USAGE_IMMUTABLE, only provide a single native 3D-API
    buffer, otherwise you need to provide SG_NUM_INFLIGHT_FRAMES buffers
    (only for GL and Metal, not D3D11). Providing multiple buffers for GL and
    Metal is necessary because sokol_gfx will rotate through them when
    calling sg_update_buffer() to prevent lock-stalls.

    Note that it is expected that immutable injected buffer have already been
    initialized with content, and the .content member must be 0!

    Also you need to call sg_reset_state_cache() after calling native 3D-API
    functions, and before calling any sokol_gfx function.
*/
typedef struct sg_buffer_desc {
    uint32_t _start_canary;
    size_t size;
    sg_buffer_type type;
    sg_usage usage;
    sg_range data;
    const char* label;
    // optionally inject backend-specific resources
    uint32_t gl_buffers[SG_NUM_INFLIGHT_FRAMES];
    const void* mtl_buffers[SG_NUM_INFLIGHT_FRAMES];
    const void* d3d11_buffer;
    const void* wgpu_buffer;
    uint32_t _end_canary;
} sg_buffer_desc;

/*
    sg_image_data

    Defines the content of an image through a 2D array of sg_range structs.
    The first array dimension is the cubemap face, and the second array
    dimension the mipmap level.
*/
typedef struct sg_image_data {
    sg_range subimage[SG_CUBEFACE_NUM][SG_MAX_MIPMAPS];
} sg_image_data;

/*
    sg_image_desc

    Creation parameters for sg_image objects, used in the sg_make_image() call.

    The default configuration is:

    .type:              SG_IMAGETYPE_2D
    .render_target:     false
    .width              0 (must be set to >0)
    .height             0 (must be set to >0)
    .num_slices         1 (3D textures: depth; array textures: number of layers)
    .num_mipmaps:       1
    .usage:             SG_USAGE_IMMUTABLE
    .pixel_format:      SG_PIXELFORMAT_RGBA8 for textures, or sg_desc.environment.defaults.color_format for render targets
    .sample_count:      1 for textures, or sg_desc.environment.defaults.sample_count for render targets
    .data               an sg_image_data struct to define the initial content
    .label              0 (optional string label for trace hooks)

    Q: Why is the default sample_count for render targets identical with the
    "default sample count" from sg_desc.environment.defaults.sample_count?

    A: So that it matches the default sample count in pipeline objects. Even
    though it is a bit strange/confusing that offscreen render targets by default
    get the same sample count as 'default swapchains', but it's better that
    an offscreen render target created with default parameters matches
    a pipeline object created with default parameters.

    NOTE:

    Images with usage SG_USAGE_IMMUTABLE must be fully initialized by
    providing a valid .data member which points to initialization data.

    ADVANCED TOPIC: Injecting native 3D-API textures:

    The following struct members allow to inject your own GL, Metal or D3D11
    textures into sokol_gfx:

    .gl_textures[SG_NUM_INFLIGHT_FRAMES]
    .mtl_textures[SG_NUM_INFLIGHT_FRAMES]
    .d3d11_texture
    .d3d11_shader_resource_view
    .wgpu_texture
    .wgpu_texture_view

    For GL, you can also specify the texture target or leave it empty to use
    the default texture target for the image type (GL_TEXTURE_2D for
    SG_IMAGETYPE_2D etc)

    For D3D11 and WebGPU, either only provide a texture, or both a texture and
    shader-resource-view / texture-view object. If you want to use access the
    injected texture in a shader you *must* provide a shader-resource-view.

    The same rules apply as for injecting native buffers (see sg_buffer_desc
    documentation for more details).
*/
typedef struct sg_image_desc {
    uint32_t _start_canary;
    sg_image_type type;
    bool render_target;
    int width;
    int height;
    int num_slices;
    int num_mipmaps;
    sg_usage usage;
    sg_pixel_format pixel_format;
    int sample_count;
    sg_image_data data;
    const char* label;
    // optionally inject backend-specific resources
    uint32_t gl_textures[SG_NUM_INFLIGHT_FRAMES];
    uint32_t gl_texture_target;
    const void* mtl_textures[SG_NUM_INFLIGHT_FRAMES];
    const void* d3d11_texture;
    const void* d3d11_shader_resource_view;
    const void* wgpu_texture;
    const void* wgpu_texture_view;
    uint32_t _end_canary;
} sg_image_desc;

/*
    sg_sampler_desc

    Creation parameters for sg_sampler objects, used in the sg_make_sampler() call

    .min_filter:        SG_FILTER_NEAREST
    .mag_filter:        SG_FILTER_NEAREST
    .mipmap_filter      SG_FILTER_NEAREST
    .wrap_u:            SG_WRAP_REPEAT
    .wrap_v:            SG_WRAP_REPEAT
    .wrap_w:            SG_WRAP_REPEAT (only SG_IMAGETYPE_3D)
    .min_lod            0.0f
    .max_lod            FLT_MAX
    .border_color       SG_BORDERCOLOR_OPAQUE_BLACK
    .compare            SG_COMPAREFUNC_NEVER
    .max_anisotropy     1 (must be 1..16)

*/
typedef struct sg_sampler_desc {
    uint32_t _start_canary;
    sg_filter min_filter;
    sg_filter mag_filter;
    sg_filter mipmap_filter;
    sg_wrap wrap_u;
    sg_wrap wrap_v;
    sg_wrap wrap_w;
    float min_lod;
    float max_lod;
    sg_border_color border_color;
    sg_compare_func compare;
    uint32_t max_anisotropy;
    const char* label;
    // optionally inject backend-specific resources
    uint32_t gl_sampler;
    const void* mtl_sampler;
    const void* d3d11_sampler;
    const void* wgpu_sampler;
    uint32_t _end_canary;
} sg_sampler_desc;

/*
    sg_shader_desc

    The structure sg_shader_desc defines all creation parameters for shader
    programs, used as input to the sg_make_shader() function:

    - reflection information for vertex attributes (vertex shader inputs):
        - vertex attribute name (only optionally used by GLES3 and GL)
        - a semantic name and index (required for D3D11)
    - for each shader-stage (vertex and fragment):
        - the shader source or bytecode
        - an optional entry function name
        - an optional compile target (only for D3D11 when source is provided,
          defaults are "vs_4_0" and "ps_4_0")
        - reflection info for each uniform block used by the shader stage:
            - the size of the uniform block in bytes
            - a memory layout hint (native vs std140, only required for GL backends)
            - reflection info for each uniform block member (only required for GL backends):
                - member name
                - member type (SG_UNIFORMTYPE_xxx)
                - if the member is an array, the number of array items
        - reflection info for textures used in the shader stage:
            - the image type (SG_IMAGETYPE_xxx)
            - the image-sample type (SG_IMAGESAMPLETYPE_xxx, default is SG_IMAGESAMPLETYPE_FLOAT)
            - whether the shader expects a multisampled texture
        - reflection info for samplers used in the shader stage:
            - the sampler type (SG_SAMPLERTYPE_xxx)
        - reflection info for each image-sampler-pair used by the shader:
            - the texture slot of the involved texture
            - the sampler slot of the involved sampler
            - for GLSL only: the name of the combined image-sampler object
        - reflection info for each storage-buffer used by the shader:
            - whether the storage buffer is readonly (currently this
              must be true)

    For all GL backends, shader source-code must be provided. For D3D11 and Metal,
    either shader source-code or byte-code can be provided.

    For D3D11, if source code is provided, the d3dcompiler_47.dll will be loaded
    on demand. If this fails, shader creation will fail. When compiling HLSL
    source code, you can provide an optional target string via
    sg_shader_stage_desc.d3d11_target, the default target is "vs_4_0" for the
    vertex shader stage and "ps_4_0" for the pixel shader stage.
*/
typedef struct sg_shader_attr_desc {
    const char* name;           // GLSL vertex attribute name (optional)
    const char* sem_name;       // HLSL semantic name
    int sem_index;              // HLSL semantic index
} sg_shader_attr_desc;

typedef struct sg_shader_uniform_desc {
    const char* name;
    sg_uniform_type type;
    int array_count;
} sg_shader_uniform_desc;

typedef struct sg_shader_uniform_block_desc {
    size_t size;
    sg_uniform_layout layout;
    sg_shader_uniform_desc uniforms[SG_MAX_UB_MEMBERS];
} sg_shader_uniform_block_desc;

typedef struct sg_shader_storage_buffer_desc {
    bool used;
    bool readonly;
} sg_shader_storage_buffer_desc;

typedef struct sg_shader_image_desc {
    bool used;
    bool multisampled;
    sg_image_type image_type;
    sg_image_sample_type sample_type;
} sg_shader_image_desc;

typedef struct sg_shader_sampler_desc {
    bool used;
    sg_sampler_type sampler_type;
} sg_shader_sampler_desc;

typedef struct sg_shader_image_sampler_pair_desc {
    bool used;
    int image_slot;
    int sampler_slot;
    const char* glsl_name;
} sg_shader_image_sampler_pair_desc;

typedef struct sg_shader_stage_desc {
    const char* source;
    sg_range bytecode;
    const char* entry;
    const char* d3d11_target;
    sg_shader_uniform_block_desc uniform_blocks[SG_MAX_SHADERSTAGE_UBS];
    sg_shader_storage_buffer_desc storage_buffers[SG_MAX_SHADERSTAGE_STORAGEBUFFERS];
    sg_shader_image_desc images[SG_MAX_SHADERSTAGE_IMAGES];
    sg_shader_sampler_desc samplers[SG_MAX_SHADERSTAGE_SAMPLERS];
    sg_shader_image_sampler_pair_desc image_sampler_pairs[SG_MAX_SHADERSTAGE_IMAGESAMPLERPAIRS];
} sg_shader_stage_desc;

typedef struct sg_shader_desc {
    uint32_t _start_canary;
    sg_shader_attr_desc attrs[SG_MAX_VERTEX_ATTRIBUTES];
    sg_shader_stage_desc vs;
    sg_shader_stage_desc fs;
    const char* label;
    uint32_t _end_canary;
} sg_shader_desc;

/*
    sg_pipeline_desc

    The sg_pipeline_desc struct defines all creation parameters for an
    sg_pipeline object, used as argument to the sg_make_pipeline() function:

    - the vertex layout for all input vertex buffers
    - a shader object
    - the 3D primitive type (points, lines, triangles, ...)
    - the index type (none, 16- or 32-bit)
    - all the fixed-function-pipeline state (depth-, stencil-, blend-state, etc...)

    If the vertex data has no gaps between vertex components, you can omit
    the .layout.buffers[].stride and layout.attrs[].offset items (leave them
    default-initialized to 0), sokol-gfx will then compute the offsets and
    strides from the vertex component formats (.layout.attrs[].format).
    Please note that ALL vertex attribute offsets must be 0 in order for the
    automatic offset computation to kick in.

    The default configuration is as follows:

    .shader:            0 (must be initialized with a valid sg_shader id!)
    .layout:
        .buffers[]:         vertex buffer layouts
            .stride:        0 (if no stride is given it will be computed)
            .step_func      SG_VERTEXSTEP_PER_VERTEX
            .step_rate      1
        .attrs[]:           vertex attribute declarations
            .buffer_index   0 the vertex buffer bind slot
            .offset         0 (offsets can be omitted if the vertex layout has no gaps)
            .format         SG_VERTEXFORMAT_INVALID (must be initialized!)
    .depth:
        .pixel_format:      sg_desc.context.depth_format
        .compare:           SG_COMPAREFUNC_ALWAYS
        .write_enabled:     false
        .bias:              0.0f
        .bias_slope_scale:  0.0f
        .bias_clamp:        0.0f
    .stencil:
        .enabled:           false
        .front/back:
            .compare:       SG_COMPAREFUNC_ALWAYS
            .fail_op:       SG_STENCILOP_KEEP
            .depth_fail_op: SG_STENCILOP_KEEP
            .pass_op:       SG_STENCILOP_KEEP
        .read_mask:         0
        .write_mask:        0
        .ref:               0
    .color_count            1
    .colors[0..color_count]
        .pixel_format       sg_desc.context.color_format
        .write_mask:        SG_COLORMASK_RGBA
        .blend:
            .enabled:           false
            .src_factor_rgb:    SG_BLENDFACTOR_ONE
            .dst_factor_rgb:    SG_BLENDFACTOR_ZERO
            .op_rgb:            SG_BLENDOP_ADD
            .src_factor_alpha:  SG_BLENDFACTOR_ONE
            .dst_factor_alpha:  SG_BLENDFACTOR_ZERO
            .op_alpha:          SG_BLENDOP_ADD
    .primitive_type:            SG_PRIMITIVETYPE_TRIANGLES
    .index_type:                SG_INDEXTYPE_NONE
    .cull_mode:                 SG_CULLMODE_NONE
    .face_winding:              SG_FACEWINDING_CW
    .sample_count:              sg_desc.context.sample_count
    .blend_color:               (sg_color) { 0.0f, 0.0f, 0.0f, 0.0f }
    .alpha_to_coverage_enabled: false
    .label  0       (optional string label for trace hooks)
*/
typedef struct sg_vertex_buffer_layout_state {
    int stride;
    sg_vertex_step step_func;
    int step_rate;
} sg_vertex_buffer_layout_state;

typedef struct sg_vertex_attr_state {
    int buffer_index;
    int offset;
    sg_vertex_format format;
} sg_vertex_attr_state;

typedef struct sg_vertex_layout_state {
    sg_vertex_buffer_layout_state buffers[SG_MAX_VERTEX_BUFFERS];
    sg_vertex_attr_state attrs[SG_MAX_VERTEX_ATTRIBUTES];
} sg_vertex_layout_state;

typedef struct sg_stencil_face_state {
    sg_compare_func compare;
    sg_stencil_op fail_op;
    sg_stencil_op depth_fail_op;
    sg_stencil_op pass_op;
} sg_stencil_face_state;

typedef struct sg_stencil_state {
    bool enabled;
    sg_stencil_face_state front;
    sg_stencil_face_state back;
    uint8_t read_mask;
    uint8_t write_mask;
    uint8_t ref;
} sg_stencil_state;

typedef struct sg_depth_state {
    sg_pixel_format pixel_format;
    sg_compare_func compare;
    bool write_enabled;
    float bias;
    float bias_slope_scale;
    float bias_clamp;
} sg_depth_state;

typedef struct sg_blend_state {
    bool enabled;
    sg_blend_factor src_factor_rgb;
    sg_blend_factor dst_factor_rgb;
    sg_blend_op op_rgb;
    sg_blend_factor src_factor_alpha;
    sg_blend_factor dst_factor_alpha;
    sg_blend_op op_alpha;
} sg_blend_state;

typedef struct sg_color_target_state {
    sg_pixel_format pixel_format;
    sg_color_mask write_mask;
    sg_blend_state blend;
} sg_color_target_state;

typedef struct sg_pipeline_desc {
    uint32_t _start_canary;
    sg_shader shader;
    sg_vertex_layout_state layout;
    sg_depth_state depth;
    sg_stencil_state stencil;
    int color_count;
    sg_color_target_state colors[SG_MAX_COLOR_ATTACHMENTS];
    sg_primitive_type primitive_type;
    sg_index_type index_type;
    sg_cull_mode cull_mode;
    sg_face_winding face_winding;
    int sample_count;
    sg_color blend_color;
    bool alpha_to_coverage_enabled;
    const char* label;
    uint32_t _end_canary;
} sg_pipeline_desc;

/*
    sg_attachments_desc

    Creation parameters for an sg_attachments object, used as argument to the
    sg_make_attachments() function.

    An attachments object bundles 0..4 color attachments, 0..4 msaa-resolve
    attachments, and none or one depth-stencil attachmente for use
    in a render pass. At least one color attachment or one depth-stencil
    attachment must be provided (no color attachment and a depth-stencil
    attachment is useful for a depth-only render pass).

    Each attachment definition consists of an image object, and two additional indices
    describing which subimage the pass will render into: one mipmap index, and if the image
    is a cubemap, array-texture or 3D-texture, the face-index, array-layer or
    depth-slice.

    All attachments must have the same width and height.

    All color attachments and the depth-stencil attachment must have the
    same sample count.

    If a resolve attachment is set, an MSAA-resolve operation from the
    associated color attachment image into the resolve attachment image will take
    place in the sg_end_pass() function. In this case, the color attachment
    must have a (sample_count>1), and the resolve attachment a
    (sample_count==1). The resolve attachment also must have the same pixel
    format as the color attachment.

    NOTE that MSAA depth-stencil attachments cannot be msaa-resolved!
*/
typedef struct sg_attachment_desc {
    sg_image image;
    int mip_level;
    int slice;      // cube texture: face; array texture: layer; 3D texture: slice
} sg_attachment_desc;

typedef struct sg_attachments_desc {
    uint32_t _start_canary;
    sg_attachment_desc colors[SG_MAX_COLOR_ATTACHMENTS];
    sg_attachment_desc resolves[SG_MAX_COLOR_ATTACHMENTS];
    sg_attachment_desc depth_stencil;
    const char* label;
    uint32_t _end_canary;
} sg_attachments_desc;

/*
    sg_trace_hooks

    Installable callback functions to keep track of the sokol-gfx calls,
    this is useful for debugging, or keeping track of resource creation
    and destruction.

    Trace hooks are installed with sg_install_trace_hooks(), this returns
    another sg_trace_hooks struct with the previous set of
    trace hook function pointers. These should be invoked by the
    new trace hooks to form a proper call chain.
*/
typedef struct sg_trace_hooks {
    void* user_data;
    void (*reset_state_cache)(void* user_data);
    void (*make_buffer)(const sg_buffer_desc* desc, sg_buffer result, void* user_data);
    void (*make_image)(const sg_image_desc* desc, sg_image result, void* user_data);
    void (*make_sampler)(const sg_sampler_desc* desc, sg_sampler result, void* user_data);
    void (*make_shader)(const sg_shader_desc* desc, sg_shader result, void* user_data);
    void (*make_pipeline)(const sg_pipeline_desc* desc, sg_pipeline result, void* user_data);
    void (*make_attachments)(const sg_attachments_desc* desc, sg_attachments result, void* user_data);
    void (*destroy_buffer)(sg_buffer buf, void* user_data);
    void (*destroy_image)(sg_image img, void* user_data);
    void (*destroy_sampler)(sg_sampler smp, void* user_data);
    void (*destroy_shader)(sg_shader shd, void* user_data);
    void (*destroy_pipeline)(sg_pipeline pip, void* user_data);
    void (*destroy_attachments)(sg_attachments atts, void* user_data);
    void (*update_buffer)(sg_buffer buf, const sg_range* data, void* user_data);
    void (*update_image)(sg_image img, const sg_image_data* data, void* user_data);
    void (*append_buffer)(sg_buffer buf, const sg_range* data, int result, void* user_data);
    void (*begin_pass)(const sg_pass* pass, void* user_data);
    void (*apply_viewport)(int x, int y, int width, int height, bool origin_top_left, void* user_data);
    void (*apply_scissor_rect)(int x, int y, int width, int height, bool origin_top_left, void* user_data);
    void (*apply_pipeline)(sg_pipeline pip, void* user_data);
    void (*apply_bindings)(const sg_bindings* bindings, void* user_data);
    void (*apply_uniforms)(sg_shader_stage stage, int ub_index, const sg_range* data, void* user_data);
    void (*draw)(int base_element, int num_elements, int num_instances, void* user_data);
    void (*end_pass)(void* user_data);
    void (*commit)(void* user_data);
    void (*alloc_buffer)(sg_buffer result, void* user_data);
    void (*alloc_image)(sg_image result, void* user_data);
    void (*alloc_sampler)(sg_sampler result, void* user_data);
    void (*alloc_shader)(sg_shader result, void* user_data);
    void (*alloc_pipeline)(sg_pipeline result, void* user_data);
    void (*alloc_attachments)(sg_attachments result, void* user_data);
    void (*dealloc_buffer)(sg_buffer buf_id, void* user_data);
    void (*dealloc_image)(sg_image img_id, void* user_data);
    void (*dealloc_sampler)(sg_sampler smp_id, void* user_data);
    void (*dealloc_shader)(sg_shader shd_id, void* user_data);
    void (*dealloc_pipeline)(sg_pipeline pip_id, void* user_data);
    void (*dealloc_attachments)(sg_attachments atts_id, void* user_data);
    void (*init_buffer)(sg_buffer buf_id, const sg_buffer_desc* desc, void* user_data);
    void (*init_image)(sg_image img_id, const sg_image_desc* desc, void* user_data);
    void (*init_sampler)(sg_sampler smp_id, const sg_sampler_desc* desc, void* user_data);
    void (*init_shader)(sg_shader shd_id, const sg_shader_desc* desc, void* user_data);
    void (*init_pipeline)(sg_pipeline pip_id, const sg_pipeline_desc* desc, void* user_data);
    void (*init_attachments)(sg_attachments atts_id, const sg_attachments_desc* desc, void* user_data);
    void (*uninit_buffer)(sg_buffer buf_id, void* user_data);
    void (*uninit_image)(sg_image img_id, void* user_data);
    void (*uninit_sampler)(sg_sampler smp_id, void* user_data);
    void (*uninit_shader)(sg_shader shd_id, void* user_data);
    void (*uninit_pipeline)(sg_pipeline pip_id, void* user_data);
    void (*uninit_attachments)(sg_attachments atts_id, void* user_data);
    void (*fail_buffer)(sg_buffer buf_id, void* user_data);
    void (*fail_image)(sg_image img_id, void* user_data);
    void (*fail_sampler)(sg_sampler smp_id, void* user_data);
    void (*fail_shader)(sg_shader shd_id, void* user_data);
    void (*fail_pipeline)(sg_pipeline pip_id, void* user_data);
    void (*fail_attachments)(sg_attachments atts_id, void* user_data);
    void (*push_debug_group)(const char* name, void* user_data);
    void (*pop_debug_group)(void* user_data);
} sg_trace_hooks;

/*
    sg_buffer_info
    sg_image_info
    sg_sampler_info
    sg_shader_info
    sg_pipeline_info
    sg_attachments_info

    These structs contain various internal resource attributes which
    might be useful for debug-inspection. Please don't rely on the
    actual content of those structs too much, as they are quite closely
    tied to sokol_gfx.h internals and may change more frequently than
    the other public API elements.

    The *_info structs are used as the return values of the following functions:

    sg_query_buffer_info()
    sg_query_image_info()
    sg_query_sampler_info()
    sg_query_shader_info()
    sg_query_pipeline_info()
    sg_query_pass_info()
*/
typedef struct sg_slot_info {
    sg_resource_state state;    // the current state of this resource slot
    uint32_t res_id;            // type-neutral resource if (e.g. sg_buffer.id)
} sg_slot_info;

typedef struct sg_buffer_info {
    sg_slot_info slot;              // resource pool slot info
    uint32_t update_frame_index;    // frame index of last sg_update_buffer()
    uint32_t append_frame_index;    // frame index of last sg_append_buffer()
    int append_pos;                 // current position in buffer for sg_append_buffer()
    bool append_overflow;           // is buffer in overflow state (due to sg_append_buffer)
    int num_slots;                  // number of renaming-slots for dynamically updated buffers
    int active_slot;                // currently active write-slot for dynamically updated buffers
} sg_buffer_info;

typedef struct sg_image_info {
    sg_slot_info slot;              // resource pool slot info
    uint32_t upd_frame_index;       // frame index of last sg_update_image()
    int num_slots;                  // number of renaming-slots for dynamically updated images
    int active_slot;                // currently active write-slot for dynamically updated images
} sg_image_info;

typedef struct sg_sampler_info {
    sg_slot_info slot;              // resource pool slot info
} sg_sampler_info;

typedef struct sg_shader_info {
    sg_slot_info slot;              // resource pool slot info
} sg_shader_info;

typedef struct sg_pipeline_info {
    sg_slot_info slot;              // resource pool slot info
} sg_pipeline_info;

typedef struct sg_attachments_info {
    sg_slot_info slot;              // resource pool slot info
} sg_attachments_info;

/*
    sg_frame_stats

    Allows to track generic and backend-specific stats about a
    render frame. Obtained by calling sg_query_frame_stats(). The returned
    struct contains information about the *previous* frame.
*/
typedef struct sg_frame_stats_gl {
    uint32_t num_bind_buffer;
    uint32_t num_active_texture;
    uint32_t num_bind_texture;
    uint32_t num_bind_sampler;
    uint32_t num_use_program;
    uint32_t num_render_state;
    uint32_t num_vertex_attrib_pointer;
    uint32_t num_vertex_attrib_divisor;
    uint32_t num_enable_vertex_attrib_array;
    uint32_t num_disable_vertex_attrib_array;
    uint32_t num_uniform;
} sg_frame_stats_gl;

typedef struct sg_frame_stats_d3d11_pass {
    uint32_t num_om_set_render_targets;
    uint32_t num_clear_render_target_view;
    uint32_t num_clear_depth_stencil_view;
    uint32_t num_resolve_subresource;
} sg_frame_stats_d3d11_pass;

typedef struct sg_frame_stats_d3d11_pipeline {
    uint32_t num_rs_set_state;
    uint32_t num_om_set_depth_stencil_state;
    uint32_t num_om_set_blend_state;
    uint32_t num_ia_set_primitive_topology;
    uint32_t num_ia_set_input_layout;
    uint32_t num_vs_set_shader;
    uint32_t num_vs_set_constant_buffers;
    uint32_t num_ps_set_shader;
    uint32_t num_ps_set_constant_buffers;
} sg_frame_stats_d3d11_pipeline;

typedef struct sg_frame_stats_d3d11_bindings {
    uint32_t num_ia_set_vertex_buffers;
    uint32_t num_ia_set_index_buffer;
    uint32_t num_vs_set_shader_resources;
    uint32_t num_ps_set_shader_resources;
    uint32_t num_vs_set_samplers;
    uint32_t num_ps_set_samplers;
} sg_frame_stats_d3d11_bindings;

typedef struct sg_frame_stats_d3d11_uniforms {
    uint32_t num_update_subresource;
} sg_frame_stats_d3d11_uniforms;

typedef struct sg_frame_stats_d3d11_draw {
    uint32_t num_draw_indexed_instanced;
    uint32_t num_draw_indexed;
    uint32_t num_draw_instanced;
    uint32_t num_draw;
} sg_frame_stats_d3d11_draw;

typedef struct sg_frame_stats_d3d11 {
    sg_frame_stats_d3d11_pass pass;
    sg_frame_stats_d3d11_pipeline pipeline;
    sg_frame_stats_d3d11_bindings bindings;
    sg_frame_stats_d3d11_uniforms uniforms;
    sg_frame_stats_d3d11_draw draw;
    uint32_t num_map;
    uint32_t num_unmap;
} sg_frame_stats_d3d11;

typedef struct sg_frame_stats_metal_idpool {
    uint32_t num_added;
    uint32_t num_released;
    uint32_t num_garbage_collected;
} sg_frame_stats_metal_idpool;

typedef struct sg_frame_stats_metal_pipeline {
    uint32_t num_set_blend_color;
    uint32_t num_set_cull_mode;
    uint32_t num_set_front_facing_winding;
    uint32_t num_set_stencil_reference_value;
    uint32_t num_set_depth_bias;
    uint32_t num_set_render_pipeline_state;
    uint32_t num_set_depth_stencil_state;
} sg_frame_stats_metal_pipeline;

typedef struct sg_frame_stats_metal_bindings {
    uint32_t num_set_vertex_buffer;
    uint32_t num_set_vertex_texture;
    uint32_t num_set_vertex_sampler_state;
    uint32_t num_set_fragment_buffer;
    uint32_t num_set_fragment_texture;
    uint32_t num_set_fragment_sampler_state;
} sg_frame_stats_metal_bindings;

typedef struct sg_frame_stats_metal_uniforms {
    uint32_t num_set_vertex_buffer_offset;
    uint32_t num_set_fragment_buffer_offset;
} sg_frame_stats_metal_uniforms;

typedef struct sg_frame_stats_metal {
    sg_frame_stats_metal_idpool idpool;
    sg_frame_stats_metal_pipeline pipeline;
    sg_frame_stats_metal_bindings bindings;
    sg_frame_stats_metal_uniforms uniforms;
} sg_frame_stats_metal;

typedef struct sg_frame_stats_wgpu_uniforms {
    uint32_t num_set_bindgroup;
    uint32_t size_write_buffer;
} sg_frame_stats_wgpu_uniforms;

typedef struct sg_frame_stats_wgpu_bindings {
    uint32_t num_set_vertex_buffer;
    uint32_t num_skip_redundant_vertex_buffer;
    uint32_t num_set_index_buffer;
    uint32_t num_skip_redundant_index_buffer;
    uint32_t num_create_bindgroup;
    uint32_t num_discard_bindgroup;
    uint32_t num_set_bindgroup;
    uint32_t num_skip_redundant_bindgroup;
    uint32_t num_bindgroup_cache_hits;
    uint32_t num_bindgroup_cache_misses;
    uint32_t num_bindgroup_cache_collisions;
    uint32_t num_bindgroup_cache_invalidates;
    uint32_t num_bindgroup_cache_hash_vs_key_mismatch;
} sg_frame_stats_wgpu_bindings;

typedef struct sg_frame_stats_wgpu {
    sg_frame_stats_wgpu_uniforms uniforms;
    sg_frame_stats_wgpu_bindings bindings;
} sg_frame_stats_wgpu;

typedef struct sg_frame_stats {
    uint32_t frame_index;   // current frame counter, starts at 0

    uint32_t num_passes;
    uint32_t num_apply_viewport;
    uint32_t num_apply_scissor_rect;
    uint32_t num_apply_pipeline;
    uint32_t num_apply_bindings;
    uint32_t num_apply_uniforms;
    uint32_t num_draw;
    uint32_t num_update_buffer;
    uint32_t num_append_buffer;
    uint32_t num_update_image;

    uint32_t size_apply_uniforms;
    uint32_t size_update_buffer;
    uint32_t size_append_buffer;
    uint32_t size_update_image;

    sg_frame_stats_gl gl;
    sg_frame_stats_d3d11 d3d11;
    sg_frame_stats_metal metal;
    sg_frame_stats_wgpu wgpu;
} sg_frame_stats;

/*
    sg_desc

    The sg_desc struct contains configuration values for sokol_gfx,
    it is used as parameter to the sg_setup() call.

    The default configuration is:

    .buffer_pool_size       128
    .image_pool_size        128
    .sampler_pool_size      64
    .shader_pool_size       32
    .pipeline_pool_size     64
    .pass_pool_size         16
    .uniform_buffer_size    4 MB (4*1024*1024)
    .max_commit_listeners   1024
    .disable_validation     false
    .mtl_force_managed_storage_mode false
    .wgpu_disable_bindgroups_cache  false
    .wgpu_bindgroups_cache_size     1024

    .allocator.alloc_fn     0 (in this case, malloc() will be called)
    .allocator.free_fn      0 (in this case, free() will be called)
    .allocator.user_data    0

    .environment.defaults.color_format: default value depends on selected backend:
        all GL backends:    SG_PIXELFORMAT_RGBA8
        Metal and D3D11:    SG_PIXELFORMAT_BGRA8
        WebGPU:             *no default* (must be queried from WebGPU swapchain object)
    .environment.defaults.depth_format: SG_PIXELFORMAT_DEPTH_STENCIL
    .environment.defaults.sample_count: 1

    Metal specific:
        (NOTE: All Objective-C object references are transferred through
        a bridged (const void*) to sokol_gfx, which will use a unretained
        bridged cast (__bridged id<xxx>) to retrieve the Objective-C
        references back. Since the bridge cast is unretained, the caller
        must hold a strong reference to the Objective-C object for the
        duration of the sokol_gfx call!

        .mtl_force_managed_storage_mode
            when enabled, Metal buffers and texture resources are created in managed storage
            mode, otherwise sokol-gfx will decide whether to create buffers and
            textures in managed or shared storage mode (this is mainly a debugging option)
        .mtl_use_command_buffer_with_retained_references
            when true, the sokol-gfx Metal backend will use Metal command buffers which
            bump the reference count of resource objects as long as they are inflight,
            this is slower than the default command-buffer-with-unretained-references
            method, this may be a workaround when confronted with lifetime validation
            errors from the Metal validation layer until a proper fix has been implemented
        .environment.metal.device
            a pointer to the MTLDevice object

    D3D11 specific:
        .environment.d3d11.device
            a pointer to the ID3D11Device object, this must have been created
            before sg_setup() is called
        .environment.d3d11.device_context
            a pointer to the ID3D11DeviceContext object
        .d3d11_shader_debugging
            set this to true to compile shaders which are provided as HLSL source
            code with debug information and without optimization, this allows
            shader debugging in tools like RenderDoc, to output source code
            instead of byte code from sokol-shdc, omit the `--binary` cmdline
            option

    WebGPU specific:
        .wgpu_disable_bindgroups_cache
            When this is true, the WebGPU backend will create and immediately
            release a BindGroup object in the sg_apply_bindings() call, only
            use this for debugging purposes.
        .wgpu_bindgroups_cache_size
            The size of the bindgroups cache for re-using BindGroup objects
            between sg_apply_bindings() calls. The smaller the cache size,
            the more likely are cache slot collisions which will cause
            a BindGroups object to be destroyed and a new one created.
            Use the information returned by sg_query_stats() to check
            if this is a frequent occurrence, and increase the cache size as
            needed (the default is 1024).
            NOTE: wgpu_bindgroups_cache_size must be a power-of-2 number!
        .environment.wgpu.device
            a WGPUDevice handle

    When using sokol_gfx.h and sokol_app.h together, consider using the
    helper function sglue_environment() in the sokol_glue.h header to
    initialize the sg_desc.environment nested struct. sglue_environment() returns
    a completely initialized sg_environment struct with information
    provided by sokol_app.h.
*/
typedef struct sg_environment_defaults {
   sg_pixel_format color_format;
   sg_pixel_format depth_format;
   int sample_count;
} sg_environment_defaults;

typedef struct sg_metal_environment {
   const void* device;
} sg_metal_environment;

typedef struct sg_d3d11_environment {
   const void* device;
   const void* device_context;
} sg_d3d11_environment;

typedef struct sg_wgpu_environment {
   const void* device;
} sg_wgpu_environment;

typedef struct sg_environment {
   sg_environment_defaults defaults;
   sg_metal_environment metal;
   sg_d3d11_environment d3d11;
   sg_wgpu_environment wgpu;
} sg_environment;

/*
   sg_commit_listener

   Used with function sg_add_commit_listener() to add a callback
   which will be called in sg_commit(). This is useful for libraries
   building on top of sokol-gfx to be notified about when a frame
   ends (instead of having to guess, or add a manual 'new-frame'
   function.
*/
typedef struct sg_commit_listener {
   void (*func)(void* user_data);
   void* user_data;
} sg_commit_listener;

/*
   sg_allocator

   Used in sg_desc to provide custom memory-alloc and -free functions
   to sokol_gfx.h. If memory management should be overridden, both the
   alloc_fn and free_fn function must be provided (e.g. it's not valid to
   override one function but not the other).
*/
typedef struct sg_allocator {
   void* (*alloc_fn)(size_t size, void* user_data);
   void (*free_fn)(void* ptr, void* user_data);
   void* user_data;
} sg_allocator;

/*
   sg_logger

   Used in sg_desc to provide a logging function. Please be aware
   that without logging function, sokol-gfx will be completely
   silent, e.g. it will not report errors, warnings and
   validation layer messages. For maximum error verbosity,
   compile in debug mode (e.g. NDEBUG *not* defined) and provide a
   compatible logger function in the sg_setup() call
   (for instance the standard logging function from sokol_log.h).
*/
typedef struct sg_logger {
   void (*func)(
       const char* tag,                // always "sg"
       uint32_t log_level,             // 0=panic, 1=error, 2=warning, 3=info
       uint32_t log_item_id,           // SG_LOGITEM_*
       const char* message_or_null,    // a message string, may be nullptr in release mode
       uint32_t line_nr,               // line number in sokol_gfx.h
       const char* filename_or_null,   // source filename, may be nullptr in release mode
       void* user_data);
   void* user_data;
} sg_logger;

typedef struct sg_desc {
   uint32_t _start_canary;
   int buffer_pool_size;
   int image_pool_size;
   int sampler_pool_size;
   int shader_pool_size;
   int pipeline_pool_size;
   int attachments_pool_size;
   int uniform_buffer_size;
   int max_commit_listeners;
   bool disable_validation;    // disable validation layer even in debug mode, useful for tests
   bool d3d11_shader_debugging;    // if true, HLSL shaders are compiled with D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION
   bool mtl_force_managed_storage_mode; // for debugging: use Metal managed storage mode for resources even with UMA
   bool mtl_use_command_buffer_with_retained_references;    // Metal: use a managed MTLCommandBuffer which ref-counts used resources
   bool wgpu_disable_bindgroups_cache;  // set to true to disable the WebGPU backend BindGroup cache
   int wgpu_bindgroups_cache_size;      // number of slots in the WebGPU bindgroup cache (must be 2^N)
   sg_allocator allocator;
   sg_logger logger; // optional log function override
   sg_environment environment;
   uint32_t _end_canary;
} sg_desc;

// setup and misc functions
void sg_setup(const sg_desc* desc);
void sg_shutdown(void);
bool sg_isvalid(void);
void sg_reset_state_cache(void);
sg_trace_hooks sg_install_trace_hooks(const sg_trace_hooks* trace_hooks);
void sg_push_debug_group(const char* name);
void sg_pop_debug_group(void);
bool sg_add_commit_listener(sg_commit_listener listener);
bool sg_remove_commit_listener(sg_commit_listener listener);

// resource creation, destruction and updating
sg_buffer sg_make_buffer(const sg_buffer_desc* desc);
sg_image sg_make_image(const sg_image_desc* desc);
sg_sampler sg_make_sampler(const sg_sampler_desc* desc);
sg_shader sg_make_shader(const sg_shader_desc* desc);
sg_pipeline sg_make_pipeline(const sg_pipeline_desc* desc);
sg_attachments sg_make_attachments(const sg_attachments_desc* desc);
void sg_destroy_buffer(sg_buffer buf);
void sg_destroy_image(sg_image img);
void sg_destroy_sampler(sg_sampler smp);
void sg_destroy_shader(sg_shader shd);
void sg_destroy_pipeline(sg_pipeline pip);
void sg_destroy_attachments(sg_attachments atts);
void sg_update_buffer(sg_buffer buf, const sg_range* data);
void sg_update_image(sg_image img, const sg_image_data* data);
int sg_append_buffer(sg_buffer buf, const sg_range* data);
bool sg_query_buffer_overflow(sg_buffer buf);
bool sg_query_buffer_will_overflow(sg_buffer buf, size_t size);

// rendering functions
void sg_begin_pass(const sg_pass* pass);
void sg_apply_viewport(int x, int y, int width, int height, bool origin_top_left);
void sg_apply_viewportf(float x, float y, float width, float height, bool origin_top_left);
void sg_apply_scissor_rect(int x, int y, int width, int height, bool origin_top_left);
void sg_apply_scissor_rectf(float x, float y, float width, float height, bool origin_top_left);
void sg_apply_pipeline(sg_pipeline pip);
void sg_apply_bindings(const sg_bindings* bindings);
void sg_apply_uniforms(sg_shader_stage stage, int ub_index, const sg_range* data);
void sg_draw(int base_element, int num_elements, int num_instances);
void sg_end_pass(void);
void sg_commit(void);

// getting information
sg_desc sg_query_desc(void);
sg_backend sg_query_backend(void);
sg_features sg_query_features(void);
sg_limits sg_query_limits(void);
sg_pixelformat_info sg_query_pixelformat(sg_pixel_format fmt);
int sg_query_row_pitch(sg_pixel_format fmt, int width, int row_align_bytes);
int sg_query_surface_pitch(sg_pixel_format fmt, int width, int height, int row_align_bytes);
// get current state of a resource (INITIAL, ALLOC, VALID, FAILED, INVALID)
sg_resource_state sg_query_buffer_state(sg_buffer buf);
sg_resource_state sg_query_image_state(sg_image img);
sg_resource_state sg_query_sampler_state(sg_sampler smp);
sg_resource_state sg_query_shader_state(sg_shader shd);
sg_resource_state sg_query_pipeline_state(sg_pipeline pip);
sg_resource_state sg_query_attachments_state(sg_attachments atts);
// get runtime information about a resource
sg_buffer_info sg_query_buffer_info(sg_buffer buf);
sg_image_info sg_query_image_info(sg_image img);
sg_sampler_info sg_query_sampler_info(sg_sampler smp);
sg_shader_info sg_query_shader_info(sg_shader shd);
sg_pipeline_info sg_query_pipeline_info(sg_pipeline pip);
sg_attachments_info sg_query_attachments_info(sg_attachments atts);
// get desc structs matching a specific resource (NOTE that not all creation attributes may be provided)
sg_buffer_desc sg_query_buffer_desc(sg_buffer buf);
sg_image_desc sg_query_image_desc(sg_image img);
sg_sampler_desc sg_query_sampler_desc(sg_sampler smp);
sg_shader_desc sg_query_shader_desc(sg_shader shd);
sg_pipeline_desc sg_query_pipeline_desc(sg_pipeline pip);
sg_attachments_desc sg_query_attachments_desc(sg_attachments atts);
// get resource creation desc struct with their default values replaced
sg_buffer_desc sg_query_buffer_defaults(const sg_buffer_desc* desc);
sg_image_desc sg_query_image_defaults(const sg_image_desc* desc);
sg_sampler_desc sg_query_sampler_defaults(const sg_sampler_desc* desc);
sg_shader_desc sg_query_shader_defaults(const sg_shader_desc* desc);
sg_pipeline_desc sg_query_pipeline_defaults(const sg_pipeline_desc* desc);
sg_attachments_desc sg_query_attachments_defaults(const sg_attachments_desc* desc);

// separate resource allocation and initialization (for async setup)
sg_buffer sg_alloc_buffer(void);
sg_image sg_alloc_image(void);
sg_sampler sg_alloc_sampler(void);
sg_shader sg_alloc_shader(void);
sg_pipeline sg_alloc_pipeline(void);
sg_attachments sg_alloc_attachments(void);
void sg_dealloc_buffer(sg_buffer buf);
void sg_dealloc_image(sg_image img);
void sg_dealloc_sampler(sg_sampler smp);
void sg_dealloc_shader(sg_shader shd);
void sg_dealloc_pipeline(sg_pipeline pip);
void sg_dealloc_attachments(sg_attachments attachments);
void sg_init_buffer(sg_buffer buf, const sg_buffer_desc* desc);
void sg_init_image(sg_image img, const sg_image_desc* desc);
void sg_init_sampler(sg_sampler smg, const sg_sampler_desc* desc);
void sg_init_shader(sg_shader shd, const sg_shader_desc* desc);
void sg_init_pipeline(sg_pipeline pip, const sg_pipeline_desc* desc);
void sg_init_attachments(sg_attachments attachments, const sg_attachments_desc* desc);
void sg_uninit_buffer(sg_buffer buf);
void sg_uninit_image(sg_image img);
void sg_uninit_sampler(sg_sampler smp);
void sg_uninit_shader(sg_shader shd);
void sg_uninit_pipeline(sg_pipeline pip);
void sg_uninit_attachments(sg_attachments atts);
void sg_fail_buffer(sg_buffer buf);
void sg_fail_image(sg_image img);
void sg_fail_sampler(sg_sampler smp);
void sg_fail_shader(sg_shader shd);
void sg_fail_pipeline(sg_pipeline pip);
void sg_fail_attachments(sg_attachments atts);

// frame stats
void sg_enable_frame_stats(void);
void sg_disable_frame_stats(void);
bool sg_frame_stats_enabled(void);
sg_frame_stats sg_query_frame_stats(void);

	cdef	load	archos
Other x64 
POSIX x64 BSD x64 
Linuxarm arm x64 Windows x64 	.dllOSX BSD Windows 
Linux OSX 
Other 
POSIX x64 x64 .soffi_sokol_gfxsokol_dllSOKOL_DLL_Gffirequire                                        	 	 	 	 	 	 
 
 
 
 
 
            √√≈ffi ?sokol_filename :libs ,lib sokol_gfx   5F:.devjit.Thunc.sokol-luajit.ffi.sokol.sokol_gfxÖ…LJ0F:.devjit.Thunc.sokol-luajit.ffi.sokol.sokol_app∆»   Gø ◊6   ' B 6 9  XÄ' 6   X+Ä5	 5  ' &==
5  ' &==5 '  ' &='  ' &==5  ' &==5  ' &==5  ' &==6   XÄ9 89 86  B9  B9 ' BL Å√
/********** sokol_app ****************************************************************/

/* misc constants */
enum {
   SAPP_MAX_TOUCHPOINTS = 8,
   SAPP_MAX_MOUSEBUTTONS = 3,
   SAPP_MAX_KEYCODES = 512,
   SAPP_MAX_ICONIMAGES = 8,
};

/*
   sapp_event_type

   The type of event that's passed to the event handler callback
   in the sapp_event.type field. These are not just "traditional"
   input events, but also notify the application about state changes
   or other user-invoked actions.
*/
typedef enum sapp_event_type {
   SAPP_EVENTTYPE_INVALID,
   SAPP_EVENTTYPE_KEY_DOWN,
   SAPP_EVENTTYPE_KEY_UP,
   SAPP_EVENTTYPE_CHAR,
   SAPP_EVENTTYPE_MOUSE_DOWN,
   SAPP_EVENTTYPE_MOUSE_UP,
   SAPP_EVENTTYPE_MOUSE_SCROLL,
   SAPP_EVENTTYPE_MOUSE_MOVE,
   SAPP_EVENTTYPE_MOUSE_ENTER,
   SAPP_EVENTTYPE_MOUSE_LEAVE,
   SAPP_EVENTTYPE_TOUCHES_BEGAN,
   SAPP_EVENTTYPE_TOUCHES_MOVED,
   SAPP_EVENTTYPE_TOUCHES_ENDED,
   SAPP_EVENTTYPE_TOUCHES_CANCELLED,
   SAPP_EVENTTYPE_RESIZED,
   SAPP_EVENTTYPE_ICONIFIED,
   SAPP_EVENTTYPE_RESTORED,
   SAPP_EVENTTYPE_FOCUSED,
   SAPP_EVENTTYPE_UNFOCUSED,
   SAPP_EVENTTYPE_SUSPENDED,
   SAPP_EVENTTYPE_RESUMED,
   SAPP_EVENTTYPE_QUIT_REQUESTED,
   SAPP_EVENTTYPE_CLIPBOARD_PASTED,
   SAPP_EVENTTYPE_FILES_DROPPED,
   _SAPP_EVENTTYPE_NUM,
   _SAPP_EVENTTYPE_FORCE_U32 = 0x7FFFFFFF
} sapp_event_type;

/*
   sapp_keycode

   The 'virtual keycode' of a KEY_DOWN or KEY_UP event in the
   struct field sapp_event.key_code.

   Note that the keycode values are identical with GLFW.
*/
typedef enum sapp_keycode {
   SAPP_KEYCODE_INVALID          = 0,
   SAPP_KEYCODE_SPACE            = 32,
   SAPP_KEYCODE_APOSTROPHE       = 39,  /* ' */
   SAPP_KEYCODE_COMMA            = 44,  /* , */
   SAPP_KEYCODE_MINUS            = 45,  /* - */
   SAPP_KEYCODE_PERIOD           = 46,  /* . */
   SAPP_KEYCODE_SLASH            = 47,  /* / */
   SAPP_KEYCODE_0                = 48,
   SAPP_KEYCODE_1                = 49,
   SAPP_KEYCODE_2                = 50,
   SAPP_KEYCODE_3                = 51,
   SAPP_KEYCODE_4                = 52,
   SAPP_KEYCODE_5                = 53,
   SAPP_KEYCODE_6                = 54,
   SAPP_KEYCODE_7                = 55,
   SAPP_KEYCODE_8                = 56,
   SAPP_KEYCODE_9                = 57,
   SAPP_KEYCODE_SEMICOLON        = 59,  /* ; */
   SAPP_KEYCODE_EQUAL            = 61,  /* = */
   SAPP_KEYCODE_A                = 65,
   SAPP_KEYCODE_B                = 66,
   SAPP_KEYCODE_C                = 67,
   SAPP_KEYCODE_D                = 68,
   SAPP_KEYCODE_E                = 69,
   SAPP_KEYCODE_F                = 70,
   SAPP_KEYCODE_G                = 71,
   SAPP_KEYCODE_H                = 72,
   SAPP_KEYCODE_I                = 73,
   SAPP_KEYCODE_J                = 74,
   SAPP_KEYCODE_K                = 75,
   SAPP_KEYCODE_L                = 76,
   SAPP_KEYCODE_M                = 77,
   SAPP_KEYCODE_N                = 78,
   SAPP_KEYCODE_O                = 79,
   SAPP_KEYCODE_P                = 80,
   SAPP_KEYCODE_Q                = 81,
   SAPP_KEYCODE_R                = 82,
   SAPP_KEYCODE_S                = 83,
   SAPP_KEYCODE_T                = 84,
   SAPP_KEYCODE_U                = 85,
   SAPP_KEYCODE_V                = 86,
   SAPP_KEYCODE_W                = 87,
   SAPP_KEYCODE_X                = 88,
   SAPP_KEYCODE_Y                = 89,
   SAPP_KEYCODE_Z                = 90,
   SAPP_KEYCODE_LEFT_BRACKET     = 91,  /* [ */
   SAPP_KEYCODE_BACKSLASH        = 92,  /* \ */
   SAPP_KEYCODE_RIGHT_BRACKET    = 93,  /* ] */
   SAPP_KEYCODE_GRAVE_ACCENT     = 96,  /* ` */
   SAPP_KEYCODE_WORLD_1          = 161, /* non-US #1 */
   SAPP_KEYCODE_WORLD_2          = 162, /* non-US #2 */
   SAPP_KEYCODE_ESCAPE           = 256,
   SAPP_KEYCODE_ENTER            = 257,
   SAPP_KEYCODE_TAB              = 258,
   SAPP_KEYCODE_BACKSPACE        = 259,
   SAPP_KEYCODE_INSERT           = 260,
   SAPP_KEYCODE_DELETE           = 261,
   SAPP_KEYCODE_RIGHT            = 262,
   SAPP_KEYCODE_LEFT             = 263,
   SAPP_KEYCODE_DOWN             = 264,
   SAPP_KEYCODE_UP               = 265,
   SAPP_KEYCODE_PAGE_UP          = 266,
   SAPP_KEYCODE_PAGE_DOWN        = 267,
   SAPP_KEYCODE_HOME             = 268,
   SAPP_KEYCODE_END              = 269,
   SAPP_KEYCODE_CAPS_LOCK        = 280,
   SAPP_KEYCODE_SCROLL_LOCK      = 281,
   SAPP_KEYCODE_NUM_LOCK         = 282,
   SAPP_KEYCODE_PRINT_SCREEN     = 283,
   SAPP_KEYCODE_PAUSE            = 284,
   SAPP_KEYCODE_F1               = 290,
   SAPP_KEYCODE_F2               = 291,
   SAPP_KEYCODE_F3               = 292,
   SAPP_KEYCODE_F4               = 293,
   SAPP_KEYCODE_F5               = 294,
   SAPP_KEYCODE_F6               = 295,
   SAPP_KEYCODE_F7               = 296,
   SAPP_KEYCODE_F8               = 297,
   SAPP_KEYCODE_F9               = 298,
   SAPP_KEYCODE_F10              = 299,
   SAPP_KEYCODE_F11              = 300,
   SAPP_KEYCODE_F12              = 301,
   SAPP_KEYCODE_F13              = 302,
   SAPP_KEYCODE_F14              = 303,
   SAPP_KEYCODE_F15              = 304,
   SAPP_KEYCODE_F16              = 305,
   SAPP_KEYCODE_F17              = 306,
   SAPP_KEYCODE_F18              = 307,
   SAPP_KEYCODE_F19              = 308,
   SAPP_KEYCODE_F20              = 309,
   SAPP_KEYCODE_F21              = 310,
   SAPP_KEYCODE_F22              = 311,
   SAPP_KEYCODE_F23              = 312,
   SAPP_KEYCODE_F24              = 313,
   SAPP_KEYCODE_F25              = 314,
   SAPP_KEYCODE_KP_0             = 320,
   SAPP_KEYCODE_KP_1             = 321,
   SAPP_KEYCODE_KP_2             = 322,
   SAPP_KEYCODE_KP_3             = 323,
   SAPP_KEYCODE_KP_4             = 324,
   SAPP_KEYCODE_KP_5             = 325,
   SAPP_KEYCODE_KP_6             = 326,
   SAPP_KEYCODE_KP_7             = 327,
   SAPP_KEYCODE_KP_8             = 328,
   SAPP_KEYCODE_KP_9             = 329,
   SAPP_KEYCODE_KP_DECIMAL       = 330,
   SAPP_KEYCODE_KP_DIVIDE        = 331,
   SAPP_KEYCODE_KP_MULTIPLY      = 332,
   SAPP_KEYCODE_KP_SUBTRACT      = 333,
   SAPP_KEYCODE_KP_ADD           = 334,
   SAPP_KEYCODE_KP_ENTER         = 335,
   SAPP_KEYCODE_KP_EQUAL         = 336,
   SAPP_KEYCODE_LEFT_SHIFT       = 340,
   SAPP_KEYCODE_LEFT_CONTROL     = 341,
   SAPP_KEYCODE_LEFT_ALT         = 342,
   SAPP_KEYCODE_LEFT_SUPER       = 343,
   SAPP_KEYCODE_RIGHT_SHIFT      = 344,
   SAPP_KEYCODE_RIGHT_CONTROL    = 345,
   SAPP_KEYCODE_RIGHT_ALT        = 346,
   SAPP_KEYCODE_RIGHT_SUPER      = 347,
   SAPP_KEYCODE_MENU             = 348,
} sapp_keycode;

/*
   Android specific 'tool type' enum for touch events. This lets the
   application check what type of input device was used for
   touch events.

   NOTE: the values must remain in sync with the corresponding
   Android SDK type, so don't change those.

   See https://developer.android.com/reference/android/view/MotionEvent#TOOL_TYPE_UNKNOWN
*/
typedef enum sapp_android_tooltype {
   SAPP_ANDROIDTOOLTYPE_UNKNOWN = 0,   // TOOL_TYPE_UNKNOWN
   SAPP_ANDROIDTOOLTYPE_FINGER = 1,    // TOOL_TYPE_FINGER
   SAPP_ANDROIDTOOLTYPE_STYLUS = 2,    // TOOL_TYPE_STYLUS
   SAPP_ANDROIDTOOLTYPE_MOUSE = 3,     // TOOL_TYPE_MOUSE
} sapp_android_tooltype;

/*
   sapp_touchpoint

   Describes a single touchpoint in a multitouch event (TOUCHES_BEGAN,
   TOUCHES_MOVED, TOUCHES_ENDED).

   Touch points are stored in the nested array sapp_event.touches[],
   and the number of touches is stored in sapp_event.num_touches.
*/
typedef struct sapp_touchpoint {
   uintptr_t identifier;
   float pos_x;
   float pos_y;
   sapp_android_tooltype android_tooltype; // only valid on Android
   bool changed;
} sapp_touchpoint;

/*
   sapp_mousebutton

   The currently pressed mouse button in the events MOUSE_DOWN
   and MOUSE_UP, stored in the struct field sapp_event.mouse_button.
*/
typedef enum sapp_mousebutton {
   SAPP_MOUSEBUTTON_LEFT = 0x0,
   SAPP_MOUSEBUTTON_RIGHT = 0x1,
   SAPP_MOUSEBUTTON_MIDDLE = 0x2,
   SAPP_MOUSEBUTTON_INVALID = 0x100,
} sapp_mousebutton;

/*
   These are currently pressed modifier keys (and mouse buttons) which are
   passed in the event struct field sapp_event.modifiers.
*/
enum {
   SAPP_MODIFIER_SHIFT = 0x1,      // left or right shift key
   SAPP_MODIFIER_CTRL  = 0x2,      // left or right control key
   SAPP_MODIFIER_ALT   = 0x4,      // left or right alt key
   SAPP_MODIFIER_SUPER = 0x8,      // left or right 'super' key
   SAPP_MODIFIER_LMB   = 0x100,    // left mouse button
   SAPP_MODIFIER_RMB   = 0x200,    // right mouse button
   SAPP_MODIFIER_MMB   = 0x400,    // middle mouse button
};

/*
   sapp_event

   This is an all-in-one event struct passed to the event handler
   user callback function. Note that it depends on the event
   type what struct fields actually contain useful values, so you
   should first check the event type before reading other struct
   fields.
*/
typedef struct sapp_event {
   uint64_t frame_count;               // current frame counter, always valid, useful for checking if two events were issued in the same frame
   sapp_event_type type;               // the event type, always valid
   sapp_keycode key_code;              // the virtual key code, only valid in KEY_UP, KEY_DOWN
   uint32_t char_code;                 // the UTF-32 character code, only valid in CHAR events
   bool key_repeat;                    // true if this is a key-repeat event, valid in KEY_UP, KEY_DOWN and CHAR
   uint32_t modifiers;                 // current modifier keys, valid in all key-, char- and mouse-events
   sapp_mousebutton mouse_button;      // mouse button that was pressed or released, valid in MOUSE_DOWN, MOUSE_UP
   float mouse_x;                      // current horizontal mouse position in pixels, always valid except during mouse lock
   float mouse_y;                      // current vertical mouse position in pixels, always valid except during mouse lock
   float mouse_dx;                     // relative horizontal mouse movement since last frame, always valid
   float mouse_dy;                     // relative vertical mouse movement since last frame, always valid
   float scroll_x;                     // horizontal mouse wheel scroll distance, valid in MOUSE_SCROLL events
   float scroll_y;                     // vertical mouse wheel scroll distance, valid in MOUSE_SCROLL events
   int num_touches;                    // number of valid items in the touches[] array
   sapp_touchpoint touches[SAPP_MAX_TOUCHPOINTS];  // current touch points, valid in TOUCHES_BEGIN, TOUCHES_MOVED, TOUCHES_ENDED
   int window_width;                   // current window- and framebuffer sizes in pixels, always valid
   int window_height;
   int framebuffer_width;              // = window_width * dpi_scale
   int framebuffer_height;             // = window_height * dpi_scale
} sapp_event;

/*
   sg_range

   A general pointer/size-pair struct and constructor macros for passing binary blobs
   into sokol_app.h.
*/
typedef struct sapp_range {
   const void* ptr;
   size_t size;
} sapp_range;


/*
   sapp_image_desc

   This is used to describe image data to sokol_app.h (at first, window
   icons, later maybe cursor images).

   Note that the actual image pixel format depends on the use case:

   - window icon pixels are RGBA8
*/
typedef struct sapp_image_desc {
   int width;
   int height;
   sapp_range pixels;
} sapp_image_desc;

/*
   sapp_icon_desc

   An icon description structure for use in sapp_desc.icon and
   sapp_set_icon().

   When setting a custom image, the application can provide a number of
   candidates differing in size, and sokol_app.h will pick the image(s)
   closest to the size expected by the platform's window system.

   To set sokol-app's default icon, set .sokol_default to true.

   Otherwise provide candidate images of different sizes in the
   images[] array.

   If both the sokol_default flag is set to true, any image candidates
   will be ignored and the sokol_app.h default icon will be set.
*/
typedef struct sapp_icon_desc {
   bool sokol_default;
   sapp_image_desc images[SAPP_MAX_ICONIMAGES];
} sapp_icon_desc;

/*
   sapp_allocator

   Used in sapp_desc to provide custom memory-alloc and -free functions
   to sokol_app.h. If memory management should be overridden, both the
   alloc_fn and free_fn function must be provided (e.g. it's not valid to
   override one function but not the other).
*/
typedef struct sapp_allocator {
   void* (*alloc_fn)(size_t size, void* user_data);
   void (*free_fn)(void* ptr, void* user_data);
   void* user_data;
} sapp_allocator;

/*
    sapp_logger

    Used in sapp_desc to provide a logging function. Please be aware that
    without logging function, sokol-app will be completely silent, e.g. it will
    not report errors or warnings. For maximum error verbosity, compile in
    debug mode (e.g. NDEBUG *not* defined) and install a logger (for instance
    the standard logging function from sokol_log.h).
*/
typedef struct sapp_logger {
   void (*func)(
       const char* tag,                // always "sapp"
       uint32_t log_level,             // 0=panic, 1=error, 2=warning, 3=info
       uint32_t log_item_id,           // SAPP_LOGITEM_*
       const char* message_or_null,    // a message string, may be nullptr in release mode
       uint32_t line_nr,               // line number in sokol_app.h
       const char* filename_or_null,   // source filename, may be nullptr in release mode
       void* user_data);
   void* user_data;
} sapp_logger;

typedef struct sapp_desc {
   void (*init_cb)(void);                  // these are the user-provided callbacks without user data
   void (*frame_cb)(void);
   void (*cleanup_cb)(void);
   void (*event_cb)(const sapp_event*);

   void* user_data;                        // these are the user-provided callbacks with user data
   void (*init_userdata_cb)(void*);
   void (*frame_userdata_cb)(void*);
   void (*cleanup_userdata_cb)(void*);
   void (*event_userdata_cb)(const sapp_event*, void*);

   int width;                          // the preferred width of the window / canvas
   int height;                         // the preferred height of the window / canvas
   int sample_count;                   // MSAA sample count
   int swap_interval;                  // the preferred swap interval (ignored on some platforms)
   bool high_dpi;                      // whether the rendering canvas is full-resolution on HighDPI displays
   bool fullscreen;                    // whether the window should be created in fullscreen mode
   bool alpha;                         // whether the framebuffer should have an alpha channel (ignored on some platforms)
   const char* window_title;           // the window title as UTF-8 encoded string
   bool enable_clipboard;              // enable clipboard access, default is false
   int clipboard_size;                 // max size of clipboard content in bytes
   bool enable_dragndrop;              // enable file dropping (drag'n'drop), default is false
   int max_dropped_files;              // max number of dropped files to process (default: 1)
   int max_dropped_file_path_length;   // max length in bytes of a dropped UTF-8 file path (default: 2048)
   sapp_icon_desc icon;                // the initial window icon to set
   sapp_allocator allocator;           // optional memory allocation overrides (default: malloc/free)
   sapp_logger logger;                 // logging callback override (default: NO LOGGING!)

   // backend-specific options
   int gl_major_version;               // override GL major and minor version (the default GL version is 4.1 on macOS, 4.3 elsewhere)
   int gl_minor_version;
   bool win32_console_utf8;            // if true, set the output console codepage to UTF-8
   bool win32_console_create;          // if true, attach stdout/stderr to a new console window
   bool win32_console_attach;          // if true, attach stdout/stderr to parent process
   const char* html5_canvas_name;      // the name (id) of the HTML5 canvas element, default is "canvas"
   bool html5_canvas_resize;           // if true, the HTML5 canvas size is set to sapp_desc.width/height, otherwise canvas size is tracked
   bool html5_preserve_drawing_buffer; // HTML5 only: whether to preserve default framebuffer content between frames
   bool html5_premultiplied_alpha;     // HTML5 only: whether the rendered pixels use premultiplied alpha convention
   bool html5_ask_leave_site;          // initial state of the internal html5_ask_leave_site flag (see sapp_html5_ask_leave_site())
   bool html5_bubble_mouse_events;     // if true, mouse events will bubble up to the web page
   bool html5_bubble_touch_events;     // same for touch events
   bool html5_bubble_wheel_events;     // same for wheel events
   bool html5_bubble_key_events;       // if true, bubble up *all* key events to browser, not just key events that represent characters
   bool html5_bubble_char_events;      // if true, bubble up character events to browser
   bool html5_use_emsc_set_main_loop;  // if true, use emscripten_set_main_loop() instead of emscripten_request_animation_frame_loop()
   bool html5_emsc_set_main_loop_simulate_infinite_loop;   // this will be passed as the simulate_infinite_loop arg to emscripten_set_main_loop()
   bool ios_keyboard_resizes_canvas;   // if true, showing the iOS keyboard shrinks the canvas
} sapp_desc;

/* HTML5 specific: request and response structs for
  asynchronously loading dropped-file content.
*/
typedef enum sapp_html5_fetch_error {
   SAPP_HTML5_FETCH_ERROR_NO_ERROR,
   SAPP_HTML5_FETCH_ERROR_BUFFER_TOO_SMALL,
   SAPP_HTML5_FETCH_ERROR_OTHER,
} sapp_html5_fetch_error;

typedef struct sapp_html5_fetch_response {
   bool succeeded;         // true if the loading operation has succeeded
   sapp_html5_fetch_error error_code;
   int file_index;         // index of the dropped file (0..sapp_get_num_dropped_filed()-1)
   sapp_range data;        // pointer and size of the fetched data (data.ptr == buffer.ptr, data.size <= buffer.size)
   sapp_range buffer;      // the user-provided buffer ptr/size pair (buffer.ptr == data.ptr, buffer.size >= data.size)
   void* user_data;        // user-provided user data pointer
} sapp_html5_fetch_response;

typedef struct sapp_html5_fetch_request {
   int dropped_file_index; // 0..sapp_get_num_dropped_files()-1
   void (*callback)(const sapp_html5_fetch_response*);     // response callback function pointer (required)
   sapp_range buffer;      // ptr/size of a memory buffer to load the data into
   void* user_data;        // optional userdata pointer
} sapp_html5_fetch_request;

typedef enum sapp_mouse_cursor {
   SAPP_MOUSECURSOR_DEFAULT = 0,   // equivalent with system default cursor
   SAPP_MOUSECURSOR_ARROW,
   SAPP_MOUSECURSOR_IBEAM,
   SAPP_MOUSECURSOR_CROSSHAIR,
   SAPP_MOUSECURSOR_POINTING_HAND,
   SAPP_MOUSECURSOR_RESIZE_EW,
   SAPP_MOUSECURSOR_RESIZE_NS,
   SAPP_MOUSECURSOR_RESIZE_NWSE,
   SAPP_MOUSECURSOR_RESIZE_NESW,
   SAPP_MOUSECURSOR_RESIZE_ALL,
   SAPP_MOUSECURSOR_NOT_ALLOWED,
   _SAPP_MOUSECURSOR_NUM,
} sapp_mouse_cursor;

/* returns true after sokol-app has been initialized */
bool sapp_isvalid(void);
/* returns the current framebuffer width in pixels */
int sapp_width(void);
/* same as sapp_width(), but returns float */
float sapp_widthf(void);
/* returns the current framebuffer height in pixels */
int sapp_height(void);
/* same as sapp_height(), but returns float */
float sapp_heightf(void);
/* get default framebuffer color pixel format */
int sapp_color_format(void);
/* get default framebuffer depth pixel format */
int sapp_depth_format(void);
/* get default framebuffer sample count */
int sapp_sample_count(void);
/* returns true when high_dpi was requested and actually running in a high-dpi scenario */
bool sapp_high_dpi(void);
/* returns the dpi scaling factor (window pixels to framebuffer pixels) */
float sapp_dpi_scale(void);
/* show or hide the mobile device onscreen keyboard */
void sapp_show_keyboard(bool show);
/* return true if the mobile device onscreen keyboard is currently shown */
bool sapp_keyboard_shown(void);
/* query fullscreen mode */
bool sapp_is_fullscreen(void);
/* toggle fullscreen mode */
void sapp_toggle_fullscreen(void);
/* show or hide the mouse cursor */
void sapp_show_mouse(bool show);
/* show or hide the mouse cursor */
bool sapp_mouse_shown(void);
/* enable/disable mouse-pointer-lock mode */
void sapp_lock_mouse(bool lock);
/* return true if in mouse-pointer-lock mode (this may toggle a few frames later) */
bool sapp_mouse_locked(void);
/* set mouse cursor type */
void sapp_set_mouse_cursor(sapp_mouse_cursor cursor);
/* get current mouse cursor type */
sapp_mouse_cursor sapp_get_mouse_cursor(void);
/* return the userdata pointer optionally provided in sapp_desc */
void* sapp_userdata(void);
/* return a copy of the sapp_desc structure */
sapp_desc sapp_query_desc(void);
/* initiate a "soft quit" (sends SAPP_EVENTTYPE_QUIT_REQUESTED) */
void sapp_request_quit(void);
/* cancel a pending quit (when SAPP_EVENTTYPE_QUIT_REQUESTED has been received) */
void sapp_cancel_quit(void);
/* initiate a "hard quit" (quit application without sending SAPP_EVENTTYPE_QUIT_REQUESTED) */
void sapp_quit(void);
/* call from inside event callback to consume the current event (don't forward to platform) */
void sapp_consume_event(void);
/* get the current frame counter (for comparison with sapp_event.frame_count) */
uint64_t sapp_frame_count(void);
/* get an averaged/smoothed frame duration in seconds */
double sapp_frame_duration(void);
/* write string into clipboard */
void sapp_set_clipboard_string(const char* str);
/* read string from clipboard (usually during SAPP_EVENTTYPE_CLIPBOARD_PASTED) */
const char* sapp_get_clipboard_string(void);
/* set the window title (only on desktop platforms) */
void sapp_set_window_title(const char* str);
/* set the window icon (only on Windows and Linux) */
void sapp_set_icon(const sapp_icon_desc* icon_desc);
/* gets the total number of dropped files (after an SAPP_EVENTTYPE_FILES_DROPPED event) */
int sapp_get_num_dropped_files(void);
/* gets the dropped file paths */
const char* sapp_get_dropped_file_path(int index);

/* special run-function for SOKOL_NO_ENTRY (in standard mode this is an empty stub) */
void sapp_run(const sapp_desc* desc);

/* EGL: get EGLDisplay object */
const void* sapp_egl_get_display(void);
/* EGL: get EGLContext object */
const void* sapp_egl_get_context(void);

/* HTML5: enable or disable the hardwired "Leave Site?" dialog box */
void sapp_html5_ask_leave_site(bool ask);
/* HTML5: get byte size of a dropped file */
uint32_t sapp_html5_get_dropped_file_size(int index);
/* HTML5: asynchronously load the content of a dropped file */
void sapp_html5_fetch_dropped_file(const sapp_html5_fetch_request* request);

/* Metal: get bridged pointer to Metal device object */
const void* sapp_metal_get_device(void);
/* Metal: get bridged pointer to MTKView's current drawable of type CAMetalDrawable */
const void* sapp_metal_get_current_drawable(void);
/* Metal: get bridged pointer to MTKView's depth-stencil texture of type MTLTexture */
const void* sapp_metal_get_depth_stencil_texture(void);
/* Metal: get bridged pointer to MTKView's msaa-color-texture of type MTLTexture (may be null) */
const void* sapp_metal_get_msaa_color_texture(void);
/* macOS: get bridged pointer to macOS NSWindow */
const void* sapp_macos_get_window(void);
/* iOS: get bridged pointer to iOS UIWindow */
const void* sapp_ios_get_window(void);

/* D3D11: get pointer to ID3D11Device object */
const void* sapp_d3d11_get_device(void);
/* D3D11: get pointer to ID3D11DeviceContext object */
const void* sapp_d3d11_get_device_context(void);
/* D3D11: get pointer to IDXGISwapChain object */
const void* sapp_d3d11_get_swap_chain(void);
/* D3D11: get pointer to ID3D11RenderTargetView object for rendering */
const void* sapp_d3d11_get_render_view(void);
/* D3D11: get pointer ID3D11RenderTargetView object for msaa-resolve (may return null) */
const void* sapp_d3d11_get_resolve_view(void);
/* D3D11: get pointer ID3D11DepthStencilView */
const void* sapp_d3d11_get_depth_stencil_view(void);
/* Win32: get the HWND window handle */
const void* sapp_win32_get_hwnd(void);

/* WebGPU: get WGPUDevice handle */
const void* sapp_wgpu_get_device(void);
/* WebGPU: get swapchain's WGPUTextureView handle for rendering */
const void* sapp_wgpu_get_render_view(void);
/* WebGPU: get swapchain's MSAA-resolve WGPUTextureView (may return null) */
const void* sapp_wgpu_get_resolve_view(void);
/* WebGPU: get swapchain's WGPUTextureView for the depth-stencil surface */
const void* sapp_wgpu_get_depth_stencil_view(void);

/* GL: get framebuffer object */
uint32_t sapp_gl_get_framebuffer(void);
/* GL: get major version (only valid for desktop GL) */
int sapp_gl_get_major_version(void);
/* GL: get minor version (only valid for desktop GL) */
int sapp_gl_get_minor_version(void);

/* Android: get native activity handle */
const void* sapp_android_get_native_activity(void);

	cdef	load
print	archos
Other x64 
POSIX x64 BSD x64 
Linuxarm arm x64 libWindows x64 	.dllOSX Windows 
Other OSX 
POSIX BSD 
Linux x64 x64 .soffi_sokol_appsokol_dllSOKOL_DLL_Gffirequire                                          	 	 	 	 	 	 
 
 
 
 
 
               UUWffi Dsokol_filename ?libs .lib 
sokol_app   5F:.devjit.Thunc.sokol-luajit.ffi.sokol.sokol_app‘.LJ+F:.devjit.Thunc.sokol-luajit.tools.dirtoolsê  *M
5  5 6 6 9'   ' -  98'	 -
  9

8

&
=6 6 9'   '	 &=6 6 9'   '
 &=6 6 9'   ' &=K   ¿/?.lualua/?.lua/ffi/sokol/?.lua	path/?.os	bin/;
cpathpackage WindowsdllMacOSXso
Linuxso Windows
win64MacOSX
macos
Linux
linuxffi path  +folders )extensions ( ã   !6  9  ' ' B  6  9 ' ' B 6  9   D 
match_%-	gsubstringp1  p2   <   *  -   &L Äsep base  addition   Á  bæ1'4   -  9  X1Ä' 6 9 ' B  XTÄ 9' B 9B6	 9
 ' B  XFÄ6	 9 )
 )ˇˇB 6	 9 ' BXÄ6	 9
 ) )˛ˇB - 
   BERÛX+Ä' 6 9 ' B  X#Ä 9' B)  6	 9 ' BXÄ6		 9		 ' ' B		 )	  	 X	Ä	 )
  
	 X	Ä-	    B	 ERÎ 9BL   ¿¿%s+	gsub
(.-)
"df -h -t ext4 --output=target([^%s]+)gmatchsubDrives: 
matchstring
close*a	readr
popeniofsutil fsinfo drivesWindowsos			






!###&ffi tinsert drives acmd /fh *data $  f cmd *fh %data count   f  Ü  [\	4  '  -  9 XÄ' 6 9   BXÄ- 	 
 BER˙ )  XÄL  -  - D  ¿¿¿Ägmatchstring(.-)[/]Windowsos(.-)[\]ffi tinsert tconcat sep path  parts patt 
  pseg  õ 	 &Dj6  9'   &' B  XÄ 9' B6 9 ) ) B6 9 '	 '
 B  9B   XÄ+ XÄ+ L + L 
close 	gsubsubstring*a	readrattrib 
popenio 

path  'fh res fileattr  Ú  
 9w
6  9'   &' B  XÄ 9' B6 9 ' B 9	B  XÄ+ XÄ+ L + L 
close.-: directory$
matchstring*a	readr
file 
popenio		path  fh res folder 	 ù 
 G°Ü'  -  9 XÄ6 9' ' B  XÄ 9' B  9	BXÄ6 9'
 ' B  XÄ 9' B  9	B   X Ä  6 9 '  ' &B  XÄ'   XÄ'  9' '	 B -  9 XÄ ' &XÄ ' &L  ¿/\%s+	gsub
)(.-)(.-
matchstringpwd
close*a	readrcd
popenioWindowsos.ffi expected_root_folder  Hbase_dir Fcmdh 	
cmdh 
folder_name last_folder remain   è  [ŒÆ#-  9  XÄ6 9  ) )ˇˇB XÄ+   - & - 8   XÄ  XÄ- 8 L 4  6 9 ) 5 B' 6	 9
6 9- 	  B' B  X	Ä 9' B  9BXÄ6 ' 6 
  B&BL 6 9 ' BXÄ5	 -
  9

 B
=
	-
  9

' B
=
	9
	)  > 
6
 9

 	 B
ERÎ- < L  ¿Ä¿Äint[1]newselect	name folder	name 
(.-)
gmatchtostring0[Error] dirtools.get_folderslist bad path: 
print
close*a	readrformat
popenio 	name..insert
table:substringWindowsos			!!"ffi sep list_folders_cache allfolders_cmd path  \cache_update  \colon files Ares :fh 	1  f newfile  £ ]œ’(-  9  X
Ä6 9  ' B XÄ  - & - 8   XÄ  XÄ- 8 L - 9  B' 6 9	6 9
- 	  B' B  XÄ 9' B  9B 	  XÄ- < L X	Ä6 ' 6 
  B&B4  L 6 9 ' BXÄ5	 -
  9

 B
=
	-
  9

' B
=
	9
	)  > 
6
 9

 	 B
ERÎ- < L  ¿Ä¿¿Äinsert
tableint[1]newselect	name folder 	name 
(.-)
gmatchtostring,[Error] dirtools.get_dirlist bad path: 
print
close*a	readrformat
popenioget_folderslist:	(.)$
matchstringWindowsos 			      !!!!!"""#####&&'ffi sep list_cache dirtools allfiles_cmd path  ^cache_update  ^colon 
files Bres Afh 	8  f newfile  •  :Ä6    BX	Ä-  99	
 B  XÄ+ L ERı+ L ¿	namecompare_pathsipairsdirtools list  path    i 	v  	 k  
(ã
   XÄ   XÄ'  -  9  BL ¿get_folder.dirtools path  parentpath 
 ˙  ,{ì   XÄ-  9B  -  9  B-  9 ' B XÄL    )  ) MÄ-	  9		 B		 -	  9		 B		 -	  9		 ' B		 X	ÄL OÌ+  L ¿get_parentsokol-luajitpath_matchget_folderslistget_app_path.dirtools start_path  -parent_up  -folder_name  -list "current 	  i  D   #™  -   &L Äsep path  child  newpath  v  	&≥-  9   B-  9 BK  ¿add_default_pathsget_app_pathdirtools base_path  
path  ù 
 * =Ë º6   ' B 4  6 96 93 =' 9 	 XÄ'
 3 =3 =3 =3 =9 	 XÄ3 =XÄ3 =3 =' 9 	 XÄ' ' 9 	 XÄ' 4  4  3	 =	3	 =	3	! =	 3	# =	"3	% =	$3	' =	&3	) =	(2  ÄL  	init change_folder find_folder get_parent path_match get_dirlist get_folderslistls -p %s | grep -v /dir /ON /A-D /B %sls -p %s | grep /dir /ON /AD /B %s get_app_path  is_folder get_folder get_drives combine_path compare_paths/Windowsos\ add_default_pathsconcatinsert
tableffirequire               & & - - X X e e i i i u u u Å Å † † § • • • • ¶ ß ß ß ß ´ ¨ — — ˝ ˝ ''..66::ffi :dirtools 9tinsert 7tconcat 5sep 2allfolders_cmd allfiles_cmd list_folders_cache list_cache   	load0F:.devjit.Thunc.sokol-luajit.tools.dirtoolspreloadpackage   r  r r ƒr ƒƒÉƒÉÉ°É°°…°……¯…¯¯u¯uuœuœœœt "  